<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>诺诺清蔓</title>
  
  <subtitle>简单，美好，奋发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lvqingyan.com/"/>
  <updated>2018-05-15T16:27:47.000Z</updated>
  <id>http://lvqingyan.com/</id>
  
  <author>
    <name>吕清燕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公益Eureka Server与定制方法</title>
    <link href="http://lvqingyan.com/sc-diy-eureka/"/>
    <id>http://lvqingyan.com/sc-diy-eureka/</id>
    <published>2018-05-14T06:00:00.000Z</published>
    <updated>2018-05-15T16:27:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>: 本文主要简单介绍如何定制一个eureka server，并直接指出最优的定制方式。</p><a id="more"></a><h2 id="1-Spring-Cloud中国公益Eureka-Server"><a href="#1-Spring-Cloud中国公益Eureka-Server" class="headerlink" title="1. Spring Cloud中国公益Eureka Server"></a>1. Spring Cloud中国公益Eureka Server</h2><p>Eureka Server为作为Spring Cloud开发过程中常用的注册中心组件，作为基础设施组件，开发学习过程中，经常需要自己创建Eureka Server应用和重启。为了帮助开发者快速学习入门。Spring Cloud中国社区特搭建一个公益注册中心，仅作为帮助Spring Cloud的开发者进行学习和调试。为了更好服务大家，请勿对本注册中心进行压测。定制的Eureka Server注册中心UI如下所示。</p><p><img src="http://springcloud-new.oss-cn-shenzhen.aliyuncs.com/1966ed6f184d06c2ab793dcaf2c41c8b.jpeg?Expires=1841654009&amp;OSSAccessKeyId=LTAI57F52hRuWq3h&amp;Signature=OeNSoXly3WYi9wfNq3guMPq%2Bt48%3D" alt=""></p><h3 id="1-1-访问地址"><a href="#1-1-访问地址" class="headerlink" title="1.1 访问地址"></a>1.1 访问地址</h3><p> <a href="http://eureka.springcloud.cn" title="http://eureka.springcloud.cn" target="_blank" rel="external">http://eureka.springcloud.cn</a></p><h2 id="2-定制Eureka-Serrver的UI"><a href="#2-定制Eureka-Serrver的UI" class="headerlink" title="2.定制Eureka Serrver的UI"></a>2.定制Eureka Serrver的UI</h2><h3 id="2-1-为什么要定制Eureka-Server"><a href="#2-1-为什么要定制Eureka-Server" class="headerlink" title="2.1 为什么要定制Eureka Server"></a>2.1 为什么要定制Eureka Server</h3><p> 原因两点:</p><ul><li>1.觉得默认的UI比较丑  </li><li>2.Eureka Server想客制化一下</li></ul><blockquote><p>至于Spring Cloud Eureka的UI客制化成什么样子由你而定！</p></blockquote><h2 id="3-两种方法定制Eureka-Server"><a href="#3-两种方法定制Eureka-Server" class="headerlink" title="3. 两种方法定制Eureka Server"></a>3. 两种方法定制Eureka Server</h2><h3 id="3-1-直接修改eureka-server的源代码"><a href="#3-1-直接修改eureka-server的源代码" class="headerlink" title="3.1 直接修改eureka server的源代码"></a>3.1 直接修改eureka server的源代码</h3><p>   直接修改eureka server的源代码，该方法是最纯的方式，而且每次有一个Eureka Server的版本都需要去修改。</p><h3 id="3-2-只修改Eureka-Server的UI"><a href="#3-2-只修改Eureka-Server的UI" class="headerlink" title="3.2 只修改Eureka Server的UI"></a>3.2 只修改Eureka Server的UI</h3><p>只需要修改对应的html+css+文案即可，完全不用去修改Eureka Server的源码,强烈推荐。</p><blockquote><p>源码参考地址:<a href="https://github.com/SpringCloud/spring-cloud-eureka" target="_blank" rel="external">https://github.com/SpringCloud/spring-cloud-eureka</a></p></blockquote><h3 id="3-3-为什么我定制自己的UI加进去"><a href="#3-3-为什么我定制自己的UI加进去" class="headerlink" title="3.3 为什么我定制自己的UI加进去"></a>3.3 为什么我定制自己的UI加进去</h3><p> 为什么我定制自己的UI加进去，就可以直接Run，那源码代码中的UI是不是被覆盖了？<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.springcloud.eureka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-server-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p><blockquote><p>如上maven配置所示，官方的spring-cloud-starter-netflix-eureka-server依赖信息配置在下面，由maven的依赖加载顺序决定，定制的UI优先加载显示。</p></blockquote><h2 id="4-如何在项目中使用DIY的Eureka-Server"><a href="#4-如何在项目中使用DIY的Eureka-Server" class="headerlink" title="4. 如何在项目中使用DIY的Eureka Server"></a>4. 如何在项目中使用DIY的Eureka Server</h2><p>只需要配置maven依赖即可:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.springcloud.eureka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-server-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;: 本文主要简单介绍如何定制一个eureka server，并直接指出最优的定制方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Eureka Server" scheme="http://lvqingyan.com/categories/Eureka-Server/"/>
    
    
      <category term="Eureka Server" scheme="http://lvqingyan.com/tags/Eureka-Server/"/>
    
  </entry>
  
  <entry>
    <title>中小型互联网公司微服务实践-经验和教训</title>
    <link href="http://lvqingyan.com/sc-zq/"/>
    <id>http://lvqingyan.com/sc-zq/</id>
    <published>2017-10-19T04:23:31.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次写了一篇文章叫<a href="https://mp.weixin.qq.com/s/vnWXpH5pv-FAzLZfbgTGvg" target="_blank" rel="external">Spring Cloud在国内中小型公司能用起来吗?</a>介绍了Spring Cloud是否能在中小公司使用起来，这篇文章是它的姊妹篇。其实我们在这条路上已经走了一年多，从16年初到现在。在使用Spring Cloud之前我们对微服务实践是没有太多的体会和经验的。从最初的开源软件<a href="https://github.com/cloudfavorites/favorites-web" target="_blank" rel="external">云收藏</a>来熟悉Spring Boot，到项目中的慢慢使用，再到最后全面拥抱Spring Cloud。这篇文章就给大家介绍一下我们使用Spring Boot/Cloud一年多的经验。<br><a id="more"></a></p><p>在开始之前我们先介绍一下几个概念，什么是微服务，它的特点是什么?<br>Spring Boot/Cloud都做了那些事情？他们三者之间又有什么联系？</p><h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><p>微服务的概念源于2014年3月Martin Fowler所写的一篇文章“<a href="http://martinfowler.com/articles/microservices.html" target="_blank" rel="external">Microservices</a>”。</p><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p><p>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</p><h3 id="微服务架构优势"><a href="#微服务架构优势" class="headerlink" title="微服务架构优势"></a>微服务架构优势</h3><p><strong>复杂度可控</strong>：在将应用分解的同时，规避了原本复杂度无止境的积累。每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界。由于体积小、复杂度低，每个微服务可由一个小规模开发团队完全掌控，易于保持高可维护性和开发效率。</p><p><strong>独立部署</strong>：由于微服务具备独立的运行进程，所以每个微服务也可以独立部署。当某个微服务发生变更时无需编译、部署整个应用。由微服务组成的应用相当于具备一系列可并行的发布流程，使得发布更加高效，同时降低对生产环境所造成的风险，最终缩短应用交付周期。</p><p><strong>技术选型灵活</strong>：微服务架构下，技术选型是去中心化的。每个团队可以根据自身服务的需求和行业发展的现状，自由选择最适合的技术栈。由于每个微服务相对简单，故需要对技术栈进行升级时所面临的风险就较低，甚至完全重构一个微服务也是可行的。</p><p><strong>容错</strong>：当某一组建发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，形成应用全局性的不可用。在微服务架构下，故障会被隔离在单个服务中。若设计良好，其他服务可通过重试、平稳退化等机制实现应用层面的容错。</p><p><strong>扩展</strong>：单块架构应用也可以实现横向扩展，就是将整个应用完整的复制到不同的节点。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。</p><h3 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot"></a>什么是Spring Boot</h3><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是Spring Boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，Spring Boot整合了所有的框架（不知道这样比喻是否合适）。</p><p>Spring Boot简化了基于Spring的应用开发，通过少量的代码就能创建一个独立的、产品级别的Spring应用。 Spring Boot为Spring平台及第三方库提供开箱即用的设置，这样你就可以有条不紊地开始。Spring Boot的核心思想就是约定大于配置，多数Spring Boot应用只需要很少的Spring配置。采用Spring Boot可以大大的简化你的开发模式，所有你想集成的常用框架，它都有对应的组件支持。</p><h3 id="Spring-Cloud都做了哪些事"><a href="#Spring-Cloud都做了哪些事" class="headerlink" title="Spring Cloud都做了哪些事"></a>Spring Cloud都做了哪些事</h3><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包</p><p>以下为Spring Cloud的核心功能：  </p><ul><li>分布式/版本化配置</li><li>服务注册和发现</li><li>路由</li><li>服务和服务之间的调用</li><li>负载均衡</li><li>断路器</li><li>分布式消息传递</li></ul><p>我们再来看一张图：</p><p><img src="http://www.ityouknow.com/assets/images/2017/springcloud/spring-cloud-architecture.png" alt=""></p><p>通过这张图，我们来了解一下各组件配置使用运行流程：</p><ul><li>1、请求统一通过API网关（Zuul）来访问内部服务.  </li><li>2、网关接收到请求后，从注册中心（Eureka）获取可用服务  </li><li>3、由Ribbon进行均衡负载后，分发到后端具体实例  </li><li>4、微服务之间通过Feign进行通信处理业务</li><li>5、Hystrix负责处理服务超时熔断</li><li>6、Turbine监控服务间的调用和熔断相关指标</li></ul><h3 id="Spring-Cloud体系介绍"><a href="#Spring-Cloud体系介绍" class="headerlink" title="Spring Cloud体系介绍"></a>Spring Cloud体系介绍</h3><p>上图只是Spring Cloud体系的一部分，Spring Cloud共集成了19个子项目，里面都包含一个或者多个第三方的组件或者框架！</p><p>Spring Cloud 工具框架</p><p>1、Spring Cloud Config 配置中心，利用git集中管理程序的配置。<br>2、Spring Cloud Netflix 集成众多Netflix的开源软件<br>3、Spring Cloud Bus 消息总线，利用分布式消息将服务和服务实例连接在一起，用于在一个集群中传播状态的变化<br>4、Spring Cloud for Cloud Foundry 利用Pivotal Cloudfoundry集成你的应用程序<br>5、Spring Cloud Cloud Foundry Service Broker 为建立管理云托管服务的服务代理提供了一个起点。<br>6、Spring Cloud Cluster 基于Zookeeper, Redis, Hazelcast, Consul实现的领导选举和平民状态模式的抽象和实现。<br>7、Spring Cloud Consul 基于Hashicorp Consul实现的服务发现和配置管理。<br>8、Spring Cloud Security 在Zuul代理中为OAuth2 rest客户端和认证头转发提供负载均衡<br>9、Spring Cloud Sleuth SpringCloud应用的分布式追踪系统，和Zipkin，HTrace，ELK兼容。<br>10、Spring Cloud Data Flow 一个云本地程序和操作模型，组成数据微服务在一个结构化的平台上。<br>11、Spring Cloud Stream 基于Redis,Rabbit,Kafka实现的消息微服务，简单声明模型用以在Spring Cloud应用中收发消息。<br>12、Spring Cloud Stream App Starters 基于Spring Boot为外部系统提供spring的集成<br>13、Spring Cloud Task 短生命周期的微服务，为SpringBooot应用简单声明添加功能和非功能特性。<br>14、Spring Cloud Task App Starters<br>15、Spring Cloud Zookeeper 服务发现和配置管理基于Apache Zookeeper。<br>16、Spring Cloud for Amazon Web Services 快速和亚马逊网络服务集成。<br>17、Spring Cloud Connectors 便于PaaS应用在各种平台上连接到后端像数据库和消息经纪服务。<br>18、Spring Cloud Starters （项目已经终止并且在Angel.SR2后的版本和其他项目合并）<br>19、Spring Cloud CLI 插件用Groovy快速的创建Spring Cloud组件应用。  </p><blockquote><p>当然这个数量还在一直增加…</p></blockquote><h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><p>微服务是一种架构的理念，提出了微服务的设计原则，从理论为具体的技术落地提供了指导思想。Spring Boot是一套快速配置脚手架，可以基于Spring Boot快速开发单个微服务；Spring Cloud是一个基于Spring Boot实现的服务治理工具包；Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架。</p><p><strong>Spring Boot/Cloud是微服务实践的最佳落地方案。</strong></p><h2 id="实战经历"><a href="#实战经历" class="headerlink" title="实战经历"></a>实战经历</h2><h3 id="遇到问题，寻找方案"><a href="#遇到问题，寻找方案" class="headerlink" title="遇到问题，寻找方案"></a>遇到问题，寻找方案</h3><p>2015年初的时候，因为公司业务的大量发展，我们开始对原有的业务进行拆分，新上的业务线也全部使用独立的项目来开发，项目和项目之间通过http接口进行访问。15年的业务发展非常迅速，项目数量也就相应急剧扩大，到了15底的时候项目达60多个，当项目数达到30几个的时候，其实我们就遇到了问题，经常某个项目因为扩展增加了新的IP地址，我们就需要被动的更新好几个相关的项目。服务越来越多，服务之间的调用关系也越来越复杂，有时候想画一张图来表示项目和项目之间的依赖关系，线条密密麻麻无法看清。网上有一张图可以表达我们的心情。</p><p><img src="http://www.ityouknow.com/assets/images/2017/architecture/calling_relation.png" alt="">  </p><p>这个时候我们就想找一种方案，可以将我们这么多分布式的服务给管理起来，到网上进行了技术调研。我们发现有两款开源软件比较适合我们，一个是Dubbo，一个是Spring Cloud。</p><p>其实刚开始我们是走了一些弯路的。这两款框架我们当时都不熟悉，当时国内使用Spring Cloud进行开发的企业非常的少，我在网上也几乎没找到太多应用的案例。但是Dubbo当时在国内的使用还是挺普遍的，相关的资料各方面都比较完善。因此在公司扩展新业务线众筹平台的时候，技术选型就先定了Dubbo，因为也是全新的业务没有什么负担，这个项目我们大概开发了六个月投产，上线之初也遇到了一些问题，但最终还比较顺利。</p><p>在新业务线选型使用Dubbo的同时，我们也没有完全放弃Spring Cloud，我们抽出了一两名开发人员学习Spring Boot我也参与其中，为了验证Spring Boot是否可以到达实战的标准，我们在业余的时间使用Spring Boot开发了一款开源软件<a href="http://favorites.ren/" target="_blank" rel="external">云收藏</a>，经过这个项目的实战验证我们对Spring Boot就有了信心。最重要的是大家体会到使用Spring Boot的各种便利之后，就再也不想使用传统的方式来进行开发了。</p><p>但是还有一个问题，在选择了Spring Boot进行新业务开发的同时，并没有解决我们上面的那个问题，服务于服务直接调用仍然比较复杂和传统，这时候我们就开始研究Spring Cloud。因为大家在前期对Spring Boot有了足够的了解，因此学习Sprig Cloud就显得顺风顺水了。所以在使用Dubbo半年之后，我们又全面开始拥抱Spring Cloud。</p><h3 id="为什么选择使用Spring-Cloud而放弃了Dubbo"><a href="#为什么选择使用Spring-Cloud而放弃了Dubbo" class="headerlink" title="为什么选择使用Spring Cloud而放弃了Dubbo"></a>为什么选择使用Spring Cloud而放弃了Dubbo</h3><p>可能大家会问，为什么选择了使用Dubbo之后，而又选择全面使用Spring Cloud呢？其中有几个原因：</p><p>1）从两个公司的背景来谈：Dubbo，是阿里巴巴服务化治理的核心框架，并被广泛应用于中国各互联网公司；Spring Cloud是大名鼎鼎的Spring家族的产品。阿里巴巴是一个商业公司，虽然也开源了很多的顶级的项目，但从整体战略上来讲，仍然是服务于自身的业务为主。Spring专注于企业级开源框架的研发，不论是在中国还是在世界上使用都非常广泛，开发出通用、开源、稳健的开源框架就是他们的主业。</p><p>2）从社区活跃度这个角度来对比，Dubbo虽然也是一个非常优秀的服务治理框架，并且在服务治理、灰度发布、流量分发这方面做的比Spring Cloud还好，除过当当网在基础上增加了rest支持外，已有两年多的时间几乎都没有任何更新了。在使用过程中出现问题，提交到github的Issue也少有回复。</p><p>相反Spring Cloud自从发展到现在，仍然在不断的高速发展，从github上提交代码的频度和发布版本的时间间隔就可以看出，现在Spring Cloud即将发布2.0版本，到了后期会更加完善和稳定。</p><p>3) 从整个大的平台架构来讲，dubbo框架只是专注于服务之间的治理，如果我们需要使用配置中心、分布式跟踪这些内容都需要自己去集成，这样无形中使用dubbo的难度就会增加。Spring Cloud几乎考虑了服务治理的方方面面，更有Spring Boot这个大将的支持，开发起来非常的便利和简单。</p><p>4）从技术发展的角度来讲，Dubbo刚出来的那会技术理念还是非常先进，解决了各大互联网公司服务治理的问题，中国的各中小公司也从中受益不少。经过了这么多年的发展，互联网行业也是涌现了更多先进的技术和理念，Dubbo一直停滞不前，自然有些掉队，有时候我个人也会感到有点可惜，如果Dubbo一直沿着当初的那个路线发展，并且延伸到周边，今天可能又是另一番景象了。</p><p>Spring 推出Spring Boot/Cloud也是因为自身的很多原因。Spring最初推崇的轻量级框架，随着不断的发展也越来越庞大，随着集成项目越来越多，配置文件也越来越混乱，慢慢的背离最初的理念。随着这么多年的发展，微服务、分布式链路跟踪等更多新的技术理念的出现，Spring急需一款框架来改善以前的开发模式，因此才会出现Spring Boot/Cloud项目，我们现在访问Spring官网，会发现Spring Boot和Spring Cloud已经放到首页最重点突出的三个项目中的前两个，可见Spring对这两个框架的重视程度。</p><p><strong>总结一下，dubbo曾经确实很牛逼，但是Spring Cloud是站在近些年技术发展之上进行开发，因此更具技术代表性。</strong></p><h3 id="如何进行微服务架构演进"><a href="#如何进行微服务架构演进" class="headerlink" title="如何进行微服务架构演进"></a>如何进行微服务架构演进</h3><p>当我们将所有的新业务都使用Spring Cloud这套架构之后，就会出现这样一个现象，公司的系统被分成了两部分，一部分是传统架构的项目，一部分是微服务架构的项目，如何让这两套配合起来使用就成为了关键，这时候Spring Cloud里面的一个关键组件解决了我们的问题，就是Zuul。在Spring Cloud架构体系内的所有微服务都通过Zuul来对外提供统一的访问入口，所有需要和微服务架构内部服务进行通讯的请求都走统一网关。如下图：</p><p><img src="http://www.ityouknow.com/assets/images/2017/architecture/framework4.jpg" alt=""></p><p>从上图可以看出我们对服务进行了分类，有四种：基础服务、业务服务、组合服务、前置服务。不同服务迁移的优先级不同</p><ul><li><strong>基础服务</strong>，是一些基础组件，与具体的业务无关。比如：短信服务、邮件服务。这里的服务最容易摘出来做微服务，也是我们第一优先级分离出来的服务。</li><li><strong>业务服务</strong>，是一些垂直的业务系统，只处理单一的业务类型，比如：风控系统、积分系统、合同系统。这类服务职责比较单一，根据业务情况来选择是否迁移，比如：如果突然有需求对积分系统进行大优化，我们就趁机将积分系统进行改造，是我们的第二优先级分离出来的服务。</li><li><strong>前置服务</strong>，前置服务一般为服务的接入或者输出服务，比如网站的前端服务、app的服务接口这类，这是我们第三优先级分离出来的服务。</li><li><strong>组合服务</strong>，组合服务就是涉及到了具体的业务，比如买标过程，需要调用很多垂直的业务服务，这类的服务我们一般放到最后再进行微服务化架构来改造，因为这类服务最为复杂，除非涉及到大的业务逻辑变更，我们是不会轻易进行迁移。</li></ul><p>在这四类服务之外，新上线的业务全部使用Sprng Boot/Cloud这套技术栈。就这样，我们从开源项目<a href="https://github.com/cloudfavorites/favorites-web" target="_blank" rel="external">云收藏</a>开始，上线几个Spring Boot项目，到现在公司绝大部分的项目都是在Spring Cloud这个架构体系中。</p><h2 id="经验和教训"><a href="#经验和教训" class="headerlink" title="经验和教训"></a>经验和教训</h2><h3 id="架构演化的步骤"><a href="#架构演化的步骤" class="headerlink" title="架构演化的步骤"></a>架构演化的步骤</h3><ul><li>在确定使用Spring Boot/Cloud这套技术栈进行微服务改造之前，先梳理平台的服务，对不同的服务进行分类，以确认演化的节奏。</li><li>先让团队熟悉Spring Boot技术，并且优先在基础服务上进行技术改造，推动改动后的项目投产上线</li><li>当团队熟悉Spring Boot之后，再推进使用Spring Cloud对原有的项目进行改造。</li><li>在进行微服务改造过程中，优先应用于新业务系统，前期可以只是少量的项目进行了微服务化改造，随着大家对技术的熟悉度增加，可以加快加大微服务改造的范围</li><li>传统项目和微服务项目共存是一个很常见的情况，除非公司业务有大的变化，不建议直接迁移核心项目。</li></ul><h3 id="服务拆分原则"><a href="#服务拆分原则" class="headerlink" title="服务拆分原则"></a>服务拆分原则</h3><p>服务拆分有以下几个原则和大家分享</p><p><strong>横向拆分</strong>。按照不同的业务域进行拆分，例如订单、营销、风控、积分资源等。形成独立的业务领域微服务集群。</p><p><strong>纵向拆分</strong>。把一个业务功能里的不同模块或者组件进行拆分。例如把公共组件拆分成独立的原子服务，下沉到底层，形成相对独立的原子服务层。这样一纵一横，就可以实现业务的服务化拆分。</p><p>要做好微服务的分层：梳理和抽取核心应用、公共应用，作为独立的服务下沉到核心和公共能力层，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求</p><p>服务拆分是越小越好吗？微服务的大与小是相对的。比如在初期，我们把交易拆分为一个微服务，但是随着业务量的增大，可能一个交易系统已经慢慢变得很大，并且并发流量也不小，为了支撑更多的交易量，我会把交易系统，拆分为订单服务、投标服务、转让服务等。因此微服务的拆分力度需与具体业务相结合，总的原则是<strong>服务内部高内聚，服务之间低耦合。</strong></p><h3 id="微服务vs传统开发"><a href="#微服务vs传统开发" class="headerlink" title="微服务vs传统开发"></a>微服务vs传统开发</h3><p>使用微服务有一段时间了，这种开发模式和传统的开发模式对比，有很大的不同。</p><ul><li>分工不同，以前我们可能是一个一个模块，现在可能是一人一个系统。 </li><li>架构不同，服务的拆分是一个技术含量很高的问题，拆分是否合理对以后发展影响巨大。  </li><li>部署方式不同，如果还像以前一样部署估计累死了，自动化运维不可不上。  </li><li>容灾不同，好的微服务可以隔离故障避免服务整体down掉，坏的微服务设计仍然可以因为一个子服务出现问题导致连锁反应。</li></ul><h3 id="给数据库带来的挑战"><a href="#给数据库带来的挑战" class="headerlink" title="给数据库带来的挑战"></a>给数据库带来的挑战</h3><p>每个微服务都有自己独立的数据库，那么后台管理的联合查询怎么处理？这应该是大家会普遍遇到的一个问题，有三种处理方案。</p><p>1）严格按照微服务的划分来做，微服务相互独立，各微服务数据库也独立，后台需要展示数据时，调用各微服务的接口来获取对应的数据，再进行数据处理后展示出来，这是标准的用法，也是最麻烦的用法。</p><p>2) 将业务高度相关的表放到一个库中，将业务关系不是很紧密的表严格按照微服务模式来拆分，这样既可以使用微服务，也避免了数据库分散导致后台系统统计功能难以实现，是一个折中的方案。</p><p>3）数据库严格按照微服务的要求来切分，以满足业务高并发，实时或者准实时将各微服务数据库数据同步到NoSQL数据库中，在同步的过程中进行数据清洗，用来满足后台业务系统的使用，推荐使用MongoDB、HBase等。</p><p>三种方案在不同的公司我都使用过，第一种方案适合业务较为简单的小公司；第二种方案，适合在原有系统之上，慢慢演化为微服务架构的公司；第三种适合大型高并发的互联网公司。</p><h3 id="微服务的经验和建议"><a href="#微服务的经验和建议" class="headerlink" title="微服务的经验和建议"></a>微服务的经验和建议</h3><p>1、建议尽量不要使用Jsp，页面开发推荐使用Thymeleaf。Web项目建议独立部署Tomcat，不要使用内嵌的Tomcat，内嵌Tomcat部署Jsp项目会偶现龟速访问的情况。</p><p>2、服务编排是个好东西，主要的作用是减少项目中的相互依赖。比如现在有项目a调用项目b，项目b调用项目c…一直到h，是一个调用链，那么项目上线的时候需要先更新最底层的h再更新g…更新c更新b最后是更新项目a。这只是这一个调用链，在复杂的业务中有非常多的调用，如果要记住每一个调用链对开发运维人员来说就是灾难。</p><p>有这样一个好办法可以尽量的减少项目的相互依赖，就是服务编排，一个核心的业务处理项目，负责和各个微服务打交道。比如之前是a调用b，b掉用c，c调用d，现在统一在一个核心项目W中来处理，W服务使用a的时候去调用b，使用b的时候W去调用c，举个例子：在第三方支付业务中，有一个核心支付项目是服务编排，负责处理支付的业务逻辑，W项目使用商户信息的时候就去调用“商户系统”，需要校验设备的时候就去调用“终端系统”，需要风控的时候就调用“风控系统”，各个项目需要的依赖参数都由W来做主控。以后项目部署的时候，只需要最后启动服务编排项目即可。</p><p>3、不要为了追求技术而追求技术，确定进行微服务架构改造之前，需要考虑以下几方面的因素：<br>1）团队的技术人员是否已经具备相关技术基础。<br>2）公司业务是否适合进行微服务化改造，并不是所有的平台都适合进行微服务化改造，比如：传统行业有很多复杂垂直的业务系统。<br>3）Spring Cloud生态的技术有很多，并不是每一种技术方案都需要用上，适合自己的才是最好的。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Spring Cloud对于中小型互联网公司来说是一种福音</strong>，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p><hr><p><strong>作者：纯洁的微笑</strong><br><strong>出处：<a href="http://www.ityouknow.com/springcloud/2017/10/19/micro-service-practice.html" target="_blank" rel="external">http://www.ityouknow.com/</a></strong><br><strong>版权所有，欢迎保留原文链接进行转载：)</strong> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次写了一篇文章叫&lt;a href=&quot;https://mp.weixin.qq.com/s/vnWXpH5pv-FAzLZfbgTGvg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud在国内中小型公司能用起来吗?&lt;/a&gt;介绍了Spring Cloud是否能在中小公司使用起来，这篇文章是它的姊妹篇。其实我们在这条路上已经走了一年多，从16年初到现在。在使用Spring Cloud之前我们对微服务实践是没有太多的体会和经验的。从最初的开源软件&lt;a href=&quot;https://github.com/cloudfavorites/favorites-web&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;云收藏&lt;/a&gt;来熟悉Spring Boot，到项目中的慢慢使用，再到最后全面拥抱Spring Cloud。这篇文章就给大家介绍一下我们使用Spring Boot/Cloud一年多的经验。&lt;br&gt;
    
    </summary>
    
      <category term="社区" scheme="http://lvqingyan.com/categories/%E7%A4%BE%E5%8C%BA/"/>
    
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Zuul遗失的世界(三)</title>
    <link href="http://lvqingyan.com/sc-zuul-s3/"/>
    <id>http://lvqingyan.com/sc-zuul-s3/</id>
    <published>2017-08-15T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>摘要</strong>:  接着上一篇《Spring Cloud Zuul遗失的世界(二)》，本文主要介绍Netflix Zuul core模块的Filter链的设计和Fifter Loader和Filter Manager相关代码的设计与分析。</p><a id="more"></a><h2 id="一-Zuul-Filter的抽象设计"><a href="#一-Zuul-Filter的抽象设计" class="headerlink" title="一.Zuul Filter的抽象设计"></a>一.Zuul Filter的抽象设计</h2><h3 id="1-1-自定义Zuul-Filter"><a href="#1-1-自定义Zuul-Filter" class="headerlink" title="1.1 自定义Zuul Filter"></a>1.1 自定义Zuul Filter</h3><p>当我们使用Spring Cloud Zuul都会直接继承ZuulFilter，覆盖实现抽象类中定义的方法，如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PreFilter.class);</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"pre"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">RequestContext ctx = RequestContext.getCurrentContext();</div><div class="line">String token = ctx.getRequest().getHeader(HttpHeaders.AUTHORIZATION);</div><div class="line"></div><div class="line">String labels = TOKEN_LABEL_MAP.get(token);</div><div class="line"></div><div class="line">logger.info(<span class="string">"label: "</span> + labels);</div><div class="line"></div><div class="line">CoreHeaderInterceptor.initHystrixRequestContext(labels); <span class="comment">// zuul本身调用微服务</span></div><div class="line">ctx.addZuulRequestHeader(CoreHeaderInterceptor.HEADER_LABEL, labels); <span class="comment">// 传递给后续微服务</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-2-IZuulFilter代码"><a href="#1-2-IZuulFilter代码" class="headerlink" title="1.2  IZuulFilter代码"></a>1.2  IZuulFilter代码</h3><p>定义 IZuulFilter interface，共同的常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IZuulFilter</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * a "true" return from this method means that the run() method should be invoked</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> true if the run() method should be invoked. false will not invoke the run() method</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * if shouldFilter() is true, this method will be invoked. this method is the core method of a ZuulFilter</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> Some arbitrary artifact may be returned. Current implementation ignores it.</div><div class="line">     */</div><div class="line">    <span class="function">Object <span class="title">run</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-2-抽象类ZuulFilter代码"><a href="#1-2-抽象类ZuulFilter代码" class="headerlink" title="1.2  抽象类ZuulFilter代码"></a>1.2  抽象类ZuulFilter代码</h3><p>抽象类ZuulFilter实现IZuulFilter，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulFilter</span> <span class="keyword">implements</span> <span class="title">IZuulFilter</span>, <span class="title">Comparable</span>&lt;<span class="title">ZuulFilter</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicBooleanProperty filterDisabled =</div><div class="line">            DynamicPropertyFactory.getInstance().getBooleanProperty(disablePropertyName(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">//filter类型</span></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   </div><div class="line">    <span class="comment">// Filter的执行顺序</span></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   </div><div class="line">   <span class="comment">//是否是静态Filter</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStaticFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">disablePropertyName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"zuul."</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">"."</span> + filterType() + <span class="string">".disable"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Filter是否启动</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFilterDisabled</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> filterDisabled.get();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> ZuulFilterResult <span class="title">runFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        ZuulFilterResult zr = <span class="keyword">new</span> ZuulFilterResult();</div><div class="line">        <span class="keyword">if</span> (!isFilterDisabled()) &#123;</div><div class="line">            <span class="keyword">if</span> (shouldFilter()) &#123;</div><div class="line">                Tracer t = TracerFactory.instance().startMicroTracer(<span class="string">"ZUUL::"</span> + <span class="keyword">this</span>.getClass().getSimpleName());</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Object res = run();</div><div class="line">                    zr = <span class="keyword">new</span> ZuulFilterResult(res, ExecutionStatus.SUCCESS);</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                    t.setName(<span class="string">"ZUUL::"</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" failed"</span>);</div><div class="line">                    zr = <span class="keyword">new</span> ZuulFilterResult(ExecutionStatus.FAILED);</div><div class="line">                    zr.setException(e);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    t.stopAndLog();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                zr = <span class="keyword">new</span> ZuulFilterResult(ExecutionStatus.SKIPPED);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> zr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ZuulFilter filter)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.filterOrder(), filter.filterOrder());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二-Spring-Cloud-Zuul的Filter管理"><a href="#二-Spring-Cloud-Zuul的Filter管理" class="headerlink" title="二.Spring Cloud Zuul的Filter管理"></a>二.Spring Cloud Zuul的Filter管理</h2><p>  zuul支持动加载Filter类文件。实现原理是监控存放Filter文件的目录，定期扫描这些目录，如果发现有新Filter源码文件或者Filter源码文件有改动，则对文件进行编译加载。目前zuul支持使用Groovy编写的Filter。</p><h3 id="2-1-FilterFileManager"><a href="#2-1-FilterFileManager" class="headerlink" title="2.1 FilterFileManager"></a>2.1 FilterFileManager</h3><p> groovy的文件filter加载,通过FilterFileManager，开启一个线程，开始轮询GroovyFilterFile的目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterFileManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(FilterFileManager.class);</div><div class="line"></div><div class="line">    String[] aDirectories;</div><div class="line">    <span class="keyword">int</span> pollingIntervalSeconds;</div><div class="line">    Thread poller;</div><div class="line">    <span class="keyword">boolean</span> bRunning = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> FilenameFilter FILENAME_FILTER;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> FilterFileManager INSTANCE;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FilterFileManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFilenameFilter</span><span class="params">(FilenameFilter filter)</span> </span>&#123;</div><div class="line">        FILENAME_FILTER = filter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Initialized the GroovyFileManager.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> pollingIntervalSeconds the polling interval in Seconds</div><div class="line">     * <span class="doctag">@param</span> directories            Any number of paths to directories to be polled may be specified</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     * <span class="doctag">@throws</span> IllegalAccessException</div><div class="line">     * <span class="doctag">@throws</span> InstantiationException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> pollingIntervalSeconds, String... directories)</span> <span class="keyword">throws</span> Exception, IllegalAccessException, InstantiationException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) INSTANCE = <span class="keyword">new</span> FilterFileManager();</div><div class="line"></div><div class="line">        INSTANCE.aDirectories = directories;</div><div class="line">        INSTANCE.pollingIntervalSeconds = pollingIntervalSeconds;</div><div class="line">        INSTANCE.manageFiles();</div><div class="line">        INSTANCE.startPoller();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FilterFileManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Shuts down the poller</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">        INSTANCE.stopPoller();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopPoller</span><span class="params">()</span> </span>&#123;</div><div class="line">        bRunning = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 开启一个线程，开始轮询</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPoller</span><span class="params">()</span> </span>&#123;</div><div class="line">        poller = <span class="keyword">new</span> Thread(<span class="string">"GroovyFilterFileManagerPoller"</span>) &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">while</span> (bRunning) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        sleep(pollingIntervalSeconds * <span class="number">1000</span>);</div><div class="line">                        manageFiles();</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        poller.setDaemon(<span class="keyword">true</span>);</div><div class="line">        poller.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the directory File for a path. A Runtime Exception is thrown if the directory is in valid</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> sPath</div><div class="line">     * <span class="doctag">@return</span> a File representing the directory path</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getDirectory</span><span class="params">(String sPath)</span> </span>&#123;</div><div class="line">        File  directory = <span class="keyword">new</span> File(sPath);</div><div class="line">        <span class="keyword">if</span> (!directory.isDirectory()) &#123;</div><div class="line">            URL resource = FilterFileManager.class.getClassLoader().getResource(sPath);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                directory = <span class="keyword">new</span> File(resource.toURI());</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOG.error(<span class="string">"Error accessing directory in classloader. path="</span> + sPath, e);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!directory.isDirectory()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(directory.getAbsolutePath() + <span class="string">" is not a valid directory"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> directory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns a List&lt;File&gt; of all Files from all polled directories</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function">List&lt;File&gt; <span class="title">getFiles</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;File&gt; list = <span class="keyword">new</span> ArrayList&lt;File&gt;();</div><div class="line">        <span class="keyword">for</span> (String sDirectory : aDirectories) &#123;</div><div class="line">            <span class="keyword">if</span> (sDirectory != <span class="keyword">null</span>) &#123;</div><div class="line">                File directory = getDirectory(sDirectory);</div><div class="line">                File[] aFiles = directory.listFiles(FILENAME_FILTER);</div><div class="line">                <span class="keyword">if</span> (aFiles != <span class="keyword">null</span>) &#123;</div><div class="line">                    list.addAll(Arrays.asList(aFiles));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * puts files into the FilterLoader. The FilterLoader will only addd new or changed filters</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> aFiles a List&lt;File&gt;</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     * <span class="doctag">@throws</span> InstantiationException</div><div class="line">     * <span class="doctag">@throws</span> IllegalAccessException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processGroovyFiles</span><span class="params">(List&lt;File&gt; aFiles)</span> <span class="keyword">throws</span> Exception, InstantiationException, IllegalAccessException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (File file : aFiles) &#123;</div><div class="line">            <span class="comment">//更新则通过FilterLoader.putFilter()置入FilterRegistr</span></div><div class="line">            FilterLoader.getInstance().putFilter(file);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//每次轮询，处理目录内的所有*.groovy文件，即调用FilterLoader.getInstance().putFilter(file);</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manageFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IllegalAccessException, InstantiationException </span>&#123;</div><div class="line">        List&lt;File&gt; aFiles = getFiles();</div><div class="line">        processGroovyFiles(aFiles);</div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-2-FilterLoader"><a href="#2-2-FilterLoader" class="headerlink" title="2.2 FilterLoader"></a>2.2 FilterLoader</h3><p>   com.netflix.zuul.FilterLoader，编译、加载filter文件，并且检查源文件是否有变更，除此之外，它还按照filterType组织并维护List<zuulfilter></zuulfilter></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterLoader</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">static</span> FilterLoader INSTANCE = <span class="keyword">new</span> FilterLoader();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(FilterLoader.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Long&gt; filterClassLastModified = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Long&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, String&gt; filterClassCode = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, String&gt; filterCheck = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, List&lt;ZuulFilter&gt;&gt; hashFiltersByType = <span class="keyword">new</span> ConcurrentHashMap&lt;String, List&lt;ZuulFilter&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> FilterRegistry filterRegistry = FilterRegistry.instance();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> DynamicCodeCompiler COMPILER;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> FilterFactory FILTER_FACTORY = <span class="keyword">new</span> DefaultFilterFactory();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets a Dynamic Code Compiler</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> compiler</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompiler</span><span class="params">(DynamicCodeCompiler compiler)</span> </span>&#123;</div><div class="line">        COMPILER = compiler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// overidden by tests</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilterRegistry</span><span class="params">(FilterRegistry r)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.filterRegistry = r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets a FilterFactory</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> factory</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilterFactory</span><span class="params">(FilterFactory factory)</span> </span>&#123;</div><div class="line">        FILTER_FACTORY = factory;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@return</span> Singleton FilterLoader</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FilterLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Given source and name will compile and store the filter if it detects that the filter code has changed or</div><div class="line">     * the filter doesn't exist. Otherwise it will return an instance of the requested ZuulFilter</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> sCode source code</div><div class="line">     * <span class="doctag">@param</span> sName name of the filter</div><div class="line">     * <span class="doctag">@return</span> the ZuulFilter</div><div class="line">     * <span class="doctag">@throws</span> IllegalAccessException</div><div class="line">     * <span class="doctag">@throws</span> InstantiationException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> ZuulFilter <span class="title">getFilter</span><span class="params">(String sCode, String sName)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (filterCheck.get(sName) == <span class="keyword">null</span>) &#123;</div><div class="line">            filterCheck.putIfAbsent(sName, sName);</div><div class="line">            <span class="keyword">if</span> (!sCode.equals(filterClassCode.get(sName))) &#123;</div><div class="line">                LOG.info(<span class="string">"reloading code "</span> + sName);</div><div class="line">                filterRegistry.remove(sName);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ZuulFilter filter = filterRegistry.get(sName);</div><div class="line">        <span class="keyword">if</span> (filter == <span class="keyword">null</span>) &#123;</div><div class="line">            Class clazz = COMPILER.compile(sCode, sName);</div><div class="line">            <span class="keyword">if</span> (!Modifier.isAbstract(clazz.getModifiers())) &#123;</div><div class="line">                filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> filter;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@return</span> the total number of Zuul filters</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterInstanceMapSize</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> filterRegistry.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * From a file this will read the ZuulFilter source code, compile it, and add it to the list of current filters</div><div class="line">     * a true response means that it was successful.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> file</div><div class="line">     * <span class="doctag">@return</span> true if the filter in file successfully read, compiled, verified and added to Zuul</div><div class="line">     * <span class="doctag">@throws</span> IllegalAccessException</div><div class="line">     * <span class="doctag">@throws</span> InstantiationException</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putFilter</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String sName = file.getAbsolutePath() + file.getName();</div><div class="line">        <span class="comment">// 如果文件在上次加载后发生了变化，重新编译加载</span></div><div class="line">        <span class="keyword">if</span> (filterClassLastModified.get(sName) != <span class="keyword">null</span> &amp;&amp; (file.lastModified() != filterClassLastModified.get(sName))) &#123;</div><div class="line">            LOG.debug(<span class="string">"reloading filter "</span> + sName);</div><div class="line">            filterRegistry.remove(sName);</div><div class="line">        &#125;</div><div class="line">        ZuulFilter filter = filterRegistry.get(sName);</div><div class="line">        <span class="keyword">if</span> (filter == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 编译、加载文件</span></div><div class="line">            Class clazz = COMPILER.compile(file);</div><div class="line">            <span class="keyword">if</span> (!Modifier.isAbstract(clazz.getModifiers())) &#123;</div><div class="line">                filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz);</div><div class="line">                <span class="comment">// 清空filter.filterType()类型的List&lt;Filter&gt;缓存，重新构建</span></div><div class="line">                List&lt;ZuulFilter&gt; list = hashFiltersByType.get(filter.filterType());</div><div class="line">                <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//重新构建某种类型Filter的List</span></div><div class="line">                    hashFiltersByType.remove(filter.filterType()); <span class="comment">//rebuild this list</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">//向Filter Registry放入新的Filter</span></div><div class="line">                filterRegistry.put(file.getAbsolutePath() + file.getName(), filter);</div><div class="line">                filterClassLastModified.put(sName, file.lastModified());</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据Filter类型返回同一类型的Filter</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> filterType</div><div class="line">     * <span class="doctag">@return</span> a List&lt;ZuulFilter&gt;</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;ZuulFilter&gt; <span class="title">getFiltersByType</span><span class="params">(String filterType)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;ZuulFilter&gt; list = hashFiltersByType.get(filterType);</div><div class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) <span class="keyword">return</span> list;</div><div class="line"></div><div class="line">        list = <span class="keyword">new</span> ArrayList&lt;ZuulFilter&gt;();</div><div class="line"></div><div class="line">        Collection&lt;ZuulFilter&gt; filters = filterRegistry.getAllFilters();</div><div class="line">        <span class="keyword">for</span> (Iterator&lt;ZuulFilter&gt; iterator = filters.iterator(); iterator.hasNext(); ) &#123;</div><div class="line">            ZuulFilter filter = iterator.next();</div><div class="line">            <span class="keyword">if</span> (filter.filterType().equals(filterType)) &#123;</div><div class="line">                list.add(filter);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//根据</span></div><div class="line">        Collections.sort(list); </div><div class="line"></div><div class="line">        hashFiltersByType.putIfAbsent(filterType, list);</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>把Groovy源码进行编译并加载进jvm里。</p></blockquote><h3 id="2-3-FilterRegistry"><a href="#2-3-FilterRegistry" class="headerlink" title="2.3 FilterRegistry"></a>2.3 FilterRegistry</h3><p> com.netflix.zuul.filters.FilterRegistry可以理解为就是用ConcurrentHashMap，在运行过程中存储Filter的数据结构，进行Put或Revome操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FilterRegistry INSTANCE = <span class="keyword">new</span> FilterRegistry();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FilterRegistry <span class="title">instance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ZuulFilter&gt; filters = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ZuulFilter&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FilterRegistry</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ZuulFilter <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filters.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ZuulFilter <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filters.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ZuulFilter filter)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.filters.putIfAbsent(key, filter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filters.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ZuulFilter&gt; <span class="title">getAllFilters</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filters.values();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-4-DynamicCodeCompiler"><a href="#2-4-DynamicCodeCompiler" class="headerlink" title="2.4 DynamicCodeCompiler"></a>2.4 DynamicCodeCompiler</h3><p> com.netflix.zuul.DynamicCodeCompiler.java,主要是一个接口，定义两种加载编译源码的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DynamicCodeCompiler</span> </span>&#123;</div><div class="line">    <span class="function">Class <span class="title">compile</span><span class="params">(String sCode, String sName)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">    <span class="function">Class <span class="title">compile</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三-参考文章"><a href="#三-参考文章" class="headerlink" title="三.参考文章"></a>三.参考文章</h2><p> <a href="http://microservices.io/patterns/apigateway.html" target="_blank" rel="external">http://microservices.io/patterns/apigateway.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;摘要&lt;/strong&gt;:  接着上一篇《Spring Cloud Zuul遗失的世界(二)》，本文主要介绍Netflix Zuul core模块的Filter链的设计和Fifter Loader和Filter Manager相关代码的设计与分析。&lt;/p&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Zuul遗失的世界(二)</title>
    <link href="http://lvqingyan.com/sc-zuul-s2/"/>
    <id>http://lvqingyan.com/sc-zuul-s2/</id>
    <published>2017-08-14T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>摘要</strong>:  接着上一篇《Spring Cloud Zuul遗失的世界(一)》，ZuulController继承了ServletWrappingController，将当前应用中的ZuulServlet直接包装为一个Controller，暴露为入口访问，在本篇文章中介绍etflix-zuul-core的代码Zuul的执行的生命周期等。</p><h2 id="一-Netflix-zuul-core源码分析"><a href="#一-Netflix-zuul-core源码分析" class="headerlink" title="一.Netflix zuul core源码分析"></a>一.Netflix zuul core源码分析</h2><p>com.netflix.zuul.http.ZuulServlet是ZuulFilter链执行的入口，通过service方法，提取请求到RequestContext，然后通过调用ZuulRunner，依次按顺序执行每种类型的Filter，完成整个Filter的生命周期，架构图如下所示。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2279594-2e6134e4743b0483.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zuul.png"></p><h3 id="1-1-ZuulServlet代码分析"><a href="#1-1-ZuulServlet代码分析" class="headerlink" title="1.1 ZuulServlet代码分析"></a>1.1 ZuulServlet代码分析</h3><p><a href="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" alt="zuul-request-lifecycle"></a></p><p>在ZuulConfiguration中点击com.netflix.zuul.http.ZuulServlet打开代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3374242278843351500L</span>;</div><div class="line">    <span class="keyword">private</span> ZuulRunner zuulRunner;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init(config);</div><div class="line"></div><div class="line">        String bufferReqsStr = config.getInitParameter(<span class="string">"buffer-requests"</span>);</div><div class="line">        <span class="keyword">boolean</span> bufferReqs = bufferReqsStr != <span class="keyword">null</span> &amp;&amp; bufferReqsStr.equals(<span class="string">"true"</span>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        zuulRunner = <span class="keyword">new</span> ZuulRunner(bufferReqs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//调用zuulRunner.init(servletRequest, servletResponse)进行请求上下文的传递</span></div><div class="line">            init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</div><div class="line"></div><div class="line">            <span class="comment">// Marks this request as having passed through the "Zuul engine", as opposed to servlets</span></div><div class="line">            <span class="comment">// explicitly bound in web.xml, for which requests will not have the same data attached</span></div><div class="line">            RequestContext context = RequestContext.getCurrentContext();</div><div class="line">            context.setZuulEngineRan();</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                preRoute();</div><div class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                error(e);</div><div class="line">                postRoute();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                route();</div><div class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                error(e);</div><div class="line">                postRoute();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postRoute();</div><div class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                error(e);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNHANDLED_EXCEPTION_"</span> + e.getClass().getName()));</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            RequestContext.getCurrentContext().unset();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行 "post" ZuulFilters</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> ZuulException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">        zuulRunner.postRoute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行 "route" filters</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> ZuulException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">route</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">        zuulRunner.route();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行 "pre" filters</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> ZuulException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">        zuulRunner.preRoute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * initializes request</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> servletRequest</div><div class="line">     * <span class="doctag">@param</span> servletResponse</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</div><div class="line">        zuulRunner.init(servletRequest, servletResponse);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * sets error context info and executes "error" filters</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> e</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(ZuulException e)</span> </span>&#123;</div><div class="line">        RequestContext.getCurrentContext().setThrowable(e);</div><div class="line">        zuulRunner.error();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>如上所示，ZuulServlet其实就是一个Servlet，service方法包含了Zuul的整个生命周期。</p></blockquote><h4 id="1-1-1-ZuulServlet-init代码拆解分析"><a href="#1-1-1-ZuulServlet-init代码拆解分析" class="headerlink" title="1.1.1 ZuulServlet init代码拆解分析"></a>1.1.1 ZuulServlet init代码拆解分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//init() - 注册一个ZuulRunner用于调用整个filter 链</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</div><div class="line">        zuulRunner.init(servletRequest, servletResponse);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h4 id="1-1-2-ZuulServlet-service代码分析"><a href="#1-1-2-ZuulServlet-service代码分析" class="headerlink" title="1.1.2 ZuulServlet service代码分析"></a>1.1.2 ZuulServlet service代码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 调用init将req,res置入上下文.获取并标记上下文此session已经通过进入</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</div><div class="line"></div><div class="line">         <span class="comment">// Marks this request as having passed through the "Zuul engine", as opposed to servlets</span></div><div class="line">         <span class="comment">// explicitly bound in web.xml, for which requests will not have the same data attached</span></div><div class="line">         RequestContext context = RequestContext.getCurrentContext();</div><div class="line">         context.setZuulEngineRan();</div><div class="line"></div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             preRoute();</div><div class="line">         &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">             error(e);</div><div class="line">             postRoute();</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             route();</div><div class="line">         &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">             error(e);</div><div class="line">             postRoute();</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             postRoute();</div><div class="line">         &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">             error(e);</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">         error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNHANDLED_EXCEPTION_"</span> + e.getClass().getName()));</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         RequestContext.getCurrentContext().unset();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><blockquote><p>正常情况下，请求只经过pre -&gt; route -&gt; post。<br>两层try…catch，内层只捕获ZuulException，而其他异常由外层捕获。<br>内层3个try…catch语句，只有pre,route抛出ZuulException时，才会执行errror，再执行post。而当post(88行)抛出ZuulException后，只会执行error。<br>外层捕获其他异常(内层try语句块中抛出的非ZuulException异常以及内层catch语句中抛出的所有异常)后，将HTTP状态码设置为500，同时交给error处理。<br>整个流程的终点有两个：post及error；而非只有post一个。</p></blockquote><h3 id="1-2-Zuul的请求上下文-RequestContext"><a href="#1-2-Zuul的请求上下文-RequestContext" class="headerlink" title="1.2 Zuul的请求上下文 RequestContext"></a>1.2 Zuul的请求上下文 RequestContext</h3><p> com.netflix.zuul.context.RequestContext继承了ConcurrentHashMap<string, object="">，是Zuul Filter生命周期中处理http请求上下文,是一个threadlocal的Map.</string,></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestContext</span> <span class="keyword">extends</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(RequestContext.class);</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Class&lt;? extends RequestContext&gt; contextClass = RequestContext.class;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RequestContext testContext = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;? extends RequestContext&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;RequestContext&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> RequestContext <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">return</span> contextClass.newInstance();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//其余省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-3-ContextLifecycleFilter"><a href="#1-3-ContextLifecycleFilter" class="headerlink" title="1.3  ContextLifecycleFilter"></a>1.3  ContextLifecycleFilter</h3><p> com.netflix.zuul.context.ContextLifecycleFilter是调用链外围finally中remove上文中threadlocal.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLifecycleFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            chain.doFilter(req, res);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            RequestContext.getCurrentContext().unset();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-4-Zuul的运行执行器-ZuulRunner"><a href="#1-4-Zuul的运行执行器-ZuulRunner" class="headerlink" title="1.4 Zuul的运行执行器-ZuulRunner"></a>1.4 Zuul的运行执行器-ZuulRunner</h3><p>com.netflix.zuul.ZuulRunner，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulRunner</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> bufferRequests;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a new &lt;code&gt;ZuulRunner&lt;/code&gt; instance.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZuulRunner</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.bufferRequests = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> bufferRequests - whether to wrap the ServletRequest in HttpServletRequestWrapper and buffer the body.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZuulRunner</span><span class="params">(<span class="keyword">boolean</span> bufferRequests)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.bufferRequests = bufferRequests;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * sets HttpServlet request and HttpResponse</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> servletRequest</div><div class="line">     * <span class="doctag">@param</span> servletResponse</div><div class="line">     */</div><div class="line">    <span class="comment">// ZuulRunner内传入的req/res就会被替换为wrapper类增强功能:</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</div><div class="line"></div><div class="line">        RequestContext ctx = RequestContext.getCurrentContext();</div><div class="line">        <span class="keyword">if</span> (bufferRequests) &#123;</div><div class="line">            ctx.setRequest(<span class="keyword">new</span> HttpServletRequestWrapper(servletRequest));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ctx.setRequest(servletRequest);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ctx.setResponse(<span class="keyword">new</span> HttpServletResponseWrapper(servletResponse));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>com.netflix.zuul.filters.ZuulServletFilter跟跟ZuulServlet是同一份代码.<br>com.netflix.zuul.monitoring，预留了CounterFactory与TracerFactory的接口，用来扩展实现counter与timer.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;strong&gt;摘要&lt;/strong&gt;:  接着上一篇《Spring Cloud Zuul遗失的世界(一)》，ZuulController继承了ServletWrappingController，将当前应用中的ZuulServlet直接包装为一个Controller，暴露为入口访问，在本篇文章中介绍etflix-zuul-core的代码Zuul的执行的生命周期等。&lt;/p&gt;
&lt;h2 id=&quot;一-Netflix-zuul-core源码分析&quot;&gt;&lt;a href=&quot;#一-Netflix-zuul-core源码分析&quot; class=&quot;headerlink&quot; title=&quot;一.Netflix zuul core源码分析&quot;&gt;&lt;/a&gt;一.Netflix zuul core源码分析&lt;/h2&gt;&lt;p&gt;com.netflix.zuul.http.ZuulServlet是ZuulFilter链执行的入口，通过service方法，提取请求到RequestContext，然后通过调用ZuulRunner，依次按顺序执行每种类型的Filter，完成整个Filter的生命周期，架构图如下所示。&lt;/p&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Zuul遗失的世界(一)</title>
    <link href="http://lvqingyan.com/sc-zuul-s1/"/>
    <id>http://lvqingyan.com/sc-zuul-s1/</id>
    <published>2017-08-13T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>摘要</strong>:  Zuul作为java网关届的鼻祖，2016年自研网关中间件的时候，对其源码看了很多次，经过两大互联网公司中间件的洗礼之后，目前轮到自己设计一个网关中间件纳管Spring Cloud。最近抽空把自己的理解，备注一下。由于Spring cloud整合Zuul的代码过多。本文主要介绍Spring Cloud对Netflix Zuul高度抽象封装整合部分。即spring-cloud-netflix-core的代码。</p> <a id="more"></a><h2 id="一-Spring-Cloud-Zuul源码分析"><a href="#一-Spring-Cloud-Zuul源码分析" class="headerlink" title="一.Spring Cloud Zuul源码分析"></a>一.Spring Cloud Zuul源码分析</h2><h3 id="1-1-EnableZuulProxy与-EnableZuulServer"><a href="#1-1-EnableZuulProxy与-EnableZuulServer" class="headerlink" title="1.1 @EnableZuulProxy与@EnableZuulServer"></a>1.1 @EnableZuulProxy与@EnableZuulServer</h3><p>如下主应用程序代码所示，我们使用Spring Cloud Zuul只需要加上@EnableZuulProxy或@EnableZuulServer两种注解就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableZuulProxy</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudZuulApplication</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(SpringCloudZuulApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>@EnableZuulProxy与@EnableZuulServer,<br>@EnableZuulServer - 普通Zuul Server,只支持基本的route与filter功能.<br>@EnableZuulProxy - 普通Zuul Server+服务发现与熔断等功能的增强版,具有反向代理功能.</p></blockquote><h3 id="1-2-EnableZuulProxy注解入口"><a href="#1-2-EnableZuulProxy注解入口" class="headerlink" title="1.2 @EnableZuulProxy注解入口"></a>1.2 @EnableZuulProxy注解入口</h3><p> 点开注解@EnableZuulProxy，进入到org.springframework.cloud.netflix.zuul.EnableZuulProxy，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableCircuitBreaker</span></div><div class="line"><span class="meta">@EnableDiscoveryClient</span></div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Import</span>(ZuulProxyConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableZuulProxy &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-3-ZuulProxyConfiguration代码"><a href="#1-3-ZuulProxyConfiguration代码" class="headerlink" title="1.3 ZuulProxyConfiguration代码"></a>1.3 ZuulProxyConfiguration代码</h3><p>@Import(ZuulProxyConfiguration.class)，查看导入的类org.springframework.cloud.netflix.zuul.ZuulProxyConfiguration，如下所示，可以看到org.springframework.cloud.netflix.zuul.ZuulProxyConfiguration,继承了上文的ZuulConfiguration,新增了服务与实例等概念，核心重要代码已经加入注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(&#123; RibbonCommandFactoryConfiguration.RestClientRibbonConfiguration.class,</div><div class="line">RibbonCommandFactoryConfiguration.OkHttpRibbonConfiguration.class,</div><div class="line">RibbonCommandFactoryConfiguration.HttpClientRibbonConfiguration.class &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulProxyConfiguration</span> <span class="keyword">extends</span> <span class="title">ZuulConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line"><span class="keyword">private</span> List&lt;RibbonRequestCustomizer&gt; requestCustomizers = Collections.emptyList();</div><div class="line"></div><div class="line">    <span class="comment">// DiscoveryClient肩负着从Eureka中获取服务列表,获取对应实例的功能</span></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> DiscoveryClient discovery;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> ServiceRouteMapper serviceRouteMapper;</div><div class="line">   </div><div class="line">    <span class="comment">// zuulFeature 依然是将Zuul标识为Discovery模式.</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> HasFeatures <span class="title">zuulFeature</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> HasFeatures.namedFeature(<span class="string">"Zuul (Discovery)"</span>, ZuulProxyConfiguration.class);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span>(DiscoveryClientRouteLocator.class)</div><div class="line"><span class="function"><span class="keyword">public</span> DiscoveryClientRouteLocator <span class="title">discoveryRouteLocator</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> DiscoveryClientRouteLocator(<span class="keyword">this</span>.server.getServletPrefix(), <span class="keyword">this</span>.discovery, <span class="keyword">this</span>.zuulProperties,</div><div class="line"><span class="keyword">this</span>.serviceRouteMapper);</div><div class="line">&#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 依然是注册了这么个ApplicationEvent来触发上文中的dirty状态.</span></div><div class="line">    <span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ApplicationListener&lt;ApplicationEvent&gt; <span class="title">zuulDiscoveryRefreshRoutesListener</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> ZuulDiscoveryRefreshListener();</div><div class="line">&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulDiscoveryRefreshListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> HeartbeatMonitor monitor = <span class="keyword">new</span> HeartbeatMonitor();</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> ZuulHandlerMapping zuulHandlerMapping;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> InstanceRegisteredEvent) &#123;</div><div class="line">reset();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ParentHeartbeatEvent) &#123;</div><div class="line">ParentHeartbeatEvent e = (ParentHeartbeatEvent) event;</div><div class="line">resetIfNeeded(e.getValue());</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> HeartbeatEvent) &#123;</div><div class="line">HeartbeatEvent e = (HeartbeatEvent) event;</div><div class="line">resetIfNeeded(e.getValue());</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetIfNeeded</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.monitor.update(value)) &#123;</div><div class="line">reset();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.zuulHandlerMapping.setDirty(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">//其余省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>DiscoveryClientRouteLocator类中的locateRoutes()方法，将path与上文的ZuulRoute通过DiscoveryClientRouteLocator.locateRoutes()的对应在一起.<br>点击查看其父类，org.springframework.cloud.netflix.zuul.ZuulConfiguration,如下我们可以看到Netflix的Zuul-core的入口，ZuulServlet。</p></blockquote><h3 id="1-4-DiscoveryClientRouteLocator中locateRoutes"><a href="#1-4-DiscoveryClientRouteLocator中locateRoutes" class="headerlink" title="1.4 DiscoveryClientRouteLocator中locateRoutes"></a>1.4 DiscoveryClientRouteLocator中locateRoutes</h3><p>DiscoveryClientRouteLocator类中的locateRoutes的大概流程</p><ol><li>将上文SimpleRouteLocator中解析出来的Route列表灌入内部的LinkedHashMap</li><li>抽取Route自带的serviceId,将其作为key,形成一个<code>staticServices</code>的map</li><li>遍历DiscoveryClient拿到的serviceId列表,匹配正则形式定义的serviceId并将对应的ZuulRoute与之对应</li><li>调整LinkedHashMap内路由顺序,将/**挪到最后</li><li>微调map内容,将key值加上/或者自定义prefix</li></ol><h3 id="1-5-ZuulConfiguration"><a href="#1-5-ZuulConfiguration" class="headerlink" title="1.5 ZuulConfiguration"></a>1.5 ZuulConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123; ZuulProperties.class &#125;)</div><div class="line"><span class="meta">@ConditionalOnClass</span>(ZuulServlet.class)</div><div class="line"><span class="comment">// Make sure to get the ServerProperties from the same place as a normal web app would</span></div><div class="line"><span class="meta">@Import</span>(ServerPropertiesAutoConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//zuulProperties 对应配置文件的内容</span></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">protected</span> ZuulProperties zuulProperties;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">protected</span> ServerProperties server;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line"><span class="keyword">private</span> ErrorController errorController;</div><div class="line"></div><div class="line">    <span class="comment">//告知actuator监控当前模式:Simple/Discovery</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> HasFeatures <span class="title">zuulFeature</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> HasFeatures.namedFeature(<span class="string">"Zuul (Discovery)"</span>, ZuulProxyConfiguration.class);</div><div class="line">&#125;</div><div class="line">    </div><div class="line">   <span class="comment">//通过继承ServletWrappingController接管了上文定义的ZuulServlet,因此ZuulController就是Zuul的入口</span></div><div class="line">   <span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ZuulController <span class="title">zuulController</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> ZuulController();</div><div class="line">&#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    *ZuulHandlerMapping,响应器模式,其实目前就是把所有路径的请求导入到ZuulController上.&lt;/br&gt;</div><div class="line">    *另外的功效是当觉察RouteLocator路由表变更,则更新自己dirty状态,重新注册所有Route到ZuulController.</div><div class="line">    */</div><div class="line">   <span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ZuulHandlerMapping <span class="title">zuulHandlerMapping</span><span class="params">(RouteLocator routes)</span> </span>&#123;</div><div class="line">ZuulHandlerMapping mapping = <span class="keyword">new</span> ZuulHandlerMapping(routes, zuulController());</div><div class="line">mapping.setErrorController(<span class="keyword">this</span>.errorController);</div><div class="line"><span class="keyword">return</span> mapping;</div><div class="line">&#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">   * ZuulRefreshListener,</div><div class="line">   */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulRefreshListener</span></span></div><div class="line"><span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; &#123;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> ZuulHandlerMapping zuulHandlerMapping;</div><div class="line"></div><div class="line"><span class="keyword">private</span> HeartbeatMonitor heartbeatMonitor = <span class="keyword">new</span> HeartbeatMonitor();</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</div><div class="line">            <span class="comment">// Simple模式下注册RoutesRefreshedEvent,解析配置文件,</span></div><div class="line">            <span class="comment">// 维护路由表并监听变化,将请求都导向ZuulController去历经filters</span></div><div class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent</div><div class="line">|| event <span class="keyword">instanceof</span> RefreshScopeRefreshedEvent</div><div class="line">|| event <span class="keyword">instanceof</span> RoutesRefreshedEvent) &#123;</div><div class="line"><span class="keyword">this</span>.zuulHandlerMapping.setDirty(<span class="keyword">true</span>);</div><div class="line">&#125; </div><div class="line">            <span class="comment">// Endpoint模式下又添加了HeartbeatEvent</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> HeartbeatEvent) &#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.heartbeatMonitor.update(((HeartbeatEvent) event).getValue())) &#123;</div><div class="line"><span class="keyword">this</span>.zuulHandlerMapping.setDirty(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">   <span class="comment">//其余省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>从ZuulConfiguration中可以拿到Simple模式下所有bean.</p></blockquote><h3 id="1-6-ZuulController整合访问的桥梁"><a href="#1-6-ZuulController整合访问的桥梁" class="headerlink" title="1.6  ZuulController整合访问的桥梁"></a>1.6  ZuulController整合访问的桥梁</h3><p> ZuulController继承了ServletWrappingController，将当前应用中的某个Servlet直接包装为一个Controller，所有到ServletWrappingController的请求实际上是由它内部所包装的这个Servlet 实例来处理的，也就是说内部封装的Servlet实例并不对外开放，对于程序的其他范围是不可见的，适配所有的HTTP请求到内部封装的Servlet实例进行处理。它通常用于对已存的Servlet的逻辑重用上。其实这也就是Spring Cloud与Netflix Zuul整合的关键点。</p><p> <img src="/images/sc-study/zuulc.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulController</span> <span class="keyword">extends</span> <span class="title">ServletWrappingController</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZuulController</span><span class="params">()</span> </span>&#123;</div><div class="line">setServletClass(ZuulServlet.class);</div><div class="line">setServletName(<span class="string">"zuul"</span>);</div><div class="line">setSupportedMethods((String[]) <span class="keyword">null</span>); <span class="comment">// Allow all</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">// We don't care about the other features of the base class, just want to</span></div><div class="line"><span class="comment">// handle the request</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">super</span>.handleRequestInternal(request, response);</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line"><span class="comment">// @see com.netflix.zuul.context.ContextLifecycleFilter.doFilter</span></div><div class="line">RequestContext.getCurrentContext().unset();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-7-ZuulProperties"><a href="#1-7-ZuulProperties" class="headerlink" title="1.7 ZuulProperties"></a>1.7 ZuulProperties</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">zuul.ignoredServices</div><div class="line">zuul.routes</div><div class="line"></div><div class="line">zuul:</div><div class="line">  ignored-services:</div><div class="line">  routes:</div></pre></td></tr></table></figure><blockquote><p>其中routes对应着内部类定义ZuulRoute.</p></blockquote><h3 id="1-8-其它补充说明"><a href="#1-8-其它补充说明" class="headerlink" title="1.8 其它补充说明"></a>1.8 其它补充说明</h3><p>org.springframework.cloud.netflix.zuul.filters.Route,是Spring Cloud 的抽象,就是上文<code>RouteLocator</code>潜移默化转换的部分. </p><p>org.springframework.cloud.netflix.zuul.ZuulFilterInitializer,实现<code>ServletContextListener</code>,servlet内容来自tomcat。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;摘要&lt;/strong&gt;:  Zuul作为java网关届的鼻祖，2016年自研网关中间件的时候，对其源码看了很多次，经过两大互联网公司中间件的洗礼之后，目前轮到自己设计一个网关中间件纳管Spring Cloud。最近抽空把自己的理解，备注一下。由于Spring cloud整合Zuul的代码过多。本文主要介绍Spring Cloud对Netflix Zuul高度抽象封装整合部分。即spring-cloud-netflix-core的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Zuul异常处理</title>
    <link href="http://lvqingyan.com/sc-zuul-excpetion/"/>
    <id>http://lvqingyan.com/sc-zuul-excpetion/</id>
    <published>2017-06-24T04:23:31.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到了一个GitHub issue在讨论如何在post类型的zuul filter中设置response body，其中涉及到异常情况下，如何返回一个自定义的response body。正好我在升级spring-cloud，也想弄清楚，spring-cloud-zuul是如何处理异常情况的，所以就仔细看了看这部分的实现细节，现在做个笔记记录下来。</p><a id="more"></a><h2 id="1-zull请求的生命周期图"><a href="#1-zull请求的生命周期图" class="headerlink" title="1.zull请求的生命周期图"></a>1.zull请求的生命周期图</h2><p>关于zuul是如何工作的，这里不再介绍，具体可以参看<a href="https://github.com/Netflix/zuul/wiki/How-it-Works" target="_blank" rel="external">这里</a>。官方给了一个zull请求的生命周期图：</p><p><a href="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" alt="zuul-request-lifecycle"></a></p><p>上图中，实线表示请求必然经过的路径，而虚线表示可能经过的路径；从这张图中可以看出：</p><ul><li>所有请求都必然按照<code>pre</code>-&gt; <code>route</code> -&gt; <code>post</code>的顺序执行。</li><li><code>post</code>返回response。</li><li>如果<code>pre</code>中有自定义filter，则执行自定义filter。</li><li>如果<code>pre</code>,<code>route</code>,<code>post</code>发生错误则执行<code>error</code>，然后再执行<code>post</code>。</li></ul><p>这张图忽略了很多细节；最明显的就是，自定义的filter可以是<code>pre</code>,<code>route</code>,<code>post</code>,<code>error</code>中的任何一种；其次假如<code>post</code>中发生了异常，执行流程交给<code>error</code>处理完之后，又重新回到<code>post</code>中，会不会又有问题？</p><p>所以还是看看代码比较靠谱。以下基于spring-cloud Dalston.RELEASE做代码分析。</p><p>调试一下，就可以看到请求进入zuul之后的整个调用链，简单来说如下：<code>ZuulServlet#service</code> -&gt; <code>FilterProcessor#processZuulFilter</code> -&gt; <code>ZuulFilter#runFilter</code> -&gt; <code>[Concret]ZuulFilter#run</code>。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h2><h3 id="ZuulServlet-service"><a href="#ZuulServlet-service" class="headerlink" title="ZuulServlet#service"></a>ZuulServlet#service</h3><p>首先找到请求进入zuul filters的入口：<a href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/http/ZuulServlet.java#L64" target="_blank" rel="external">ZuulServlet#service(ServletRequest, ServletResponse)</a>。</p><p>下面抽出这个函数的主干：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">           </div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                preRoute();</div><div class="line">             &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                 error(e);</div><div class="line">                 postRoute();</div><div class="line">                 <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">try</span> &#123;</div><div class="line">                 route();</div><div class="line">             &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                 error(e);</div><div class="line">                 postRoute();</div><div class="line">                 <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">try</span> &#123;</div><div class="line">                 postRoute();</div><div class="line">             &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                 error(e);</div><div class="line">                 <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">             error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNHANDLED_EXCEPTION_"</span> + e.getClass().getName()));</div><div class="line">         &#125;</div></pre></td></tr></table></figure><p>这个函数基本遵从但不完全符合官网给出的生命周期图：</p><ul><li>正常情况下，请求只经过<code>pre</code> -&gt; <code>route</code> -&gt; <code>post</code>。</li><li>两层<code>try...catch</code>，内层只捕获<code>ZuulException</code>，而其他异常由外层捕获。</li><li>内层3个<code>try...catch</code>语句，只有<code>pre</code>,<code>route</code>抛出<code>ZuulException</code>时，才会执行<code>errror</code>，再执行<code>post</code>。而当<code>post</code>(88行)抛出<code>ZuulException</code>后，只会执行<code>error</code>。</li><li>外层捕获其他异常(内层<code>try</code>语句块中抛出的非<code>ZuulException</code>异常以及内层<code>catch</code>语句中抛出的所有异常)后，将HTTP状态码设置为500，同时交给<code>error</code>处理。</li><li>整个流程的终点有两个：<code>post</code>及<code>error</code>；而非只有<code>post</code>一个。</li></ul><p>另外看一下<code>error(ZuulException)</code>这个函数到底做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(ZuulException e)</span> </span>&#123;</div><div class="line">    RequestContext.getCurrentContext().setThrowable(e);</div><div class="line">    zuulRunner.error();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>异常信息是在这里被加入到<code>RequestContext</code>中的，以供后续的filter使用，然后调用<code>error</code> filters。</p><p>至此我们可以得到一个流程图(感觉还不如代码看得清晰<strong>-_-</strong>!!)：</p><p><a href="https://github.com/lowzj/note-book/blob/master/img/springcloud/sc-ZuulServlet.jpeg" target="_blank" rel="external"><img src="https://github.com/lowzj/note-book/raw/master/img/springcloud/sc-ZuulServlet.jpeg" alt="sc-ZuulServlet"></a></p><h3 id="FilterProcessor-processZuulFilter"><a href="#FilterProcessor-processZuulFilter" class="headerlink" title="FilterProcessor#processZuulFilter"></a>FilterProcessor#processZuulFilter</h3><p><a href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/FilterProcessor.java#L173" target="_blank" rel="external">FilterPreocessor#processZuulFilter</a>，这个函数调用ZuulFilter，并且会将异常重新抛出，如果是非<code>ZuulException</code>的异常，则转为状态码为500的<code>ZuulException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   </div><div class="line">            Throwable t = <span class="keyword">null</span>;</div><div class="line">   </div><div class="line">            ZuulFilterResult result = filter.runFilter();</div><div class="line">            ExecutionStatus s = result.getStatus();</div><div class="line">   </div><div class="line">            <span class="keyword">switch</span> (s) &#123;</div><div class="line">                <span class="keyword">case</span> FAILED:</div><div class="line">                    t = result.getException();</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">   </div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">throw</span> t;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ZuulException) &#123;</div><div class="line">                <span class="keyword">throw</span> (ZuulException) e;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ZuulException ex = <span class="keyword">new</span> ZuulException(e, <span class="string">"Filter threw Exception"</span>, <span class="number">500</span>, filter.filterType() + <span class="string">":"</span> + filterName);</div><div class="line">                <span class="keyword">throw</span> ex;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>如果ZuulFilter执行失败，即结果状态为<code>FAILED</code>，则从ZuulFilter的执行结果ZuulFilterResult中提取出异常信息(199行)，然后抛出(214)；在<code>catch</code>语句块中，捕获刚才抛出的异常，判断是否为<code>ZuulException</code>，如果是则直接抛出，否则转化为状态为500的<code>ZuulException</code>再抛出。</p><p>看到这里，基本确认的一点是，ZuulFilter中抛出的任何形式的异常，最终都会转化为<code>ZuulException</code>抛给上层调用者，即<code>ZuulServlet#service</code>。但是这里并不是通过<code>try...catch</code>来捕获ZuulFilter执行中抛出的异常，而是从返回结果ZuulFilterResult中直接获取的，这是怎么一回事，需要再看下<code>ZuulFilter#runFilter</code>的实现逻辑。</p><h3 id="ZuulFilter-runFilter"><a href="#ZuulFilter-runFilter" class="headerlink" title="ZuulFilter#runFilter"></a>ZuulFilter#runFilter</h3><p>下面是从<a href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/ZuulFilter.java#L110" target="_blank" rel="external">ZuulFilter#runFilter()</a>抽取出来的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ZuulFilterResult zr = <span class="keyword">new</span> ZuulFilterResult();</div><div class="line">    </div><div class="line">                 <span class="keyword">try</span> &#123;</div><div class="line">                     Object res = run();</div><div class="line">                     zr = <span class="keyword">new</span> ZuulFilterResult(res, ExecutionStatus.SUCCESS);</div><div class="line">                 &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                     zr = <span class="keyword">new</span> ZuulFilterResult(ExecutionStatus.FAILED);</div><div class="line">                     zr.setException(e);</div><div class="line">                 &#125;</div><div class="line">    </div><div class="line">         <span class="keyword">return</span> zr;</div></pre></td></tr></table></figure><p>这段代码会调用某个具体的ZuulFilter实现的<code>run</code>方法，如果不抛出异常，则返回状态为<code>ExecutionStatus.SUCCESS</code>的ZuulFilterResult(117行)；若有任何异常，则将返回结果的状态设置为<code>ExecutionStatus.FAILED</code>(120)，同时将异常信息设置到返回结果中(121)。即我们实现一个ZuulFilter，如果不抛出异常，则会被认为是成功的，否则就会被当作失败的。</p><p>结合上面两节的代码分析，ZuulFilter中一旦有异常抛出，必然是(或被转化为)<code>ZuulException</code>，然后必然进入到<code>error</code> filters中处理。由此，我们简化一下上面的流程图：</p><p><a href="https://github.com/lowzj/note-book/blob/master/img/springcloud/sc-ZuulServlet-simple.jpeg" target="_blank" rel="external"><img src="https://github.com/lowzj/note-book/raw/master/img/springcloud/sc-ZuulServlet-simple.jpeg" alt="sc-ZuulServlet-simple"></a></p><h2 id="3-SpringCloud中的SendErrorFilter"><a href="#3-SpringCloud中的SendErrorFilter" class="headerlink" title="3.SpringCloud中的SendErrorFilter"></a>3.SpringCloud中的SendErrorFilter</h2><p>在<code>Dalston.RELEASE</code>之前，spring-cloud-netflix中并不包含<code>error</code>类型的Filter；而处理错误情况的filter为<code>SendErrorFilter</code>，其类型为<code>post</code>，<code>order</code>为0，比<code>SendResponseFilter</code>优先级高(1000)，即更早调用。先来分析一下<code>Dalston.RELEASE</code>之前版本的<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/v1.2.7.RELEASE/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/zuul/filters/post/SendErrorFilter.java#L34" target="_blank" rel="external">SendErrorFilter</a>，下面的代码片段摘自<code>spring-cloud-netflix 1.2.7.RELEASE</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;error.path:/error&#125;"</span>)</div><div class="line">     <span class="keyword">private</span> String errorPath;</div><div class="line">   </div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">         RequestContext ctx = RequestContext.getCurrentContext();</div><div class="line">         <span class="comment">// only forward to errorPath if it hasn't been forwarded to already</span></div><div class="line">         <span class="keyword">return</span> ctx.containsKey(<span class="string">"error.status_code"</span>)</div><div class="line">                 &amp;&amp; !ctx.getBoolean(SEND_ERROR_FILTER_RAN, <span class="keyword">false</span>);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   </div><div class="line">             <span class="keyword">int</span> statusCode = (Integer) ctx.get(<span class="string">"error.status_code"</span>);</div><div class="line">             request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>, statusCode);</div><div class="line">   </div><div class="line">             Object e = ctx.get(<span class="string">"error.exception"</span>);</div><div class="line">             request.setAttribute(<span class="string">"javax.servlet.error.exception"</span>, e);</div><div class="line">   </div><div class="line">             String message = (String) ctx.get(<span class="string">"error.message"</span>);</div><div class="line">             request.setAttribute(<span class="string">"javax.servlet.error.message"</span>, message);</div><div class="line">   </div><div class="line">             RequestDispatcher dispatcher = request.getRequestDispatcher(</div><div class="line">                     <span class="keyword">this</span>.errorPath);</div><div class="line">   </div><div class="line">             dispatcher.forward(request, ctx.getResponse());</div><div class="line">   </div><div class="line">     &#125;</div></pre></td></tr></table></figure><p>从上面的代码中可以得出以下几点：</p><ul><li><code>SendErrorFilter</code>的进入条件是：<code>RequestContext</code>中包含<code>error.status_code</code>，且之前从未执行过该filter。(55, 56)</li><li>会将错误信息转发给<code>errorPath</code>执行；<code>errorPath</code>可由配置项<code>error.paht</code>指定，默认为<code>/error</code>。(38, 79, 84)</li><li>转发的错误信息是从<code>RequestContext</code>中的三个<code>key</code>得到：<code>error.status_code</code>, <code>error.exception</code>, <code>error.message</code>。(65~76)</li><li>如果要使用<code>SendErrorFilter</code>，则我们在自己实现自定义ZuulFilter做异常处理的时候，需要注意：</li><li><p>如果是<code>pre</code>, <code>route</code>类型的filter，则捕获所有内部异常，将异常信息设置到<code>error.message</code>中，设置所需返回的HTTP状态码到<code>error.status_code</code>中；然后抛出一个异常。抛出异常是为了将执行流程交给<code>error-&gt;post</code>这个执行分支；否则，当前filter会被认为执行成功，继续执行后续的filter。<code>run()</code>方法抛出的异常需是(或继承)<code>RuntimeException</code>，因为<code>IZuulFilter#run()</code>接口没有显示抛出异常。</p></li><li><p>如果是 post类型：</p><ul><li>设置该filter的<code>order</code>，小于0(这是<code>SendErrorFilter</code>)。</li><li>仔细考虑<code>shouldFilter()</code>的实现细节，因为异常流也会进入<code>post</code> filters，确定是否需要处理。</li><li><code>run()</code>方法中捕获所有异常，然后设置<code>error.status_code</code>, <code>error.message</code>, <code>error.exception</code>，并且不再抛出异常。否则会进入<code>error</code> filters，但是现在没有，由<code>SendErrorFilter</code>替代；除非自己实现一个<code>error</code> filter，然后禁掉<code>SendErrorFilter</code>。</li></ul></li></ul><p>这个版本中，spring-cloud-netflix提供的这个<code>SendErrorFilter</code>有明显的缺陷，无法处理由<code>post</code> filters抛出的异常，也不符合zuul请求的生命周期图。所以在<code>Dalston.RELEASE</code>之后，即<code>spring-cloud-netflix 1.3.0.RELEASE</code>，将<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/v1.3.0.RELEASE/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/zuul/filters/post/SendErrorFilter.java#L43" target="_blank" rel="external">SendErrorFilter</a>的类型改为了<code>error</code>。</p><p>下面的代码片段摘自<code>spring-cloud-netflix 1.3.0.RELEASE</code>的<code>SendErrorFilter</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ERROR_TYPE;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        RequestContext ctx = RequestContext.getCurrentContext();</div><div class="line">        <span class="comment">// only forward to errorPath if it hasn't been forwarded to already</span></div><div class="line">        <span class="keyword">return</span> ctx.getThrowable() != <span class="keyword">null</span></div><div class="line">                &amp;&amp; !ctx.getBoolean(SEND_ERROR_FILTER_RAN, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  </div><div class="line">            ZuulException exception = findZuulException(ctx.getThrowable());</div><div class="line">  </div><div class="line">            request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>, exception.nStatusCode);</div><div class="line">            request.setAttribute(<span class="string">"javax.servlet.error.exception"</span>, exception);</div><div class="line">            request.setAttribute(<span class="string">"javax.servlet.error.message"</span>, exception.errorCause);</div><div class="line">  </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">   <span class="function">ZuulException <span class="title">findZuulException</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (throwable.getCause() <span class="keyword">instanceof</span> ZuulRuntimeException) &#123;</div><div class="line">           <span class="comment">// this was a failure initiated by one of the local filters</span></div><div class="line">           <span class="keyword">return</span> (ZuulException) throwable.getCause().getCause();</div><div class="line">       &#125;</div><div class="line">  </div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>需要注意几点：</p><ul><li>类型为<code>error</code>(53行)。</li><li>进入条件为：<code>RequestContext</code>中有异常，并且该filter从未执行过(65, 66)。异常对象是在<code>ZuulServlet#error(ZuulException)</code>方法中设置的。</li><li><code>run()</code>方法中提取错误信息不再是从<code>RequestContext</code>的三个<code>key</code>(<code>error.status_code</code>, <code>error.message</code>, <code>error.exception</code>)中获取；而是直接从<code>ZuulException</code>对象中获取(73~82)。</li><li>如何取得<code>ZuulException</code>对象(100<del>118)，最重要的一点是从<code>ZuulRuntimeException</code>中提取<code>ZuulException</code>对象(101</del>103)，而<code>ZuulRuntimeException</code>继承<code>RuntimeException</code>。</li><li>注意101行代码，是判断<code>throwable.getCause()</code>是否为<code>ZuulRuntimeException</code>，这是因为所有非<code>ZuulException</code>的异常在<code>FilterProcessor#processZuulFilter()</code>(227行)中会被转化为<code>ZuulException</code>。</li><li><code>findZuulException</code>没有贴全，其会优先从自定义filter中抛出的<code>ZuulRuntimeException</code>中提取<code>ZuulException</code>对象。这样就允许我们返回我们想要的错误信息和HTTP状态码。</li></ul><p>那基于1.3.0.RELEASE，我们在写自定义filter时，如何做异常处理呢：</p><ul><li>将filter内部异常转化为<code>ZuulException</code>，设置自己需要返回的HTTP状态码，然后包装为<code>ZuulRuntimeException</code>抛出。</li><li>如若不封装为<code>ZuulRuntimeException</code>，则返回的HTTP状态码为500。</li></ul><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// do something</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(<span class="keyword">new</span> ZuulException(t, HttpStatus.BAD_REQUEST.value(), t.getMessage()));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果想自定义返回的异常信息的response body的格式，最简单的方法是仿照<code>BasicErrorController</code>重写一下<code>/error</code>接口。</p>]]></content>
    
    <summary type="html">
    
      最近看到了一个GitHub issue在讨论如何在post类型的zuul filter中设置response body，其中涉及到异常情况下，如何返回一个自定义的response body。正好我在升级spring-cloud，也想弄清楚，spring-cloud-zuul是如何处理异常情况的，所以就仔细看了看这部分的实现细节，现在做个笔记记录下来。
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>在Spring Cloud中实现降级之权重路由和标签路由</title>
    <link href="http://lvqingyan.com/sc-ribbon-demoted/"/>
    <id>http://lvqingyan.com/sc-ribbon-demoted/</id>
    <published>2017-06-03T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong> 限流、降级、灰度是服务治理的一个很重要的功能。本文参考<a href="http://www.jianshu.com/p/37ee1e84900a" target="_blank" rel="external">Spring Cloud中国社区的VIP会员-何鹰的博客-整理</a><br>Dubbo自带服务降级、限流功能，spring cloud并没有提供此功能，只能由我们自行实现。这里的限流、降级、灰度都是针对服务实例级别，并不是整个服务级别，整个服务级别可以通过实例部署数量来实现。</p><h2 id="限流降级设计"><a href="#限流降级设计" class="headerlink" title="限流降级设计"></a>限流降级设计</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>服务A，部署了3个实例A1、A2、A3。spring cloud默认客户端负载均衡策略是采用轮询方式，A1、A2、A3三个实例流量均分，各1/3。如果这个时候需要将服务A由1.0版升级至2.0版，我们需要做的步骤是：将A1的流量降为0，柔性下线，关闭A1实例并升级到2.0，将A1流量提升为10%观察2.0线上运行情况，如果情况稳定，则逐步开放流量至不限制及1/3。依次在A2，A3上执行上述操作。<br>在上述步骤中，我们想让特别的人使用2.0，其他人还是使用1.0版，稳定后再全员开放。<br><a id="more"></a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分析，服务A的流量产生有两个方面，一个是外部流量，外网通过zuul过来的流量，一个是内部流量，服务间调用，服务B调用服务A的这类流量。不管是zuul还是内部服务来的，都是要通过ribbon做客户端负载均衡，我们可以修改ribbon负载均衡策略来实现上述限流、降级、灰度功能。</p><p>要实现这些想法，我们需要对spring-cloud的各个组件、数据流非常熟悉，这样才能知道该在哪里做扩展。一个典型的调用：外网-》Zuul网关-》服务A-》服务B。。。</p><p>spring-cloud跟dubbo一样都是客户端负载均衡，所有调用均由Ribbon来做负载均衡选择服务器，所有调用前后会套一层hystrix做隔离、熔断。服务间调用均用带LoadBalanced注解的RestTemplate发出。RestTemplate-》Ribbon-》hystrix</p><p>通过上述分析我们可以看到，我们的扩展点就在Ribbon，Ribbon根据我们的规则，选择正确的服务器即可。</p><p>我们先来一个dubbo自带的功能：基于权重的流量控制。dubbo自带的控制台可以设置服务实例粒度的半权，倍权。其实就是在客户端负载均衡时，选择服务器带上权重即可，spring-cloud默认是ZoneAvoidanceRule，优先选择相同Zone下的实例，实例间采用轮询方式做负载均衡。我们的想把基于轮询改为基于权重即可。接下来的问题是，每个实例的权重信息保存在哪里？从哪里取？dubbo放在zookeeper中，spring-cloud放在eureka中。我们只需从eureka拿每个实例的权重信息，然后根据权重来选择服务器即可。具体代码LabelAndWeightMetadataRule（先忽略里面的优先匹配label相关代码）。</p><h2 id="工程案例演示"><a href="#工程案例演示" class="headerlink" title="工程案例演示"></a>工程案例演示</h2><p><img src="/images/sc-study/sc-r-d02.png" alt="工程目录"></p><blockquote><p><a href="https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-ribbon-demoted" target="_blank" rel="external">https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-ribbon-demoted</a></p></blockquote><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ol><li><p>config 配置中心<br>端口：8888，方便起见直接读取配置文件，生产环境可以读取git。application-dev.properties为全局配置。先启动配置中心，所有服务的配置（包括注册中心的地址）均从配置中心读取。</p></li><li><p>consumer 服务消费者<br>端口：18090，调用服务提供者，为了演示header传递。</p></li><li><p>core 框架核心包<br>核心jar包，所有微服务均引用该包，使用AutoConfig实现免配置，模拟生产环境下spring-cloud的使用。</p></li><li><p>eureka 注册中心<br>端口：8761，/metadata端点实现metadata信息配置。</p></li><li><p>provider 服务提供者<br>端口：18090，服务提供者，无特殊逻辑。</p></li><li><p>zuul 网关<br>端口：8080，演示解析token获得label并放入header往后传递</p></li></ol><h2 id="案例具体实现"><a href="#案例具体实现" class="headerlink" title="案例具体实现"></a>案例具体实现</h2><h3 id="基于权重的实现思路"><a href="#基于权重的实现思路" class="headerlink" title="基于权重的实现思路"></a>基于权重的实现思路</h3><p>LabelAndWeightMetadataRule写好了，那么我们如何使用它，使之生效呢？有3种方式。</p><p>1）写个AutoConfig将LabelAndWeightMetadataRule声明成@Bean，用来替换默认的ZoneAvoidanceRule。这种方式在技术验证、开发测试阶段使用短平快。但是这种方式是强制全局设置，无法个性化。</p><p>2）由于spring-cloud的Ribbon并没有实现netflix Ribbon的所有配置项。netflix配置全局rule方式为：ribbon.NFLoadBalancerRuleClassName=package.YourRule，spring-cloud并不支持，spring-cloud直接到服务粒度，只支持SERVICE_ID.ribbon.NFLoadBalancerRuleClassName=package.YourRule。</p><blockquote><p>我们可以扩展org.springframework.cloud.netflix.ribbon.PropertiesFactory修正spring cloud ribbon未能完全支持netflix ribbon配置的问题。这样我们可以将全局配置写到配置中心的application-dev.properties全局配置中，然后各个微服务还可以根据自身情况做个性化定制。但是PropertiesFactory属性均为私有，应该是spring cloud不建议在此扩展。参见<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1741。" target="_blank" rel="external">https://github.com/spring-cloud/spring-cloud-netflix/issues/1741。</a></p></blockquote><p>3）使用spring cloud官方建议的@RibbonClient方式。该方式仅存在于spring-cloud单元测试中（在我提问后，现在还存在于spring-cloud issue list）。具体代码参见DefaultRibbonConfiguration.java、CoreAutoConfiguration.java。</p><blockquote><p>目前采用第三种方式处理</p></blockquote><h3 id="基于权重的路由测试"><a href="#基于权重的路由测试" class="headerlink" title="基于权重的路由测试"></a>基于权重的路由测试</h3><p>依次开启 config eureka provide（开两个实例，通过启动参数server.port指定不同端口区分） consumer zuul<br>访问 <a href="http://localhost:8761/metadata.html" target="_blank" rel="external">http://localhost:8761/metadata.html</a> 这是我手写的一个简单的metadata管理界面，分别设置两个provider实例的weight值（设置完需要一段2分钟才能生效），然后访问 <a href="http://localhost:8080/provider/user" target="_blank" rel="external">http://localhost:8080/provider/user</a> 多刷几次来测试zuul是否按权重发送请求，也可以访问 <a href="http://localhost:8080/consumer/test" target="_blank" rel="external">http://localhost:8080/consumer/test</a> 多刷几次来测试consumer是否按权重来调用provide服务。</p><h3 id="基于标签的路由处理"><a href="#基于标签的路由处理" class="headerlink" title="基于标签的路由处理"></a>基于标签的路由处理</h3><p>基于权重的搞定之后，接下来才是重头戏：基于标签的路由。入口请求含有各种标签，然后我们可以根据标签幻化出各种各样的路由规则。例如只有标注为粉丝的用户才使用新版本（灰度、AB、金丝雀），例如标注为中国的用户请求必须发送到中国的服务器（全球部署），例如标注为写的请求必须发送到专门的写服务实例（读写分离），等等等等，唯一限制你的就是你的想象力。</p><h4 id="基于标签的路由实现思路"><a href="#基于标签的路由实现思路" class="headerlink" title="基于标签的路由实现思路"></a>基于标签的路由实现思路</h4><p>根据标签的控制，我们当然放到之前写的Ribbon的rule中，每个实例配置的不同规则也是跟之前一样放到注册中心的metadata中。需要解决以下几个问题:</p><p><strong>Q:关键是标签数据如何传过来?</strong></p><blockquote><p>A:权重随机的实现思路里面有答案，请求都通过zuul进来，因此我们可以在zuul里面给请求打标签，基于用户，IP或其他看你的需求，然后将标签信息放入ThreadLocal中，然后在Ribbon Rule中从ThreadLocal拿出来使用就可以了。</p><p>然而，按照这个方式去实验时，发现有问题，拿不到ThreadLocal。原因是有hystrix这个东西，回忆下hystrix的原理，为了做到故障隔离，hystrix启用了自己的线程，不在同一个线程ThreadLocal失效。</p></blockquote><p>那么还有什么办法能够将标签信息一传到底呢，想想之前有没有人实现过类似的东西，没错sleuth，它的链路跟踪就能够将span传递下去，翻翻sleuth源码，找找其他资料，发现可以使用HystrixRequestVariableDefault，这里不建议直接使用HystrixConcurrencyStrategy，会和sleuth的strategy冲突。代码参见CoreHeaderInterceptor.java。现在可以测试zuul里面的rule，看能否拿到标签内容了。</p><blockquote><p>标签传到HystrixRequestVariableDefault这里的，如果项目中没有使用Hystrix就用不了了,这个时候需要做一个判断在restTemple里面做个判断，没有hystrix就直接threadlocal取。</p></blockquote><p><strong>Q:这里还不是终点，解决了zuul的路由，服务A调服务B这里的路由怎么处理呢？zuul算出来的标签如何往后面依次传递下去呢?</strong></p><p>   我们还是抄sleuth：把标签放入header，服务A调服务B时，将服务A header里面的标签放到服务B的header里，依次传递下去。这里的关键点就是：内部的微服务在接收到发来的请求时(zuul-&gt;A，A-&gt;B）我们将请求放入ThreadLocal，哦，不对，是HystrixRequestVariableDefault，还记得上面说的原因么：）。<br>   这个容易处理，写一个spring mvc拦截器即可，代码参见CoreHeaderInterceptor。然后发送请求时自动带上这个里面保存的标签信息，参见RestTemplate的拦截器CoreHttpRequestInterceptor。到此为止，技术上全部走通实现。</p><blockquote><p>总结一下：zuul依据用户或IP等计算标签，并将标签放入header里向后传递，后续的微服务通过拦截器，将header里的标签放入RestTemplate请求的header里继续向后接力传递。标签的内容通过放入类似于ThreadLocal的全局变量（HystrixRequestVariableDefault），使Ribbon Rule可以使用。</p></blockquote><h3 id="基于标签路由的测试"><a href="#基于标签路由的测试" class="headerlink" title="基于标签路由的测试"></a>基于标签路由的测试</h3><p>参见PreFilter源码，模拟了几个用户的标签，参见LabelAndWeightMetadataRule源码，模拟了OR AND两种标签处理策略。依次开启 config eureka provide（开两个实例，通过启动参数server.port指定不同端口区分） consumer zuul.</p><p><img src="/images/sc-study/sc-r-d03.png" alt="测试"></p><hr><p><img src="/images/sc-study/sc-r-d01.png" alt="测试"><br>访问 <a href="http://localhost:8761/metadata.html" target="_blank" rel="external">http://localhost:8761/metadata.html</a> 设置第一个provide 实例 orLabel为 CN,Test 发送请求头带入Authorization: emt 访问<a href="http://localhost:8080/provider/user" target="_blank" rel="external">http://localhost:8080/provider/user</a> 多刷几次，可以看到zuul所有请求均路由给了第一个实例。访问<a href="http://localhost:8080/consumer/test" target="_blank" rel="external">http://localhost:8080/consumer/test</a> 多刷几次，可以看到，consumer调用均路由给了第一个实例。</p><p>设置第二个provide 实例 andLabel为 EN,Male 发送请求头带入Authorization: em 访问<a href="http://localhost:8080/provider/user" target="_blank" rel="external">http://localhost:8080/provider/user</a> 多刷几次，可以看到zuul所有请求均路由给了第二个实例。访问<a href="http://localhost:8080/consumer/test" target="_blank" rel="external">http://localhost:8080/consumer/test</a> 多刷几次，可以看到，consumer调用均路由给了第二个实例。</p><p>Authorization头还可以设置为PreFilter里面的模拟token来做测试，至此所有内容讲解完毕，技术路线拉通，剩下的就是根据需求来完善你自己的路由策略啦。</p><h2 id="伪代码分析实现流程"><a href="#伪代码分析实现流程" class="headerlink" title="伪代码分析实现流程"></a>伪代码分析实现流程</h2><h3 id="伪代码示例"><a href="#伪代码示例" class="headerlink" title="伪代码示例"></a>伪代码示例</h3><p>Ribbon默认采用ZoneAvoidanceRule，优先选择同zone下的实例。我们继承这个rule并扩展我们自己的限流功能，仔细阅读ZoneAvoidanceRule及其父类源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedMetadataRule</span> <span class="keyword">extends</span> <span class="title">ZoneAvoidanceRule</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String META_DATA_KEY_WEIGHT = <span class="string">"weight"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    List&lt;Server&gt; serverList = <span class="keyword">this</span>.getPredicate().getEligibleServers(<span class="keyword">this</span>.getLoadBalancer().getAllServers(), key);</div><div class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(serverList)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 计算总值并剔除0权重节点</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    Map&lt;Server, Integer&gt; serverWeightMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (Server server : serverList) &#123;</div><div class="line">        String strWeight = ((DiscoveryEnabledServer) server).getInstanceInfo().getMetadata().get(META_DATA_KEY_WEIGHT);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> weight = <span class="number">100</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            weight = Integer.parseInt(strWeight);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="comment">// 无需处理</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (weight &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        serverWeightMap.put(server, weight);</div><div class="line">        sum += weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 权重随机</span></div><div class="line">    <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * sum);</div><div class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;Server, Integer&gt; entry : serverWeightMap.entrySet()) &#123;</div><div class="line">        current += entry.getValue();</div><div class="line">        <span class="keyword">if</span> (random &lt; current) &#123;</div><div class="line">            <span class="keyword">return</span> entry.getKey();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使上述代码生效，在zuul网关中加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">weightedMetadataRule</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> WeightedMetadataRule();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="代码示例测试"><a href="#代码示例测试" class="headerlink" title="代码示例测试"></a>代码示例测试</h3><p>打断点测试是否进入WeightedMetadataRule，开启多个服务A实例，通过zuul访问服务A。<br>成功进入断点，代码生效后，我们再来看如何指定metadata。<br>访问eureka restful API （我的eureka服务器端口为8100，修改为你自己的eureka端口）<br>Get <a href="http://localhost:8100/eureka/apps" target="_blank" rel="external">http://localhost:8100/eureka/apps</a><br>这个api可以看到所有服务<br>Get <a href="http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME" target="_blank" rel="external">http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME</a><br>这个api可以看到你的服务信息，包括部署了哪些实例<br>Get <a href="http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME/INSTANCE_ID" target="_blank" rel="external">http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME/INSTANCE_ID</a><br>这个api可以看到服务实例的信息，注意其中的metadata节点，目前为empty<br>Put <a href="http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME/INSTANCE_ID/metadata?weight=10" target="_blank" rel="external">http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME/INSTANCE_ID/metadata?weight=10</a><br>通过put方式可以修改metadata的内容，放入weight，设为10</p><p>然后稍等两分钟，让zuul更新注册中心中的信息，接着重新访问，调试就可以看到metadata的内容了，并且也是按照权重随机来进行流量限制的，至此hello world搞定。</p><h3 id="生产上使用WeightedMetadataRule"><a href="#生产上使用WeightedMetadataRule" class="headerlink" title="生产上使用WeightedMetadataRule"></a>生产上使用WeightedMetadataRule</h3><p>接下来，在生产环境中，我们如何应用这个WeightedMetadataRule呢，有如下几种方式：</p><h3 id="手动指定服务策略，"><a href="#手动指定服务策略，" class="headerlink" title="手动指定服务策略，"></a>手动指定服务策略，</h3><p>spring cloud ribbon并没有完整实现netflix ribbon的所有配置功能，负载策略默认只能配置微服务级别，无法配置全局默认值。<br>例如：只能配置 SOME_SERVICE_ID.ribbon.NFLoadBalancerRuleClassName=package.WeightedMetadataRule<br>而不支持配置全局默认值 ribbon.NFLoadBalancerRuleClassName=package.WeightedMetadataRule<br>这种方案明显不符合我们的要求。</p><h3 id="通过声明Irule-spring-bean配置全局负载策略"><a href="#通过声明Irule-spring-bean配置全局负载策略" class="headerlink" title="通过声明Irule spring bean配置全局负载策略"></a>通过声明Irule spring bean配置全局负载策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">weightedMetadataRule</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> WeightedMetadataRule();</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>这种方式也就是我们上面用的hello world方式，配置后强制所有微服务使用该策略，没有例外，微服务无法个性化定制策略，符合目前需求，但不适于长期规划。</p></blockquote><h3 id="继承重写PropertiesFactory"><a href="#继承重写PropertiesFactory" class="headerlink" title="继承重写PropertiesFactory"></a>继承重写PropertiesFactory</h3><p>继承重写org.springframework.cloud.netflix.ribbon.PropertiesFactory类，修正spring cloud ribbon未能完全支持netflix ribbon的问题。但是PropertiesFactory属性均为私有，应该是spring cloud不建议在此扩展。参见<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1741" target="_blank" rel="external">https://github.com/spring-cloud/spring-cloud-netflix/issues/1741</a></p><h3 id="使用spring-cloud官方建议的-RibbonClient方式"><a href="#使用spring-cloud官方建议的-RibbonClient方式" class="headerlink" title="使用spring cloud官方建议的@RibbonClient方式"></a>使用spring cloud官方建议的@RibbonClient方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@RibbonClients</span>(defaultConfiguration = DefaultRibbonConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRibbonConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;ribbon.client.name:#&#123;null&#125;&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line">    <span class="keyword">private</span> IClientConfig config;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> PropertiesFactory propertiesFactory;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 默认配置</span></div><div class="line">        WeightedMetadataRule rule = <span class="keyword">new</span> WeightedMetadataRule();</div><div class="line">        rule.initWithNiwsConfig(config);</div><div class="line">        <span class="keyword">return</span> rule;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于权重随机的性能，上述代码用的数组分段查找法，还可以采用TreeMap二分查找法。可以将权重数组或权重TreeMap缓存起来。<br>根据测试，在实例数量为50个时 缓存权重数组和权重TreeMap，数组分段查找百万次耗时78-125ms，TreeMap二分耗时50-80ms。</p><p>这篇文章只是把技术打通，至于如何根据服务器负载情况，自动降级，限流等需求，只需要监控服务器状况，调用eureka接口设置metadata即可（其实我个人建议这方面需求通过docker的自动扩容缩容完成，只是有朋友问到如何通过spring cloud实现）。</p><p>下一篇会写基于标签的流量控制。如何控制部分用户使用服务A2.0，其他用户使用服务A1.0。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://calvin1978.blogcn.com/articles/routing.html" target="_blank" rel="external">江南白衣-服务化之－路由</a><br><a href="http://www.jianshu.com/p/37ee1e84900a" target="_blank" rel="external">SpringCloud Ribbon 降级、限流、灰度发布</a></p>]]></content>
    
    <summary type="html">
    
      限流、降级、灰度是服务治理的一个很重要的功能。 Dubbo自带服务降级、限流功能，spring cloud并没有提供此功 能，只能由我们自行实现。这里的限流、降级、灰度都是针对服务 实例级别，并不是整个服务级别，整个服务级别可以通过实例部署 数量来实现。
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Ribbon" scheme="http://lvqingyan.com/tags/Spring-Cloud-Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>API GateWay(网关)那些儿事</title>
    <link href="http://lvqingyan.com/sc-zuul/"/>
    <id>http://lvqingyan.com/sc-zuul/</id>
    <published>2017-05-10T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>:现在越来越多的技术团队开始尝试采纳微服务架构进行产品开发。而基于微服务架构后后端服务通常而言是动态的，为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度，这边文章我们就来聊聊API Gateway的那些事。<br> 关键字：<strong>API Gateway</strong>, <strong>Spring Cloud Zuul</strong>, <strong>Nginx</strong>，<strong>Consul</strong>，<strong>Consul-Template</strong>。</p><h2 id="为什么需要API-Gateway"><a href="#为什么需要API-Gateway" class="headerlink" title="为什么需要API Gateway"></a>为什么需要API Gateway</h2><ul><li>简化客户端调用复杂度</li></ul><p>在微服务架构模式下后端服务的实例数一般是动态的，对于客户端而言如何发现这些动态改变的服务实例的访问地址信息？因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。<br><a id="more"></a><br><img src="/images/sc-study/gw.png" alt=""></p><ul><li>数据裁剪以及聚合</li></ul><p>通常而言多余不同的客户端对于显示时对于数据的需求是不一致的，比如手机端或者Web端又或者在低延迟的网络环境或者高延迟的网络环境。</p><p>因此为了优化客户端的使用体验，API Gateway可以对通用性的响应数据进行裁剪以适应不同客户端的使用需求。同时还可以将多个API调用逻辑进行聚合，从而减少客户端的请求数，优化客户端用户体验</p><ul><li>多渠道支持</li></ul><p>当然我们还可以针对不同的渠道和客户端提供不同的API Gateway,对于该模式的使用由另外一个大家熟知的方式叫<strong>Backend for front-end</strong>, 在Backend for front-end模式当中，我们可以针对不同的客户端分别创建其BFF</p><p><img src="/images/sc-study/gw1.png" alt=""></p><ul><li>遗留系统的微服务化改造</li></ul><p>对于系统系统而言进行微服务改造通常是由于原有的系统存在或多或少的问题，比如技术债务，代码质量，可维护性，可扩展性等等。API Gateway的模式同样适用于这一类遗留系统的改造，通过微服务化的改造逐步实现对原有系统中的问题的修复，从而提升对于原有业务<strong>响应力</strong>的提升。<strong>通过引入抽象层，逐步使用新的实现替换旧的实现。</strong></p><p><img src="/images/sc-study/gw2.png" alt=""></p><h2 id="使用Zuul实现API网关"><a href="#使用Zuul实现API网关" class="headerlink" title="使用Zuul实现API网关"></a>使用Zuul实现API网关</h2><p>Spring Cloud的Zuul组件提供了轻量级网关的功能支持，通过定义路由规则可以快速实现一个轻量级的API网关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">zuul:</div><div class="line">  ignoredPatterns: /api/auth</div><div class="line">  sensitive-headers: &quot;*&quot;</div><div class="line">  ignoreLocalService: true</div><div class="line">  retryable: false</div><div class="line">  host:</div><div class="line">    max-total-connections: 500</div><div class="line">  routes:</div><div class="line">    service01:</div><div class="line">      path: /service01/**</div><div class="line">      serviceId: service01</div><div class="line">      stripPrefix: true</div><div class="line">    thirdpart:</div><div class="line">      pateh: /thirdpart/**</div><div class="line">      url: http://thirdpart.api.com</div></pre></td></tr></table></figure><p>同时除了通过serviceId关联已经注册到Consul的服务实例以外，我们也可以通过zuul直接定义实现对已有服务的直接集成。</p><p>这里我们就不过多介绍Zuul的细节，在实际使用中我们会发现直接使用Zuul会存在诸多问题，包括：</p><ul><li>性能问题：当存在大量请求超时后会造成Zuul阻塞，目前只能通过横向扩展Zuul实例实现对高并发的支持；</li><li>WebSocket的支持问题： Zuul中并不直接提供对WebSocket的支持，需要添加额外的过滤器实现对WebSocket的支持；<br><img src="/images/sc-study/gw-scoket.jpg" alt=""><br>为了解决以上问题，可以通过在Zuul前端部署Nginx实现对Zuul实例的反向代理，同时适当的通过添加Cache以及请求压缩减少对后端Zuul实例的压力。</li></ul><p><img src="/images/sc-study/gw3.png" alt=""></p><h2 id="实现Nginx的动态代理"><a href="#实现Nginx的动态代理" class="headerlink" title="实现Nginx的动态代理"></a>实现Nginx的动态代理</h2><p>通过Nginx我们可以实现对多实例Zuul的请求代理，同时通过添加适当的缓存以及请求压缩配置可以提升前端UI的请求响应时间。这里需要解决的问题是Nginx如何动态发现Zuul实例信息并且将请求转发到Zuul当中。</p><p><a href="https://github.com/hashicorp/consul-template" target="_blank" rel="external">consul-template</a>可以帮助我们解决以上问题,consul-template是一个命令行工具，结合consul实现配置文件的动态生成并且支持在配置文件发生变化后触发用户自定义命令。</p><p>我们使用了如下的Dockerfile用于构建我们的Nginx服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">FROM nginx:1.11.10</div><div class="line"></div><div class="line">ADD consul-template /usr/local/bin</div><div class="line"></div><div class="line">RUN mkdir /etc/consul-templates</div><div class="line"></div><div class="line"># 模板文件</div><div class="line">ADD nginx.tpl /etc/consul-templates/nginx.tpl</div><div class="line">ENV CT_FILE /etc/consul-templates/nginx.tpl</div><div class="line"></div><div class="line">ENV NX_FILE /etc/nginx/conf.d/default.conf # 目标文件</div><div class="line"></div><div class="line">ENV SERVICE identity # 注册在Consul的服务名</div><div class="line"></div><div class="line">COPY dist /usr/share/nginx/html</div><div class="line">RUN mkdir -p /data/cache</div><div class="line"></div><div class="line">CMD /usr/sbin/nginx -c /etc/nginx/nginx.conf  \</div><div class="line">  &amp; CONSUL_TEMPLATE_LOG=debug \</div><div class="line">  consul-template -consul-addr=$CONSUL -template &quot;$CT_FILE:$NX_FILE:/usr/sbin/nginx -s reload&quot;;</div></pre></td></tr></table></figure><p>Nginx配置模板文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># nginx.tpl</div><div class="line">upstream api_server &#123;</div><div class="line">  least_conn;</div><div class="line">  &#123;&#123;range service &quot;identity&quot;&#125;&#125;</div><div class="line">  server  &#123;&#123;.Address&#125;&#125;:&#123;&#123;.Port&#125;&#125;;</div><div class="line">  &#123;&#123;else&#125;&#125;server 127.0.0.1:9191;&#123;&#123;end&#125;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  localhost;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        root   /usr/share/nginx/html;</div><div class="line">        index  index.html index.htm;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /api &#123;</div><div class="line">      proxy_pass http://api_server;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream api_server &#123;</div><div class="line">  least_conn;</div><div class="line">  &#123;&#123;range service &quot;identity&quot;&#125;&#125;</div><div class="line">  server  &#123;&#123;.Address&#125;&#125;:&#123;&#123;.Port&#125;&#125;;</div><div class="line">  &#123;&#123;else&#125;&#125;server 127.0.0.1:9191;&#123;&#123;end&#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>会根据当前consul中注册的所有identity服务实例进行模板渲染，并且当配置文件内容发生变化后调用nginx -s reload重新加载Nginx配置从而实现对于后端服务实例的动态代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CMD /usr/sbin/nginx -c /etc/nginx/nginx.conf  \</div><div class="line">  &amp; CONSUL_TEMPLATE_LOG=debug \</div><div class="line">  consul-template -consul-addr=$CONSUL -template &quot;$CT_FILE:$NX_FILE:/usr/sbin/nginx -s reload&quot;;</div></pre></td></tr></table></figure><h2 id="其它的一些优化建议"><a href="#其它的一些优化建议" class="headerlink" title="其它的一些优化建议"></a>其它的一些优化建议</h2><p>启用Nginx的Gzip可以对服务器端响应内容进行压缩从而减少一定的客户端响应时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gzip on;</div><div class="line">gzip_min_length 1k;</div><div class="line">gzip_buffers  4 32k;</div><div class="line">gzip_types    text/plain application/x-javascript application/javascript text/xml text/css;</div><div class="line">gzip_vary on;</div></pre></td></tr></table></figure><p>缓存图片以及其它静态资源可以减少对Zuul实例的请求量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">proxy_buffering on;</div><div class="line">proxy_cache_valid any 10m;</div><div class="line">proxy_cache_path /data/cache levels=1:2 keys_zone=my-cache:8m max_size=1000m inactive=600m;</div><div class="line">proxy_temp_path /data/temp;</div><div class="line">proxy_buffer_size 4k;</div><div class="line">proxy_buffers 100 8k;</div><div class="line"></div><div class="line">location ~* (images)    &#123;</div><div class="line">  proxy_pass http://api_server;</div><div class="line">  # cache setting</div><div class="line">  proxy_cache my-cache;</div><div class="line">  proxy_cache_valid 200;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果需要通过Nginx实现对Websocket的代理可以添加一下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">location /sockjs &#123;</div><div class="line">    proxy_pass http://api_server;</div><div class="line"></div><div class="line">    proxy_set_header X-Real-IP $remote_addr;</div><div class="line">    proxy_set_header Host $host;</div><div class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line"></div><div class="line">    # WebSocket support (nginx 1.4)</div><div class="line">    proxy_http_version 1.1;</div><div class="line">    proxy_set_header Upgrade $http_upgrade;</div><div class="line">    proxy_set_header Connection &quot;upgrade&quot;;</div><div class="line">    proxy_connect_timeout 90;</div><div class="line">    proxy_send_timeout 90;</div><div class="line">    proxy_read_timeout 90;</div><div class="line"></div><div class="line">    # !!!Support Spring Boot</div><div class="line">    proxy_pass_header X-XSRF-TOKEN;</div><div class="line">    proxy_set_header Origin &quot;http://localhost:4000&quot;;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;:现在越来越多的技术团队开始尝试采纳微服务架构进行产品开发。而基于微服务架构后后端服务通常而言是动态的，为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度，这边文章我们就来聊聊API Gateway的那些事。&lt;br&gt; 关键字：&lt;strong&gt;API Gateway&lt;/strong&gt;, &lt;strong&gt;Spring Cloud Zuul&lt;/strong&gt;, &lt;strong&gt;Nginx&lt;/strong&gt;，&lt;strong&gt;Consul&lt;/strong&gt;，&lt;strong&gt;Consul-Template&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要API-Gateway&quot;&gt;&lt;a href=&quot;#为什么需要API-Gateway&quot; class=&quot;headerlink&quot; title=&quot;为什么需要API Gateway&quot;&gt;&lt;/a&gt;为什么需要API Gateway&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简化客户端调用复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在微服务架构模式下后端服务的实例数一般是动态的，对于客户端而言如何发现这些动态改变的服务实例的访问地址信息？因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。&lt;br&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>Spring  Cloud Zuul的URL转发和路由规则</title>
    <link href="http://lvqingyan.com/sc-zuul-01/"/>
    <id>http://lvqingyan.com/sc-zuul-01/</id>
    <published>2017-04-30T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>:最近开了《跟我学Spring Cloud》系列教程,由于最近比较忙，因此更新较慢。由于自己最近在研究基于Netty名为Janus的网关中间件分为janus-Server端和janus-console管控端，纳管Spring Cloud实现市面上网关85%以上的功能，将在2017年5月6号Spring Cloud中国社区北京技术沙龙分享。顺便抽时间把Spring Cloud Zuul相关的东西整理比较。在本篇文章中Spring Cloud的版本更换为Dalston.RELEASE，Spring Boot的版本为1.5.2.RELEASE。</p><h2 id="Spring-Cloud-Zuul"><a href="#Spring-Cloud-Zuul" class="headerlink" title="Spring Cloud Zuul"></a>Spring Cloud Zuul</h2><p> Spring Cloud Zuul 通过与 Spring Cloud Eureka 进行整合，将自身注册到 Eureka Server中，与Eureka,Ribbon,Hystrix等整合，同时从 Eureka 中获得了所有其它微服务的实例信息。这样的设计通过把网关和服务治理整合到一起，Spring Cloud Zuul可以获取到服务注册信息，结合Ribbon，Hystrix等更好的实现路由转发，负载均衡等功能。想了解更多的内容，可以参考下面的中英文对照翻译文档。或者查看官网文档。<br>   <a href="http://xujin.org/sc/docs/sc-en-zuul-01/" target="_blank" rel="external">Spring Cloud Zuul中英文对照翻译①</a>  <a href="http://xujin.org/sc/docs/sc-en-zuul-02/" target="_blank" rel="external">Spring Cloud Zuul中英文对照翻译②</a>   <a href="http://xujin.org/sc/docs/sc-en-zuul-03/" target="_blank" rel="external">Spring Cloud Zuul中英文对照翻译③</a><br><a id="more"></a><br> <img src="/images/sc-study/janus.jpg" alt="Janus网关"></p><h2 id="快速搭建SC-Zuul"><a href="#快速搭建SC-Zuul" class="headerlink" title="快速搭建SC Zuul"></a>快速搭建SC Zuul</h2><p>工程目录如下图所示:</p><p><img src="/images/sc-study/sc-zuul-01-ml.png" alt="工程目录"></p><blockquote><p>Code地址:<a href="https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-zuul-first" target="_blank" rel="external">https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-zuul-first</a></p></blockquote><h3 id="Spring-Cloud-Zuul原始的URL转发功能"><a href="#Spring-Cloud-Zuul原始的URL转发功能" class="headerlink" title="Spring Cloud Zuul原始的URL转发功能"></a>Spring Cloud Zuul原始的URL转发功能</h3><p> 由于sc-zuul-first-provider1的代码极其简单就是一个简单的服务提供者，因此不做过多介绍。下面主要介绍sc-zuul-first-zuul-no-eureka这个工程，</p><h4 id="URL路由转发功能"><a href="#URL路由转发功能" class="headerlink" title="URL路由转发功能"></a>URL路由转发功能</h4><ol><li><p>创建名为sc-zuul-first-zuul-no-eureka的maven工程,添加依赖，但注意的是该工程只有Zuul的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"> &lt;?xml version="1.0"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xujin.sc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sc-zuul-first-zuul-no-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>sc-zuul-first-zuul-no-eureka<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">  </div><div class="line"> <span class="comment">&lt;!-- 引入spring boot的依赖 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 引入spring cloud的依赖 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- 添加spring-boot的maven插件 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure><blockquote><p>说明: 对于 spring-cloud-starter-zuul 依赖，我们可以通过查看它的依赖内容了解 到：该模块中不仅包含了 Netflix Zuul 的核心依赖 zuul-core，它还包含了下面这 些网关服务需要的重要依赖。<br> spring-cloud-starter-hystrix：该依赖用来在网关服务中实现对微服务 转发时候的保护机制，通过线程隔离和断路器，防止微服务的故障引发 API 网关 资源无法释放，从而影响其他应用的对外服务。<br> spring-cloud-starter-ribbon：该依赖用来实现在网关服务进行路由转发 时候的客户端负载均衡以及请求重试。<br> spring-boot-starter-actuator ：该依赖用来提供常规的微服务管理端点。另外，在Spring Cloud Zuul中还特别提供了/routes 端点来返回当前的所有路由规则。</p></blockquote></li></ol><p>2.主入口程序代码如下，使用@EnableZuulProxy注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xujin.sc.zuul.first.zuul;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulServer;</div><div class="line"></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableZuulProxy</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudZuulApplication</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">SpringApplication.run(SpringCloudZuulApplication.class, args);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3.application.yml配置文件信息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.port=8041</div><div class="line">spring.application.name=sc-zuul-first-zuul-no-eureka</div><div class="line"></div><div class="line">zuul.routes.api-url.path=/api-url/**</div><div class="line">zuul.routes.api-url.url=http://localhost:8000/</div></pre></td></tr></table></figure></p><p>该配置定义了发往 API 网关服务的请求中，所有符合/api-url/**规则的访问都 将 被 路 由 转 发 到  <a href="http://localhost:8000/" target="_blank" rel="external">http://localhost:8000/</a> 地 址 上 ， 也 就 是 说 当 我 们 访 问 <a href="http://localhost:8041/api-url/sc/order/1" target="_blank" rel="external">http://localhost:8041/api-url/sc/order/1</a> 可以正常的把请求的url转发到<a href="http://localhost:8000/sc/order/2" target="_blank" rel="external">http://localhost:8000/sc/order/2</a> 。其 中 ， 配 置 属 性 zuul.routes.api-url.path 中的 api-url 部分为路由的名字，可以任意定义， 但是一组 path 和 url 映射关系的路由名要相同。</p><blockquote><p>zuul.routes.api-url.url=<a href="http://localhost:8000/" target="_blank" rel="external">http://localhost:8000/</a> 这个配置了服务提供者sc-zuul-first-provider1的URL</p></blockquote><p>4.测试依次按如下顺序,把各个服务启动。<br> <em>注册中心为：sc-zuul-first-eureka-server </em>服务提供者为:sc-zuul-first-provider1，sc-zuul-first-provider2<br> <em>启动sc-zuul-first-zuul-no-eureka </em>上述Server启动之后，测试Case:</p><h4 id="URL路由转发功能测试"><a href="#URL路由转发功能测试" class="headerlink" title="URL路由转发功能测试"></a>URL路由转发功能测试</h4><p>1.当注解为@EnableZuulProxy时，测试转发。通过访问网关的URL: <a href="http://localhost:8041/api-url/sc/order/1" target="_blank" rel="external">http://localhost:8041/api-url/sc/order/1</a> 可以正常的把请求的url转发到<a href="http://localhost:8000/sc/order/2" target="_blank" rel="external">http://localhost:8000/sc/order/2</a></p><p> <img src="/images/sc-study/sc-zuul-01-zfdebug.png" alt="网关URL转发Debug"></p><blockquote><p>Tips:断点跳过之后,返回结果如下，说明当使用@EnableZuulProxy注解的时候，Zuul具有URL转发调用的功能。</p></blockquote><p> <img src="/images/sc-study/sc-zuul-01-zf.png" alt="网关URL转发"></p><p>2.关闭sc-zuul-first-zuul-no-eureka对应的服务，把主应用程序中的注解@EnableZuulProxy变为@EnableZuulServer,按第1步启动sc-zuul-first-zuul-no-eureka服务，测试。</p><p> <img src="/images/sc-study/sc-zuul-01-pts.png" alt="换为@EnableZuulServer注解变为普通的Zuul Server"></p><blockquote><p>Tips: 可以看到上图返回结果为200，但是空白。那为什么会这样呢？后面专门对Zuul的源码分析，请读者忽略或自行查看源码。</p></blockquote><h2 id="Spring-Cloud-Zuul功能"><a href="#Spring-Cloud-Zuul功能" class="headerlink" title="Spring Cloud Zuul功能"></a>Spring Cloud Zuul功能</h2><p>   大家知道Spring Cloud的服务治理的粒度是服务应用名，而如下的配置规则硬编码配置主机名和端口，由于Spring Cloud Zuul整合了Ribbon负载均衡器等因此，下面的配置方式不推荐使用比较low。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.port=8041</div><div class="line">spring.application.name=sc-zuul-first-zuul-no-eureka</div><div class="line"></div><div class="line">zuul.routes.api-url.path=/api-url/**</div><div class="line">zuul.routes.api-url.url=http://localhost:8000/</div></pre></td></tr></table></figure></p><h3 id="Spring-Cloud-Zuul功能案例"><a href="#Spring-Cloud-Zuul功能案例" class="headerlink" title="Spring Cloud Zuul功能案例"></a>Spring Cloud Zuul功能案例</h3><p>1.为了演示面向服务名为粒度的路由规则，新建了一个名为sc-zuul-first-zuul的工程，该工程与sc-zuul-first-zuul-no-eureka的最大的区别就是在pom.xml文件中，加入spring-cloud-starter-eureka依赖,如下注释所示。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 多了eureka starter --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p><p>2.application.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8040</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">sc-zuul-first-zuul</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    service-url:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></div></pre></td></tr></table></figure></p><p>3.主应用程序代码SpringCloudZuulApplication.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xujin.sc.zuul.first.zuul;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> xujin</div><div class="line"> * <span class="doctag">@EnableZuulProxy</span> 声明一个Zuul 代理，该代理使用Ribbon软负载均衡，还整合Hystrix实现熔断</div><div class="line"> */</div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableZuulProxy</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudZuulApplication</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(SpringCloudZuulApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>4.分别依次把sc-zuul-first-eureka-server，sc-zuul-first-zuul，sc-zuul-first-provider1，<br>sc-zuul-first-provider2，sc-zuul-first-consumer，sc-zuul-first-hystrix-dashboard启动。<br><img src="/images/sc-study/sc-zuul-01-eurserver.png" alt="Eureka Server"></p><h3 id="Spring-Cloud-Zuul功能演示"><a href="#Spring-Cloud-Zuul功能演示" class="headerlink" title="Spring Cloud Zuul功能演示"></a>Spring Cloud Zuul功能演示</h3><p>1.网关的默认路由规则<br>   说明默认情况下，Zuul会代理所有注册到Eureka Server的微服务，并且Zuul的路由规则如下：<br>   <a href="http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/**" target="_blank" rel="external">http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/**</a> 会被转发到serviceId对应的微服务。<br>   <a href="http://localhost:8040/sc-zuul-first-provider/sc/order/2" target="_blank" rel="external">http://localhost:8040/sc-zuul-first-provider/sc/order/2</a><br>   <img src="/images/sc-study/sc-zuul-01-t1.png" alt="默认路由规则"><br>2.网关的负载均衡<br>   <a href="http://localhost:8040/sc-zuul-first-provider/sc/order/2" target="_blank" rel="external">http://localhost:8040/sc-zuul-first-provider/sc/order/2</a><br>   通过网关访问服务提供者，负载均衡打出对应的日志<br>  <figure class="highlight console"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  2017-04-30 18:35:37.502[0;39m [32m INFO[0;39m [35m3443[0;39m [2m---[0;39m [2m[nio-8000-exec-3][0;39m [36mo.x.s.e.f.o.controller.OrderController  [0;39m [2m:[0;39m Zuul路由到服务提供者①</div><div class="line">  2017-04-30 18:34:06.764[0;39m [32m INFO[0;39m [35m3444[0;39m [2m---[0;39m [2m[nio-8001-exec-4][0;39m [36mo.x.s.e.f.o.controller.OrderController  [0;39m [2m:[0;39m Zuul路由到服务提供者②</div><div class="line">[2m2017-04-30 18:35:37.251[0;39m [32m INFO[0;39m [35m3444[0;39m [2m---[0;39m [2m[trap-executor-0][0;39m [36mc.n.d.s.r.aws.ConfigClusterResolver     [0;39m [2m:[0;39m Resolving eureka endpoints via configuration</div></pre></td></tr></table></figure></p><p>3.集成Hystrix<br> <a href="http://localhost:8040/hystrix.stream" target="_blank" rel="external">http://localhost:8040/hystrix.stream</a><br> <img src="/images/sc-study/sc-zuul-01-t2.png" alt=""></p><h2 id="Spring-Cloud-Zuul路由规则"><a href="#Spring-Cloud-Zuul路由规则" class="headerlink" title="Spring Cloud Zuul路由规则"></a>Spring Cloud Zuul路由规则</h2><h3 id="指定服务路由对外访问路径"><a href="#指定服务路由对外访问路径" class="headerlink" title="指定服务路由对外访问路径"></a>指定服务路由对外访问路径</h3> <figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line"><span class="attr"> routes:</span></div><div class="line"><span class="attr">   sc-zuul-first-provider:</span> <span class="string">/order/**</span></div></pre></td></tr></table></figure><blockquote><p>相当于把sc-zuul-first-provider映射为/order/**，访问<a href="http://localhost:8040/sc-zuul-first-provider/sc/order/2" target="_blank" rel="external">http://localhost:8040/sc-zuul-first-provider/sc/order/2</a><br>  可以等价于:<a href="http://localhost:8040/order/sc/order/2，其它路由规则，可以从官网文档中阅读尝试。" target="_blank" rel="external">http://localhost:8040/order/sc/order/2，其它路由规则，可以从官网文档中阅读尝试。</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;:最近开了《跟我学Spring Cloud》系列教程,由于最近比较忙，因此更新较慢。由于自己最近在研究基于Netty名为Janus的网关中间件分为janus-Server端和janus-console管控端，纳管Spring Cloud实现市面上网关85%以上的功能，将在2017年5月6号Spring Cloud中国社区北京技术沙龙分享。顺便抽时间把Spring Cloud Zuul相关的东西整理比较。在本篇文章中Spring Cloud的版本更换为Dalston.RELEASE，Spring Boot的版本为1.5.2.RELEASE。&lt;/p&gt;
&lt;h2 id=&quot;Spring-Cloud-Zuul&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Zuul&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Zuul&quot;&gt;&lt;/a&gt;Spring Cloud Zuul&lt;/h2&gt;&lt;p&gt; Spring Cloud Zuul 通过与 Spring Cloud Eureka 进行整合，将自身注册到 Eureka Server中，与Eureka,Ribbon,Hystrix等整合，同时从 Eureka 中获得了所有其它微服务的实例信息。这样的设计通过把网关和服务治理整合到一起，Spring Cloud Zuul可以获取到服务注册信息，结合Ribbon，Hystrix等更好的实现路由转发，负载均衡等功能。想了解更多的内容，可以参考下面的中英文对照翻译文档。或者查看官网文档。&lt;br&gt;   &lt;a href=&quot;http://xujin.org/sc/docs/sc-en-zuul-01/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud Zuul中英文对照翻译①&lt;/a&gt;  &lt;a href=&quot;http://xujin.org/sc/docs/sc-en-zuul-02/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud Zuul中英文对照翻译②&lt;/a&gt;   &lt;a href=&quot;http://xujin.org/sc/docs/sc-en-zuul-03/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud Zuul中英文对照翻译③&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Netflix之Eureka上篇</title>
    <link href="http://lvqingyan.com/sc-netflix-eureka/"/>
    <id>http://lvqingyan.com/sc-netflix-eureka/</id>
    <published>2016-10-23T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言:Spring Cloud NetFlix这个项目对NetFlix中一些久经考验靠谱的服务发现，熔断，网关，智能路由，以及负载均衡等做了封装，并通过注解的或简单配置的方式提供给Spring Cloud用户用。本文主要介绍 Spring Cloud中的Eureka组件。由于Spring Cloud做技术选型时中立的，因此Spring Cloud也提供了Spring Cloud Zookeeper,Spring Cloud Consul用于服务治理或服务发现供大家选择使用，另外我还发现<a href="https://github.com/SpringCloud/spring-cloud-etcd" target="_blank" rel="external">Spring Cloud etcd</a>这个项目，也可以用于服务注册和发现<br><a id="more"></a></p><h2 id="什么是-Spring-Cloud-Netflix"><a href="#什么是-Spring-Cloud-Netflix" class="headerlink" title="什么是 Spring Cloud Netflix ?"></a>什么是 Spring Cloud Netflix ?</h2><p>其官方文档中对自己的定义是如下，<a href="http://cloud.spring.io/spring-cloud-netflix/" target="_blank" rel="external">官网连接</a>,<a href="https://github.com/spring-cloud/spring-cloud-netflix" target="_blank" rel="external">Github地址</a></p><blockquote><p>This project provides Netflix OSS integrations for Spring Boot apps through autoconfiguration and binding to the Spring Environment and other Spring programming model idioms. With a few simple annotations you can quickly enable and configure the common patterns inside your application and build large distributed systems with battle-tested Netflix components. The patterns provided include Service Discovery (Eureka), Circuit Breaker (Hystrix), Intelligent Routing (Zuul) and Client Side Load Balancing (Ribbon).</p></blockquote><p>Spring Cloud Netflix这个项目对于Spring Boot应用来说，它集成了NetFlix OSS的一些组件，只需通过注解配置和Spring环境的通用简单的使用注解，你可以快速的启用和配置这些久经测试考验的NetFlix的组件于你的应用和用于构建分布式系统中。这些组件包含的功能有服务发现（Eureka），熔断器（Hystrix），智能路由(Zuul)以及客户端的负载均衡器（Ribbon）</p><p>简单的来说，Spring Cloud NetFlix这个项目对NetFlix中一些久经考验靠谱的服务发现，熔断，网关，智能路由，以及负载均衡等做了封装，并通过注解的或简单配置的方式提供给Spring Cloud用户用。</p><h2 id="什么是-Eureka"><a href="#什么是-Eureka" class="headerlink" title="什么是 Eureka?"></a>什么是 Eureka?</h2><p>官网定义是:</p><blockquote><p>Eureka is a REST (Representational State Transfer) based service that is primarily used in the AWS cloud for locating services for the purpose of load balancing and failover of middle-tier servers. We call this service, the Eureka Server. Eureka also comes with a Java-based client component,the Eureka Client, which makes interactions with the service much easier. The client also has a built-in load balancer that does basic round-robin load balancing.</p></blockquote><p>简单来说Eureka就是Netflix开源的一款提供服务注册和发现的产品，并且提供了相应的Java客户端。</p><h2 id="为什么要选择-Eureka"><a href="#为什么要选择-Eureka" class="headerlink" title="为什么要选择 Eureka?"></a>为什么要选择 Eureka?</h2><p>那么为什么我们在项目中使用了Eureka呢？主要原因如下:</p><ul><li><strong>它提供了完整的Service Registry和Service Discovery实现</strong><ul><li>首先是提供了完整的实现，并且也经受住了Netflix的生产环境考验，使用比较方便只需通过注解或简单配置的方式即可。</li></ul></li><li><strong>和Spring Cloud无缝集成</strong><ul><li>Spring Cloud对Eureka做了无缝集成，提供了一套完善的解决方案，所以使用起来非常方便。</li><li>另外，Eureka支持嵌入到应用自身的容器中启动，应用启动完之后，既充当了Eureka的角色，同时也是服务的提供者。这样就极大的提高了服务的可用性。</li></ul></li><li><strong>开源</strong><ul><li>开源代码，方便学习掌握其源码并驾驭它。  </li></ul></li></ul><p>参考阅读：为什么不应该使用ZooKeeper做服务发现<br>英文链接:<br>Eureka! Why You Shouldn’t Use ZooKeeper for Service Discovery:<br><a href="http://www.knewton.com/tech/blog/2014/12/eureka-shouldnt-use-zookeeper-service-discovery/" target="_blank" rel="external">http://www.knewton.com/tech/blog/2014/12/eureka-shouldnt-use-zookeeper-service-discovery/</a><br>中文链接:<br><a href="http://blog.csdn.net/jenny8080/article/details/52448403" target="_blank" rel="external">http://blog.csdn.net/jenny8080/article/details/52448403</a><br>Eureka vs. Zookeeper：<br><a href="https://groups.google.com/forum/#%21topic/eureka_netflix/LXKWoD14RFY" target="_blank" rel="external">https://groups.google.com/forum/#%21topic/eureka_netflix/LXKWoD14RFY</a></p><h2 id="进一步了解-Eureka"><a href="#进一步了解-Eureka" class="headerlink" title="进一步了解 Eureka"></a>进一步了解 Eureka</h2><h3 id="Eureka基本架构图"><a href="#Eureka基本架构图" class="headerlink" title="Eureka基本架构图"></a>Eureka基本架构图</h3><p><img src="/images/spring-cloud-netflix/eureka/architecture-overview.png" alt="architecture-overview"></p><p>上图简要描述了Eureka的基本架构，由3个角色组成：</p><ol><li><p><strong>Eureka Server</strong></p><ul><li>提供服务注册和发现</li></ul></li><li><p><strong>Service Provider</strong></p><ul><li>服务提供者，服务启动的时候会将自己的服务信息注册到Eureka</li></ul></li><li><p><strong>Service Consumer</strong></p><ul><li>服务消费者，从Eureka中获取已注的服务信息，用于调用服务生产者</li></ul></li></ol><p>需要注意一点是：一个Service Provider既可以是Service Consumer，也可以是Service Provider。</p><h3 id="集群模式下的Eureka"><a href="#集群模式下的Eureka" class="headerlink" title="集群模式下的Eureka"></a>集群模式下的Eureka</h3><p><img src="/images/spring-cloud-netflix/eureka/architecture-detail.png" alt="architecture-detail"></p><p>上图更进一步的展示了3个角色之间的交互。</p><ol><li>Service Provider会向Eureka Server做Register（服务注册）、Renew（服务续约）、Cancel（服务下线）等操作。</li><li>Eureka Server之间会做注册服务的同步，从而保证状态一致</li><li>Service Consumer会向Eureka Server获取注册服务列表，并消费服务</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言:Spring Cloud NetFlix这个项目对NetFlix中一些久经考验靠谱的服务发现，熔断，网关，智能路由，以及负载均衡等做了封装，并通过注解的或简单配置的方式提供给Spring Cloud用户用。本文主要介绍 Spring Cloud中的Eureka组件。由于Spring Cloud做技术选型时中立的，因此Spring Cloud也提供了Spring Cloud Zookeeper,Spring Cloud Consul用于服务治理或服务发现供大家选择使用，另外我还发现&lt;a href=&quot;https://github.com/SpringCloud/spring-cloud-etcd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud etcd&lt;/a&gt;这个项目，也可以用于服务注册和发现&lt;br&gt;
    
    </summary>
    
      <category term="Spring Cloud Eureka" scheme="http://lvqingyan.com/categories/Spring-Cloud-Eureka/"/>
    
    
      <category term="Spring Cloud Netflix" scheme="http://lvqingyan.com/tags/Spring-Cloud-Netflix/"/>
    
      <category term="Eureka" scheme="http://lvqingyan.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Sleuth-全链路监控调研</title>
    <link href="http://lvqingyan.com/sc-sleuth/"/>
    <id>http://lvqingyan.com/sc-sleuth/</id>
    <published>2016-10-21T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言:做过软件开发的都知道，对<code>系统进行全链路的监控</code>是非常有必要的。在单体应用中，传统的方式是软件开发者，通过自定义日志的level，日志文件的方式记录单体应用的<code>运行日志</code>。从而排查线上系统出现运行过慢，出现故障，异常等问题，但是在微服务架构或分布式系统中，一个系统被拆分成了A、B、C、D、E等多个服务，而每个服务可能又有多个实例组成集群，采用上诉定位问题的方式就行不通了，你充其量就知道某个服务是应用的瓶颈，但中间发生了什么你完全不知道。而且问题的查询，因为有海量各种各样的日志等文件，导致<code>追溯定位问题</code>等极其不方便。因此需要<code>全链路监控系统的收集，上报，对海量日志实时计算生成，监控告警，视图报表，帮助开发人员快速定位问题</code>。</p><h2 id="服务追踪分析"><a href="#服务追踪分析" class="headerlink" title="服务追踪分析"></a>服务追踪分析</h2><p>一个由微服务构成的应用系统由N个服务实例组成，通过<code>REST请求</code>或者<code>RPC协议</code>等来通讯完成一个业务流程的调用。对于入口的一个调用可能需要有多个后台服务协同完成，链路上<code>任何一个调用超时</code>或<code>出错</code>都可能造成前端请求的失败。服务的调用链也会越来越长，并形成一个树形的调用链。如下图所示:<br><img src="/images/spring-cloud-sleuth/1/dyl.png" alt="调用链"><br><a id="more"></a><br>但是随着服务的增多，对调用链的分析也会越来越负责。设想你在负责下面这个系统，其中每个小点都是一个微服务，他们之间的调用关系形成了复杂的网络。如下图所示:<br><img src="/images/spring-cloud-sleuth/1/qzfw.png" alt="调用关系复杂网络图"></p><p>通过该图，可以看出错综复杂的调用网路图。针对服务化应用全链路追踪的问题，Google发表了Dapper论文，介绍了他们如何进行服务追踪分析。其基本思路是在服务调用的请求和响应中加入ID，标明上下游请求的关系。利用这些信息，可以可视化地分析服务调用链路和服务间的依赖关系。</p><h2 id="什么是-Spring-Cloud-Sleuth"><a href="#什么是-Spring-Cloud-Sleuth" class="headerlink" title="什么是 Spring Cloud Sleuth ?"></a>什么是 Spring Cloud Sleuth ?</h2><p>Spring Cloud Sleuth为Spring Cloud提供了分布式追踪方案，为了更好的理解这个领域中的一些概念，建议先自行搜索学习一下Google Dapper相关的论文，<a href="http://research.google.com/pubs/pub36356.html，github" target="_blank" rel="external">http://research.google.com/pubs/pub36356.html，github</a> Code连接:<a href="https://github.com/spring-cloud/spring-cloud-sleuth" target="_blank">Spring Cloud Sleuth Code</a>。官方文档地址:<a href="http://cloud.spring.io/spring-cloud-sleuth/spring-cloud-sleuth.html" target="_blank" rel="external">http://cloud.spring.io/spring-cloud-sleuth/spring-cloud-sleuth.html</a>. 其官方文档中对自己的定义是如下：</p><blockquote><p>Spring Cloud Sleuth implements a distributed tracing solution for Spring Cloud, borrowing heavily from Dapper, Zipkin and HTrace. For most users Sleuth should be invisible, and all your interactions with external systems should be instrumented automatically. You can capture data simply in logs, or by sending it to a remote collector service.</p></blockquote><p>简单来说，Spring Cloud Sleuth就是APM(Application Performance Monitor),全链路监控的APM的一部分，如果要完整的使用该组件需要自己定制化或者和开源的系统集成，例如:ZipKin。</p><blockquote><p>APM（Application Performance Monitor）这个领域最近异常火热。国外该领域知名公司包括New Relic，Appdynamics，Splunk。其中New Relic已经成功IPO，估值超过20亿美元。<br>国内外的个大互联网公司也都有类似大名鼎鼎的APM产品，例如淘宝鹰眼Eagle Eyes，点评的CAT，微博的Watchman，twitter的Zipkin。他们的产品虽未像专业APM公司的产品这样功能强大，但结合各自公司的业务特点，这些产品在支撑业务系统的高性能和稳定性方面，发挥了显著的作用。</p></blockquote><h2 id="Spring-Cloud-Sleuth和Zipkin"><a href="#Spring-Cloud-Sleuth和Zipkin" class="headerlink" title="Spring Cloud Sleuth和Zipkin"></a>Spring Cloud Sleuth和Zipkin</h2><p>对应Dpper的开源实现是Zipkin，支持多种语言包括JavaScript，Python，Java, Scala, Ruby, C#, Go等。其中Java由多种不同的库来支持。</p><h2 id="SpringCloudSleuth-借用了-Dapper-的术语"><a href="#SpringCloudSleuth-借用了-Dapper-的术语" class="headerlink" title="SpringCloudSleuth 借用了 Dapper 的术语"></a>SpringCloudSleuth 借用了 Dapper 的术语</h2><ul><li><strong>Span</strong><ul><li>基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址) span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。</li></ul></li><li><strong>Trace</strong><ul><li>一系列spans组成的一个树状结构，例如，如果你要在分布式中大数据存储中使用，Trace将会由一个请求执行调用链形成。</li></ul></li><li><strong>Annotation</strong><ul><li>用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束。<br><em>cs：Client Sent - 客户端发起一个请求，这个annotion描述了这个span的开始</em>sr：Server Received - 服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟<br><em>ss：Server Sent - 注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间</em>cr：Client Received - 表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间<br>将Span和Trace在一个系统中使用Zipkin注解的过程图形化，如下图所示:</li></ul></li></ul><p><img src="/images/spring-cloud-sleuth/1/trace-id.png" alt="Spring Cloud Sleuth使用ZipKin过程图形化"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言:做过软件开发的都知道，对&lt;code&gt;系统进行全链路的监控&lt;/code&gt;是非常有必要的。在单体应用中，传统的方式是软件开发者，通过自定义日志的level，日志文件的方式记录单体应用的&lt;code&gt;运行日志&lt;/code&gt;。从而排查线上系统出现运行过慢，出现故障，异常等问题，但是在微服务架构或分布式系统中，一个系统被拆分成了A、B、C、D、E等多个服务，而每个服务可能又有多个实例组成集群，采用上诉定位问题的方式就行不通了，你充其量就知道某个服务是应用的瓶颈，但中间发生了什么你完全不知道。而且问题的查询，因为有海量各种各样的日志等文件，导致&lt;code&gt;追溯定位问题&lt;/code&gt;等极其不方便。因此需要&lt;code&gt;全链路监控系统的收集，上报，对海量日志实时计算生成，监控告警，视图报表，帮助开发人员快速定位问题&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;服务追踪分析&quot;&gt;&lt;a href=&quot;#服务追踪分析&quot; class=&quot;headerlink&quot; title=&quot;服务追踪分析&quot;&gt;&lt;/a&gt;服务追踪分析&lt;/h2&gt;&lt;p&gt;一个由微服务构成的应用系统由N个服务实例组成，通过&lt;code&gt;REST请求&lt;/code&gt;或者&lt;code&gt;RPC协议&lt;/code&gt;等来通讯完成一个业务流程的调用。对于入口的一个调用可能需要有多个后台服务协同完成，链路上&lt;code&gt;任何一个调用超时&lt;/code&gt;或&lt;code&gt;出错&lt;/code&gt;都可能造成前端请求的失败。服务的调用链也会越来越长，并形成一个树形的调用链。如下图所示:&lt;br&gt;&lt;img src=&quot;/images/spring-cloud-sleuth/1/dyl.png&quot; alt=&quot;调用链&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Spring Cloud Sleuth" scheme="http://lvqingyan.com/categories/Spring-Cloud-Sleuth/"/>
    
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/tags/Spring-Cloud/"/>
    
      <category term="Spring Cloud Sleuth" scheme="http://lvqingyan.com/tags/Spring-Cloud-Sleuth/"/>
    
      <category term="全链路监控" scheme="http://lvqingyan.com/tags/%E5%85%A8%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/"/>
    
      <category term="微服务" scheme="http://lvqingyan.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>什么是Spring Cloud Config？</title>
    <link href="http://lvqingyan.com/sc-config/"/>
    <id>http://lvqingyan.com/sc-config/</id>
    <published>2016-10-19T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言:在单体应用中，我们一般的做法是把Property和Code放在一起，没有什么问题。但是在分布式系统中，由于存在多个服务实例，需要分别管理到每个具体的服务工程中的配置，上线需要准备check list 并逐个检查每个上线的服务是否正确。在系统上线之后修改某个配置，需要重启服务。这样开发就相当麻烦。因此我们急需需要把分布式系统中的配置信息抽取出来统一管理，服务获取系统信息时有一个覆盖顺序:property–&gt; Evn—-&gt;配置中心。这样修改环境变量或者修改配置中心的配置就能取到最新的配置信息。在唯品会 Venus Framework中我们专门设计了这个功能。Spring cloud出现之后，避免了大家重复造轮子。</p><h2 id="什么是-Spring-Cloud-Config"><a href="#什么是-Spring-Cloud-Config" class="headerlink" title="什么是 Spring Cloud Config ?"></a>什么是 Spring Cloud Config ?</h2><p>其官方文档中对自己的定义是如下，官网连接:<a href="http://cloud.spring.io/spring-cloud-config/" target="_blank">Spring Cloud Config</a>。</p><blockquote><p>Spring Cloud Config provides server and client-side support for externalized configuration in a distributed system.<br>With the Config Server you have a central place to manage external properties for applications across all environments.</p></blockquote><p>简单来说，Spring Cloud Config就是我们通常意义上的配置中心 - 把应用原本放在本地文件的配置抽取出来放在中心服务器，从而能够提供更好的管理、发布能力。<br><a id="more"></a></p><p>另外，Spring Cloud Config提供基于以下3个维度的配置管理：</p><ul><li><strong>应用</strong><ul><li>这个比较好理解，每个配置都是属于某一个应用的</li></ul></li><li><strong>环境</strong><ul><li>每个配置都是区分环境的，如dev, test, prod等</li></ul></li><li><strong>版本</strong><ul><li>这个可能是一般的配置中心所缺乏的，就是对同一份配置的不同版本管理，比如:可以通过Git进行版本控制。</li><li>Spring Cloud Config提供版本的支持，也就是说对于一个应用的不同部署实例，可以从服务端获取到不同版本的配置，这对于一些特殊场景如：灰度发布，A/B测试等提供了很好的支持。</li></ul></li></ul><h2 id="为什么会诞生Spring-Cloud-Config"><a href="#为什么会诞生Spring-Cloud-Config" class="headerlink" title="为什么会诞生Spring Cloud Config?"></a>为什么会诞生Spring Cloud Config?</h2><p>   配置中心目前现状:不管是开源的(百度的disconf)，还是一些公司自己闭源投入使用的产品已经不少了，那为什么还会诞生Spring Cloud Config呢？</p><p>在我看来，Spring Cloud Config在以下几方面还是有比较独特的优势，如下：</p><ul><li><strong>基于应用、环境、版本三个维度管理</strong><ul><li>这个在前面提过了，主要是有版本的支持</li></ul></li><li><strong>配置存储支持Git</strong><ul><li>这个就比较有特色了，后端基于Git存储，一方面程序员非常熟悉，另一方面在部署上会非常简单，而且借助于Git，天生就能非常好的支持版本</li><li>当然，它还支持其它的存储如本地文件、SVN等</li></ul></li><li><strong>和Spring无缝集成</strong><ul><li>它无缝支持Spring里面<code>Environment</code>和<code>PropertySource</code>的接口</li><li>所以对于已有的Spring应用程序的迁移成本非常低，在配置获取的接口上是完全一致的</li></ul></li></ul><h2 id="Spring-Cloud-Config-入门例子"><a href="#Spring-Cloud-Config-入门例子" class="headerlink" title="Spring Cloud Config 入门例子"></a>Spring Cloud Config 入门例子</h2><p>上述节点主要介绍了Spring cloud的相关理论，大家对Spring Cloud Config有了一个初步的认识，接下来例子让大家感受一下Spring cloud config的魅力。</p><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/images/2016-10-18/overview.png" alt="Overview"></p><p>上图简要描述了一个普通Spring Cloud Config应用的场景。其中主要有以下几个组件：</p><ul><li><em>Config Client</em><ul><li>Client很好理解，就是使用了Spring Cloud Config的应用</li><li>Spring Cloud Config提供了基于Spring的客户端，应用只要在代码中引入Spring Cloud Config Client的jar包即可工作</li></ul></li><li><em>Config Server</em><ul><li>Config Server是需要独立部署的一个web应用，它负责把git上的配置返回给客户端</li></ul></li><li><em>Remote Git Repository</em><ul><li>远程Git仓库，一般而言，我们会把配置放在一个远程仓库，通过现成的git客户端来管理配置</li></ul></li><li><em>Local Git Repostiory</em><ul><li>Config Server的本地Git仓库</li><li>Config Server接到来自客户端的配置获取请求后，会先把远程仓库的配置clone到本地的临时目录，然后从临时目录读取配置并返回</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言:在单体应用中，我们一般的做法是把Property和Code放在一起，没有什么问题。但是在分布式系统中，由于存在多个服务实例，需要分别管理到每个具体的服务工程中的配置，上线需要准备check list 并逐个检查每个上线的服务是否正确。在系统上线之后修改某个配置，需要重启服务。这样开发就相当麻烦。因此我们急需需要把分布式系统中的配置信息抽取出来统一管理，服务获取系统信息时有一个覆盖顺序:property–&amp;gt; Evn—-&amp;gt;配置中心。这样修改环境变量或者修改配置中心的配置就能取到最新的配置信息。在唯品会 Venus Framework中我们专门设计了这个功能。Spring cloud出现之后，避免了大家重复造轮子。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Spring-Cloud-Config&quot;&gt;&lt;a href=&quot;#什么是-Spring-Cloud-Config&quot; class=&quot;headerlink&quot; title=&quot;什么是 Spring Cloud Config ?&quot;&gt;&lt;/a&gt;什么是 Spring Cloud Config ?&lt;/h2&gt;&lt;p&gt;其官方文档中对自己的定义是如下，官网连接:&lt;a href=&quot;http://cloud.spring.io/spring-cloud-config/&quot; target=&quot;_blank&quot;&gt;Spring Cloud Config&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Cloud Config provides server and client-side support for externalized configuration in a distributed system.&lt;br&gt;With the Config Server you have a central place to manage external properties for applications across all environments.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，Spring Cloud Config就是我们通常意义上的配置中心 - 把应用原本放在本地文件的配置抽取出来放在中心服务器，从而能够提供更好的管理、发布能力。&lt;br&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Config" scheme="http://lvqingyan.com/tags/Spring-Cloud-Config/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud微服务框架主要子项目和RPC框架的对比</title>
    <link href="http://lvqingyan.com/sc-introduce/"/>
    <id>http://lvqingyan.com/sc-introduce/</id>
    <published>2016-10-18T02:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>　<strong>摘要</strong>:Spring Cloud是一个相对比较新的微服务框架，今年(2016)推出1.0的release版本，目前Github上更新速度很快. 虽然Spring Cloud时间最短, 但是相比Dubbo等RPC框架, Spring Cloud提供的全套的分布式系统解决方案。spring cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局琐，leader选举，分布式session，集群状态）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用．它们将在任何分布式环境中工作，包括开发人员自己的笔记本电脑，裸物理机的数据中心，和像Cloud Foundry云管理平台。在未来引领这微服务架构的发展，提供业界标准的一套微服务架构解决方案。<br><a id="more"></a></p><h2 id="什么是Spring-Cloud？"><a href="#什么是Spring-Cloud？" class="headerlink" title="什么是Spring Cloud？"></a>什么是Spring Cloud？</h2><p> 　Spring Cloud是一个相对比较新的微服务框架，今年(2016)才推出1.0的release版本. 虽然Spring Cloud时间最短, 但是相比Dubbo等RPC框架, Spring Cloud提供的全套的分布式系统解决方案。spring cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全居琐，leader选举，分布式session，集群状态）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用．它们将在任何分布式环境中工作，包括开发人员自己的笔记本电脑，裸物理机的数据中心，和像Cloud Foundry云管理平台。下面是官方对Spring Cloud定义和解释。<br>　<blockquote><p>  　Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry.　</p></blockquote></p><h2 id="Spring-Cloud主要项目"><a href="#Spring-Cloud主要项目" class="headerlink" title="Spring Cloud主要项目"></a>Spring Cloud主要项目</h2><p>  Spring Cloud 侧重于提供良好的开箱即用的功能，以便支持典型的开发场景和扩展支持。下面主要Spring Cloud项目在微服务框架中的主要子项目，具体的子项目源码分析，以及实现细节，将会在后面的文章中介绍。</p><ul><li>Spring Cloud Config—配置中心<br> Spring Cloud Config就是我们通常意义上的配置中心 - 把应用原本放在本地文件的配置抽取出来放在中心服务器，从而能够提供更好的管理、发布。<blockquote><p>在RPC服务治理框架中，一般都会开发一个配置中心和ZK配合使用，用于管理分布式应用中的配置信息。比如熔断的阀值，负载均衡的策略等。</p></blockquote></li><li>Spring Cloud Netflix–注册中心，服务发现，LB<br> Spring Cloud Netflix通过Eureka Server实现服务注册中心(包括服务注册，服务发现)，通过Ribbon实现软负载均衡(load balance,简称LB)<blockquote><p>在RPC框架中，例如：dubboX，HSF，OSP(唯品会的RPC框架)等RPC框架，都会通过ZK等实现服务注册，服务发现。当服务启动时，会将服务的IP地址，端口，服务命名，版本号等信息注册到ZK中，同时ZK Node会监听变化，接收最新的服务注册信息到client端或Proxy端。<br>至于LB，都会有自己的实现算法，熔断等都有自己的实现方式。</p></blockquote></li><li>Hystrix<br>　　熔断，包含在服务治理中。</li><li>Spring Cloud Sleuth<br> Spring Cloud Sleuth为Spring Cloud提供了分布式追踪方案。全链路监控系统。<blockquote><p>　　APM（Application Performance Monitor）这个领域最近异常火热。国外该领域知名公司包括New Relic，Appdynamics，Splunk。其中New Relic已经成功IPO，估值超过20亿美元。<br>　１．国内外的个大互联网公司也都有类似大名鼎鼎的APM产品，例如淘宝鹰眼Eagle Eyes，点评的CAT，微博的Watchman，twitter的Zipkin。他们的产品虽未像专业APM公司的产品这样功能强大，但结合各自公司的业务特点，这些产品在支撑业务系统的高性能和稳定性方面，发挥了显著的作用。<br>　２．众所周知，中大型互联网公司的后台业务系统由众多分布式组件构成，这些组件由web类型组件，RPC服务化类型组件，缓存组件，消息组件和数据库组件。一个通过浏览器或移动客户端的前端请求到达后台系统后，会经过很多个业务组件和系统组件，并且留下足迹和相关日志信息。但这些分散在每个业务组件和主机下的日志信息不利于问题排查和定位问题的Root Cause。这种监控场景正是应用性能监控系统的用武之地，应用性能监控系统收集，汇总并分析日志信息达到有效监控系统性能和问题的效果．<br>　３．在唯品会体系中，Mercury提供的主要功能包括：<br>　　定位慢调用：包括慢Web服务（包括Restful Web服务），慢OSP服务，慢SQL<br>　　定位错误：包括4XX，5XX，OSP Error<br>　　定位异常：包括Error Exception，Fatal Exception<br>　　展现依赖和拓扑：域拓扑，服务拓扑，trace拓扑<br>　　Trace调用链：将端到端的调用，以及附加在这次调用的上下文信息，异常日志信息，每一个调用点的耗时都呈现给用户<br>　　应用告警：根据运维设定的告警规则，扫描指标数据，如违反告警规则，则将告警信息上报到唯品会中央告警平台</p></blockquote></li></ul><h2 id="dubbo与Spring-Cloud的比较"><a href="#dubbo与Spring-Cloud的比较" class="headerlink" title="dubbo与Spring Cloud的比较"></a>dubbo与Spring Cloud的比较</h2><p>   　1.dubbo出自于阿里，Spring cloud出自于Spring社区,基于Spring boot提供一套完整的微服务解决方案。dubbo或者dubbox是RPC框<br>　架，功能是Spring Cloud功能的一个子集。<br>   　2.dubbo是RPC服务治理框架，和Spring Cloud一样具备服务注册、发现、路由、负载均衡等能力。但是没有配置中心，完整的好用全链路监<br>　控，需要采用开源的解决方案定制或者自研。Spring cloud的配置中心，全链路监控等组件。从目前来看，Spring Cloud国内中小型企业用的比较多，大型企业可能需要对其需要的组件进行定制化处理。<br>   　3.Spring cloud基于注解的服务发现，服务治理等功能具有代码侵入性，dubbo没有代码侵入性，业务开发人员不需要通过注解的方式去关注<br>框架级别的处理。从中间件或者做基础架构的角度来看，其实服务治理等功能对普通的业务程序员应该是透明的，业务程序员不需要关注服务治理框架的使用，专注于业务代码即可。<br>   因此大型企业可能需要对Spring cloud进行定制化处理。更多比较信息，可以参考下面的连接。</p><p>   <a href="http://blog.didispace.com/microservice-framework/" title="Spring Cloud与Dubbo的对比" target="_blank" rel="external">http://blog.didispace.com/microservice-framework/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　&lt;strong&gt;摘要&lt;/strong&gt;:Spring Cloud是一个相对比较新的微服务框架，今年(2016)推出1.0的release版本，目前Github上更新速度很快. 虽然Spring Cloud时间最短, 但是相比Dubbo等RPC框架, Spring Cloud提供的全套的分布式系统解决方案。spring cloud 为开发者提供了在分布式系统（配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全局琐，leader选举，分布式session，集群状态）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用．它们将在任何分布式环境中工作，包括开发人员自己的笔记本电脑，裸物理机的数据中心，和像Cloud Foundry云管理平台。在未来引领这微服务架构的发展，提供业界标准的一套微服务架构解决方案。&lt;br&gt;
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Jdk的万能配置</title>
    <link href="http://lvqingyan.com/jdk-install/"/>
    <id>http://lvqingyan.com/jdk-install/</id>
    <published>2016-10-15T13:00:00.000Z</published>
    <updated>2018-06-02T03:38:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>　java是通过java虚拟机来解释运行的,也就是通过java命令; javac编译生成的.class文件就是虚拟机要执行的代码, 称之为字节码(bytecode),虚拟机通过classloader来装载这些字节码,也就是通常意义上的类.这里就有一个问题,classloader从哪里知道java本身的类库及用户自己的类在什么地方呢?或者有着缺省值(当前路径).或者要有一个用户指定的变量来表明, 这个变量就是类路径(classpath),或者在运行的时候传参数给虚拟机.<br>通过这段文字，你就知道，为什么javac编译通过了，但是java命令却出错(类定义没找到)的原因了。<br>就是环境变量classpath(类路径)没有设置正确，使得JAVA虚拟机的classloader无法找到类来执行目标程序<br><a id="more"></a></p><h2 id="快速配置"><a href="#快速配置" class="headerlink" title="快速配置"></a>快速配置</h2><h3 id="1-新建系统变量JAVA-HOME变量-JAVA-HOME指明JDK安装路径。"><a href="#1-新建系统变量JAVA-HOME变量-JAVA-HOME指明JDK安装路径。" class="headerlink" title="1.新建系统变量JAVA_HOME变量(JAVA_HOME指明JDK安装路径。)"></a>1.新建系统变量JAVA_HOME变量(JAVA_HOME指明JDK安装路径。)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">E:\development\Java\Java8\jdk1.8.0_73</div></pre></td></tr></table></figure><p>　</p><h3 id="2-在系统变量中的path中添加-Path使得系统可以在任何路径下识别java命令。"><a href="#2-在系统变量中的path中添加-Path使得系统可以在任何路径下识别java命令。" class="headerlink" title="2.在系统变量中的path中添加(Path使得系统可以在任何路径下识别java命令。)"></a>2.在系统变量中的path中添加(Path使得系统可以在任何路径下识别java命令。)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</div></pre></td></tr></table></figure><p>　</p><h3 id="3、新建系统变量CLASSPATH-CLASSPATH为java加载类-class-or-lib-路径，只有类在classpath中，java命令才能识别"><a href="#3、新建系统变量CLASSPATH-CLASSPATH为java加载类-class-or-lib-路径，只有类在classpath中，java命令才能识别" class="headerlink" title="3、新建系统变量CLASSPATH(CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别.)"></a>3、新建系统变量CLASSPATH(CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别.)</h3><p>　设定值为：.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar<br>　注意 一定要加“.”，“.”代表当前目录，即可到处建立.java文件，java class都能找到并编译运行用户的.java文件。</p><h3 id="4-进入dos窗口运行“java-–version”-如果显示下面内容则成功。"><a href="#4-进入dos窗口运行“java-–version”-如果显示下面内容则成功。" class="headerlink" title="4.进入dos窗口运行“java –version” 如果显示下面内容则成功。"></a>4.进入dos窗口运行“java –version” 如果显示下面内容则成功。</h3><p><img src="/images/2016-10-18/jdk-config.png" alt="Java -version"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　java是通过java虚拟机来解释运行的,也就是通过java命令; javac编译生成的.class文件就是虚拟机要执行的代码, 称之为字节码(bytecode),虚拟机通过classloader来装载这些字节码,也就是通常意义上的类.这里就有一个问题,classloader从哪里知道java本身的类库及用户自己的类在什么地方呢?或者有着缺省值(当前路径).或者要有一个用户指定的变量来表明, 这个变量就是类路径(classpath),或者在运行的时候传参数给虚拟机.&lt;br&gt;通过这段文字，你就知道，为什么javac编译通过了，但是java命令却出错(类定义没找到)的原因了。&lt;br&gt;就是环境变量classpath(类路径)没有设置正确，使得JAVA虚拟机的classloader无法找到类来执行目标程序&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://lvqingyan.com/categories/java/"/>
    
    
      <category term="Jdk" scheme="http://lvqingyan.com/tags/Jdk/"/>
    
      <category term="Java" scheme="http://lvqingyan.com/tags/Java/"/>
    
  </entry>
  
</feed>
