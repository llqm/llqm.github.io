<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>诺诺清蔓</title>
  
  <subtitle>简单，美好，奋发</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lvqingyan.com/"/>
  <updated>2018-05-15T16:27:47.000Z</updated>
  <id>http://lvqingyan.com/</id>
  
  <author>
    <name>吕清燕</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公益Eureka Server与定制方法</title>
    <link href="http://lvqingyan.com/sc-diy-eureka/"/>
    <id>http://lvqingyan.com/sc-diy-eureka/</id>
    <published>2018-05-14T06:00:00.000Z</published>
    <updated>2018-05-15T16:27:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>: 本文主要简单介绍如何定制一个eureka server，并直接指出最优的定制方式。</p><a id="more"></a><h2 id="1-Spring-Cloud中国公益Eureka-Server"><a href="#1-Spring-Cloud中国公益Eureka-Server" class="headerlink" title="1. Spring Cloud中国公益Eureka Server"></a>1. Spring Cloud中国公益Eureka Server</h2><p>Eureka Server为作为Spring Cloud开发过程中常用的注册中心组件，作为基础设施组件，开发学习过程中，经常需要自己创建Eureka Server应用和重启。为了帮助开发者快速学习入门。Spring Cloud中国社区特搭建一个公益注册中心，仅作为帮助Spring Cloud的开发者进行学习和调试。为了更好服务大家，请勿对本注册中心进行压测。定制的Eureka Server注册中心UI如下所示。</p><p><img src="http://springcloud-new.oss-cn-shenzhen.aliyuncs.com/1966ed6f184d06c2ab793dcaf2c41c8b.jpeg?Expires=1841654009&amp;OSSAccessKeyId=LTAI57F52hRuWq3h&amp;Signature=OeNSoXly3WYi9wfNq3guMPq%2Bt48%3D" alt=""></p><h3 id="1-1-访问地址"><a href="#1-1-访问地址" class="headerlink" title="1.1 访问地址"></a>1.1 访问地址</h3><p> <a href="http://eureka.springcloud.cn" title="http://eureka.springcloud.cn" target="_blank" rel="external">http://eureka.springcloud.cn</a></p><h2 id="2-定制Eureka-Serrver的UI"><a href="#2-定制Eureka-Serrver的UI" class="headerlink" title="2.定制Eureka Serrver的UI"></a>2.定制Eureka Serrver的UI</h2><h3 id="2-1-为什么要定制Eureka-Server"><a href="#2-1-为什么要定制Eureka-Server" class="headerlink" title="2.1 为什么要定制Eureka Server"></a>2.1 为什么要定制Eureka Server</h3><p> 原因两点:</p><ul><li>1.觉得默认的UI比较丑  </li><li>2.Eureka Server想客制化一下</li></ul><blockquote><p>至于Spring Cloud Eureka的UI客制化成什么样子由你而定！</p></blockquote><h2 id="3-两种方法定制Eureka-Server"><a href="#3-两种方法定制Eureka-Server" class="headerlink" title="3. 两种方法定制Eureka Server"></a>3. 两种方法定制Eureka Server</h2><h3 id="3-1-直接修改eureka-server的源代码"><a href="#3-1-直接修改eureka-server的源代码" class="headerlink" title="3.1 直接修改eureka server的源代码"></a>3.1 直接修改eureka server的源代码</h3><p>   直接修改eureka server的源代码，该方法是最纯的方式，而且每次有一个Eureka Server的版本都需要去修改。</p><h3 id="3-2-只修改Eureka-Server的UI"><a href="#3-2-只修改Eureka-Server的UI" class="headerlink" title="3.2 只修改Eureka Server的UI"></a>3.2 只修改Eureka Server的UI</h3><p>只需要修改对应的html+css+文案即可，完全不用去修改Eureka Server的源码,强烈推荐。</p><blockquote><p>源码参考地址:<a href="https://github.com/SpringCloud/spring-cloud-eureka" target="_blank" rel="external">https://github.com/SpringCloud/spring-cloud-eureka</a></p></blockquote><h3 id="3-3-为什么我定制自己的UI加进去"><a href="#3-3-为什么我定制自己的UI加进去" class="headerlink" title="3.3 为什么我定制自己的UI加进去"></a>3.3 为什么我定制自己的UI加进去</h3><p> 为什么我定制自己的UI加进去，就可以直接Run，那源码代码中的UI是不是被覆盖了？<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.springcloud.eureka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-server-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p><blockquote><p>如上maven配置所示，官方的spring-cloud-starter-netflix-eureka-server依赖信息配置在下面，由maven的依赖加载顺序决定，定制的UI优先加载显示。</p></blockquote><h2 id="4-如何在项目中使用DIY的Eureka-Server"><a href="#4-如何在项目中使用DIY的Eureka-Server" class="headerlink" title="4. 如何在项目中使用DIY的Eureka Server"></a>4. 如何在项目中使用DIY的Eureka Server</h2><p>只需要配置maven依赖即可:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.springcloud.eureka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-server-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;: 本文主要简单介绍如何定制一个eureka server，并直接指出最优的定制方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Eureka Server" scheme="http://lvqingyan.com/categories/Eureka-Server/"/>
    
    
      <category term="Eureka Server" scheme="http://lvqingyan.com/tags/Eureka-Server/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Gateway翻译</title>
    <link href="http://lvqingyan.com/sc-gw-fy/"/>
    <id>http://lvqingyan.com/sc-gw-fy/</id>
    <published>2017-11-09T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>: 本文主要对Spring Cloud Gateway v2.0.0.M3<a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/v2.0.0.M3/docs/src/main/asciidoc/spring-cloud-gateway.adoc" target="_blank" rel="external">原文地址</a> 版本文档进行翻译,持续更新至稳定版本，然后公布。</p><a id="more"></a><h2 id="spring-cloud-gateway"><a href="#spring-cloud-gateway" class="headerlink" title="spring-cloud-gateway"></a>spring-cloud-gateway</h2><p>This project provides an API Gateway built on top of the Spring Ecosystem, including: Spring 5, Spring Boot 2 and Project Reactor. Spring Cloud Gateway aims to provide a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as: security, monitoring/metrics, and resiliency.</p><blockquote><p>这个项目提供了一个构建在Spring生态系统之上的API网关，包括：Spring 5，Spring Boot 2和Project Reactor。 Spring Cloud Gateway旨在提供一种简单而有效的API路由方式，并为其提供横切关注点，例如：安全，监控/指标，和弹性。</p></blockquote><h2 id="How-to-Include-Spring-Cloud-Gateway"><a href="#How-to-Include-Spring-Cloud-Gateway" class="headerlink" title="How to Include Spring Cloud Gateway"></a>How to Include Spring Cloud Gateway</h2><p>To include Spring Cloud Gateway in your project use the starter with group org.springframework.cloud and artifact id spring-cloud-starter-gateway. See the Spring Cloud Project page for details on setting up your build system with the current Spring Cloud Release Train.</p><blockquote><p>要在项目中包含Spring Cloud Gateway，请使用组org.springframework.cloud和工件id spring-cloud-starter-gateway。请参阅Spring Cloud Project页面，以获取有关使用当前Spring Cloud Release Train设置构建系统的详细信息。</p></blockquote><p>If you include the starter, but, for some reason, you do not want the gateway to be enabled, set spring.cloud.gateway.enabled=false.</p><blockquote><p>如果你项目中包含了Spring Cloud Gateway这个starter，但是由于某种原因，你不想让它在你的项目中生效，你可以设置spring.cloud.gateway.enabled=false</p></blockquote><h2 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h2><ul><li>Route: Route the basic building block of the gateway. It is defined by an ID, a destination URI, a collection of predicates and a collection of filters. A route is matched if aggregate predicate is true.</li></ul><blockquote><p>路由：路由是网关的基本构建模块。它由一个ID，一个目标URI，一组断言和一个过滤器的集合定义。如果聚合谓词为真，则路由匹配</p></blockquote><ul><li>Predicate: This is a Java 8 Function Predicate. The input type is a Spring Framework ServerWebExchange. This allows developers to match on anything from the HTTP request, such as headers or parameters.</li></ul><blockquote><p>谓词：这是一个Java 8函数谓词。输入类型是一个Spring框架的ServerWebExchange。这允许开发人员匹配来自HTTP请求的任何内容，例如标题或参数</p></blockquote><ul><li>Filter: These are instances Spring Framework GatewayFilter constructed in with a specific factory. Here, requests and responses can be modified before or after sending the downstream request.</li></ul><blockquote><p> 过滤器：这是实例Spring Framework GatewayFilter与特定工厂构建的实例。这里，可以在发送下游请求之前或之后修改请求和响应</p></blockquote><h2 id="How-It-Works"><a href="#How-It-Works" class="headerlink" title="How It Works"></a>How It Works</h2><p>Clients make requests to Spring Cloud Gateway. If the Gateway Handler Mapping determines that a request matches a Route, it is sent to the Gateway Web Handler. This handler runs sends the request through a filter chain that is specific to the request. The reason the filters are divided by the dotted line, is that filters may execute logic before the proxy request is sent or after. All “pre” filter logic is executed, then the proxy request is made. After the proxy request is made, the “post” filter logic is executed.</p><h2 id="Route-Predicate-Factories"><a href="#Route-Predicate-Factories" class="headerlink" title="Route Predicate Factories"></a>Route Predicate Factories</h2><p>Spring Cloud Gateway matches routes as part of the Spring WebFlux HandlerMapping infrastructure. Spring Cloud Gateway includes many built-in Route Predicate Factories. All of these predicates match on different attributes of the HTTP request. Multiple Route Predicate Factories can be combined and are combined via logical and.</p><h2 id="After-Route-Predicate-Factory"><a href="#After-Route-Predicate-Factory" class="headerlink" title="After Route Predicate Factory"></a>After Route Predicate Factory</h2><p>The After Route Predicate Factory takes one parameter, a datetime. This predicate matches requests that happen after the current datetime.</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">after_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">After=2017-01-20T17:42:47.789-07:00[America/Denver]</span></div></pre></td></tr></table></figure><p>This route matches any request after Jan 20, 2017 17:42 Mountain Time (Denver).</p><h2 id="Before-Route-Predicate-Factory"><a href="#Before-Route-Predicate-Factory" class="headerlink" title="Before Route Predicate Factory"></a>Before Route Predicate Factory</h2><p>The Before Route Predicate Factory takes one parameter, a datetime. This predicate matches requests that happen before the current datetime.</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">before_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Before=2017-01-20T17:42:47.789-07:00[America/Denver]</span></div></pre></td></tr></table></figure><p>This route matches any request before Jan 20, 2017 17:42 Mountain Time (Denver).</p><h2 id="Between-Route-Predicate-Factory"><a href="#Between-Route-Predicate-Factory" class="headerlink" title="Between Route Predicate Factory"></a>Between Route Predicate Factory</h2><p>The Between Route Predicate Factory takes two parameters, datetime1 and datetime2. This predicate matches requests that happen after datetime1 and before datetime2. The datetime2 parameter must be after datetime1.</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">between_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Betweeen=2017-01-20T17:42:47.789-07:00[America/Denver],</span> <span class="number">2017</span><span class="bullet">-01</span><span class="bullet">-21</span><span class="attr">T17:42:47.789-07:00[America/Denver]</span></div></pre></td></tr></table></figure><p>This route matches any request after Jan 20, 2017 17:42 Mountain Time (Denver) and before Jan 21, 2017 17:42 Mountain Time (Denver). This could be useful for maintenance windows.</p><h2 id="Cookie-Route-Predicate-Factory"><a href="#Cookie-Route-Predicate-Factory" class="headerlink" title="Cookie Route Predicate Factory"></a>Cookie Route Predicate Factory</h2><p>The Cookie Route Predicate Factory takes two parameters, the cookie name and a regular expression. This predicate matches cookies that have the given name and the value matches the regular expression.</p><p>application.yml</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: cookie_route</div><div class="line">        uri: http://example.org</div><div class="line">        predicates:</div><div class="line">        - Cookie=chocolate, ch.p</div></pre></td></tr></table></figure><p>This route matches the request has a cookie named chocolate who’s value matches the ch.p regular expression.</p><h2 id="Header-Route-Predicate-Factory"><a href="#Header-Route-Predicate-Factory" class="headerlink" title="Header Route Predicate Factory"></a>Header Route Predicate Factory</h2><p>The Header Route Predicate Factory takes two parameters, the header name and a regular expression. This predicate matches with a header that has the given name and the value matches the regular expression.</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">header_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></div></pre></td></tr></table></figure><p>This route matches if the request has a header named X-Request-Id whos value matches the \d+ regular expression (has a value of one or more digits).</p><h2 id="Host-Route-Predicate-Factory"><a href="#Host-Route-Predicate-Factory" class="headerlink" title="Host Route Predicate Factory"></a>Host Route Predicate Factory</h2><p>The Host Route Predicate Factory takes one parameter: the host name pattern. The pattern is an Ant style pattern with . as the separator. This predicates matches the Host header that matches the pattern.</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">host_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Host=**.somehost.org</span></div></pre></td></tr></table></figure><p>This route would match if the request has a Host header has the value www.somehost.org or beta.somehost.org.</p><h2 id="Method-Route-Predicate-Factory"><a href="#Method-Route-Predicate-Factory" class="headerlink" title="Method Route Predicate Factory"></a>Method Route Predicate Factory</h2><p>The Method Route Predicate Factory takes one parameter: the HTTP method to match.</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">method_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Method=GET</span></div></pre></td></tr></table></figure><p>This route would match if the request method was a GET.</p><h2 id="Path-Route-Predicate-Factory"><a href="#Path-Route-Predicate-Factory" class="headerlink" title="Path Route Predicate Factory"></a>Path Route Predicate Factory</h2><p>The Path Route Predicate Factory takes one parameter: a Spring PathMatcher pattern.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">host_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Path=/foo/&#123;segment&#125;</span></div></pre></td></tr></table></figure><p>This route would match if the request path was, for example: /foo/1 or /foo/bar.</p><p>This predicate extracts the URI template variables (like segment defined in the example above) as a map of names and values and places it in the ServerWebExchange.getAttributes() with a key defined in PathRoutePredicate.URL_PREDICATE_VARS_ATTR. Those values are then available for use by<a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/v2.0.0.M3/docs/src/main/asciidoc/spring-cloud-gateway.adoc#gateway-route-filters" target="_blank" rel="external">GatewayFilter Factories</a></p><h2 id="Query-Route-Predicate-Factory"><a href="#Query-Route-Predicate-Factory" class="headerlink" title="Query Route Predicate Factory"></a>Query Route Predicate Factory</h2><p>The Query Route Predicate Factory takes two parameters: a required param and an optional regexp.</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">query_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Query=baz</span></div></pre></td></tr></table></figure><p>This route would match if the request contained a baz query parameter.</p><p>application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  cloud:</span></div><div class="line"><span class="attr">    gateway:</span></div><div class="line"><span class="attr">      routes:</span></div><div class="line">      <span class="comment"># =====================================</span></div><div class="line"><span class="attr">      - id:</span> <span class="string">query_route</span></div><div class="line"><span class="attr">        uri:</span> <span class="attr">http://example.org</span></div><div class="line"><span class="attr">        predicates:</span></div><div class="line"><span class="bullet">        -</span> <span class="string">Query=foo,</span> <span class="string">ba.</span></div></pre></td></tr></table></figure><p>This route would match if the request contained a foo query parameter whose value matched the ba. regexp, so bar and baz would match.</p><h2 id="RemoteAddr-Route-Predicate-Factory（远程地址路由Predicate工厂）"><a href="#RemoteAddr-Route-Predicate-Factory（远程地址路由Predicate工厂）" class="headerlink" title="RemoteAddr Route Predicate Factory（远程地址路由Predicate工厂）"></a>RemoteAddr Route Predicate Factory（远程地址路由Predicate工厂）</h2><p> 远程地址路由Predicate工厂需要维护一个CIDR-notation的字符串列表，该列表的大小大于1，比如192.168.0.1/16 (192.168.0.1一个ip地址，16 是一个子网掩码。</p><p>配置文件application.yml如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: remoteaddr_route</div><div class="line">        uri: http://example.org</div><div class="line">        predicates:</div><div class="line">        - RemoteAddr=192.168.1.1/24</div></pre></td></tr></table></figure><p>这个路由将会匹配比如像192.168.1.10这样的远程请求。</p><h2 id="GatewayFilter-Factories（网关过滤器工厂链）"><a href="#GatewayFilter-Factories（网关过滤器工厂链）" class="headerlink" title="GatewayFilter Factories（网关过滤器工厂链）"></a>GatewayFilter Factories（网关过滤器工厂链）</h2><p>路由过滤器能够以某种方式允许修改进入的Http请求或输出的对外的Http响应。<br>路由过滤器的作用域是一个特定的路由。 Spring Cloud Gateway包含许多内置的GatewayFilter工厂。</p><h3 id="AddRequestHeader-GatewayFilter-Factory（添加请求头的过滤器工厂）"><a href="#AddRequestHeader-GatewayFilter-Factory（添加请求头的过滤器工厂）" class="headerlink" title="AddRequestHeader GatewayFilter Factory（添加请求头的过滤器工厂）"></a>AddRequestHeader GatewayFilter Factory（添加请求头的过滤器工厂）</h3><p>添加请求头的过滤器工厂可以在请求头中添加一对键值对参数。</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: add_request_header_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - AddRequestHeader=X-Request-Foo, Bar</div></pre></td></tr></table></figure><p>以上的配置会将X-Request-Foo：Bar头添加到所有匹配请求的下游请求头。</p><h3 id="AddRequestParameter-GatewayFilter-Factory（添加请求参数的过滤器工厂）"><a href="#AddRequestParameter-GatewayFilter-Factory（添加请求参数的过滤器工厂）" class="headerlink" title="AddRequestParameter GatewayFilter Factory（添加请求参数的过滤器工厂）"></a>AddRequestParameter GatewayFilter Factory（添加请求参数的过滤器工厂）</h3><p>添加请求参数的过滤器工厂可以在请求中添加一对请求参数的键值对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: add_request_parameter_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - AddRequestParameter=foo, bar</div></pre></td></tr></table></figure><p>以上的配置会将foo：bar参数添加到所有匹配请求的下游请求中。</p><h3 id="AddResponseHeader-GatewayFilter-Factory（添加响应头的过滤器工厂）"><a href="#AddResponseHeader-GatewayFilter-Factory（添加响应头的过滤器工厂）" class="headerlink" title="AddResponseHeader GatewayFilter Factory（添加响应头的过滤器工厂）"></a>AddResponseHeader GatewayFilter Factory（添加响应头的过滤器工厂）</h3><p>添加响应头的过滤器工厂可以在响应头中添加键值对。</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: add_request_header_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - AddResponseHeader=X-Response-Foo, Bar</div></pre></td></tr></table></figure><p>以上的配置会将X-Response-Foo, Bar头添加到所有匹配请求的下游请求的相响应头中。</p><h3 id="Hystrix-GatewayFilter-Factory（熔断过滤器工厂）"><a href="#Hystrix-GatewayFilter-Factory（熔断过滤器工厂）" class="headerlink" title="Hystrix GatewayFilter Factory（熔断过滤器工厂）"></a>Hystrix GatewayFilter Factory（熔断过滤器工厂）</h3><p>Hystrix GatewayFilter Factory采用单个名称的参数，即HystrixCommand的名称。 （未来版本中可能会添加更多选项）。</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: hytstrix_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - Hystrix=myCommandName</div></pre></td></tr></table></figure><p>以上的配置将使用命令名称myCommandName将剩余的过滤器包装在HystrixCommand中。</p><h3 id="PrefixPath-GatewayFilter-Factory（前缀路径过滤器工厂）"><a href="#PrefixPath-GatewayFilter-Factory（前缀路径过滤器工厂）" class="headerlink" title="PrefixPath GatewayFilter Factory（前缀路径过滤器工厂）"></a>PrefixPath GatewayFilter Factory（前缀路径过滤器工厂）</h3><p>前缀路径过滤器工厂使用的是一个简单的prefix参数。</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: prefixpath_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - PrefixPath=/mypath</div></pre></td></tr></table></figure><p>这将前缀/mypath到所有匹配的请求的路径。 所以/hello的请求将被发送到/mypath/hello。</p><h3 id="RequestRateLimiter-GatewayFilter-Factory（请求限流过滤器工厂）"><a href="#RequestRateLimiter-GatewayFilter-Factory（请求限流过滤器工厂）" class="headerlink" title="RequestRateLimiter GatewayFilter Factory（请求限流过滤器工厂）"></a>RequestRateLimiter GatewayFilter Factory（请求限流过滤器工厂）</h3><p>请求限流过滤器工厂需要三个参数：replenishRate, burstCapacity 和keyResolverName.</p><ul><li><p>replenishRate 允许用户每秒处理多少个请求。</p></li><li><p>burstCapacity TODO：文件的爆发能力</p></li><li><p>keyResolver是一个实现KeyResolver接口的bean。在配置中，使用SpEL通过名称引用bean。＃{@myKeyResolver}是引用名为myKeyResolver的bean的SpEL表达式。</p></li></ul><p>KeyResolver.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface KeyResolver &#123;</div><div class="line">Mono&lt;String&gt; resolve(ServerWebExchange exchange);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>KeyResolver接口允许可插入策略派生出限制请求的密钥。 在未来的里程碑版本中，将会有一些KeyResolver具体实现类。</p><p>Redis的实现基于Stripe工作的。 它需要使用spring-boot-starter-data-redis-reactive 的起步依赖。</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: requestratelimiter_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - RequestRateLimiter=10, 20, #&#123;@userKeyResolver&#125;</div></pre></td></tr></table></figure><p>Config.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">KeyResolver userKeyResolver() &#123;</div><div class="line">    return exchange -&gt; Mono.just(exchange.getRequest().getQueryParams().getFirst(&quot;user&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上的配置定义了每个用户10个请求速率限制。 KeyResolver是一个简单的获取用户请求参数（注意：这不建议用于生产）。</p><h3 id="RedirectTo-GatewayFilter-Factory（重定向过滤器工厂）"><a href="#RedirectTo-GatewayFilter-Factory（重定向过滤器工厂）" class="headerlink" title="RedirectTo GatewayFilter Factory（重定向过滤器工厂）"></a>RedirectTo GatewayFilter Factory（重定向过滤器工厂）</h3><p>重定向过滤器工厂接受一个状态和一个url参数。 该状态是一个300系列重定向http代码，如301.该网址应该是一个有效的网址。 并将它们组合成一个Location的header.</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: prefixpath_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - RedirectTo=302, http://acme.org</div></pre></td></tr></table></figure><p>以上的配置将使用Location：http：//acme.org标头发送状态302以执行重定向。</p><h3 id="RemoveNonProxyHeaders-GatewayFilter-Factory（去掉非代理头的过滤器工厂）"><a href="#RemoveNonProxyHeaders-GatewayFilter-Factory（去掉非代理头的过滤器工厂）" class="headerlink" title="RemoveNonProxyHeaders GatewayFilter Factory（去掉非代理头的过滤器工厂）"></a>RemoveNonProxyHeaders GatewayFilter Factory（去掉非代理头的过滤器工厂）</h3><p>去掉非代理头的过滤器工厂从转发的请求中删除请求头。 被删除的请求头的默认列表来自IETF。</p><p>默认删除请求头如下：</p><ul><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>TE</li><li>Trailer</li><li>Transfer-Encoding</li><li>Upgrade</li></ul><p>要改变这一点，请将spring.cloud.gateway.filter.remove-non-proxy-headers.headers属性设置为要删除的标题名称列表。</p><h3 id="RemoveRequestHeader-GatewayFilter-Factory（去掉请求头的过滤器工厂）"><a href="#RemoveRequestHeader-GatewayFilter-Factory（去掉请求头的过滤器工厂）" class="headerlink" title="RemoveRequestHeader GatewayFilter Factory（去掉请求头的过滤器工厂）"></a>RemoveRequestHeader GatewayFilter Factory（去掉请求头的过滤器工厂）</h3><p>去掉请求头的过滤器工厂需要一个名称的参数，这个名称参数是需要去掉的请求头名。</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: removerequestheader_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - RemoveRequestHeader=X-Request-Foo</div></pre></td></tr></table></figure><p>以上的配置将在下游发送之前删除X-Request-Foo头。</p><h3 id="RemoveResponseHeader-GatewayFilter-Factory-（去掉响应头的过滤器工厂）"><a href="#RemoveResponseHeader-GatewayFilter-Factory-（去掉响应头的过滤器工厂）" class="headerlink" title="RemoveResponseHeader GatewayFilter Factory （去掉响应头的过滤器工厂）"></a>RemoveResponseHeader GatewayFilter Factory （去掉响应头的过滤器工厂）</h3><p>去掉响应头的过滤器工厂需要一个名称的参数，这个名称参数是需要去掉的响应头名。</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: removeresponseheader_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - RemoveResponseHeader=X-Response-Foo</div></pre></td></tr></table></figure><p>这将在返回到网关客户端之前从响应中删除X-Response-Foo头。</p><h3 id="RewritePath-GatewayFilter-Factory（重些url路径的过滤器工厂）"><a href="#RewritePath-GatewayFilter-Factory（重些url路径的过滤器工厂）" class="headerlink" title="RewritePath GatewayFilter Factory（重些url路径的过滤器工厂）"></a>RewritePath GatewayFilter Factory（重些url路径的过滤器工厂）</h3><p>重些url网关过滤器工厂采用路径正则表达式参数和一个替换参数。 使用的是Java正则表达式来灵活地重写请求路径。</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: rewritepath_route</div><div class="line">        uri: http://example.org</div><div class="line">        - Path=/foo/**</div><div class="line">        filters:</div><div class="line">        - RewritePath=/foo/(?&lt;segment&gt;.*), /$\&#123;segment&#125;</div></pre></td></tr></table></figure><p>以上的配置，对于/foo/bar的请求路径，将在进行下游请求之前将路径设置为/ bar。 注意由于YAML规范，”$\” 被 “$” 替换。</p><h3 id="SecureHeaders-GatewayFilter-Factory（安全头过滤工厂）"><a href="#SecureHeaders-GatewayFilter-Factory（安全头过滤工厂）" class="headerlink" title="SecureHeaders GatewayFilter Factory（安全头过滤工厂）"></a>SecureHeaders GatewayFilter Factory（安全头过滤工厂）</h3><p>安全头过滤工厂给响应添加了一些列的安全头，这些安全头在这篇文章有详细的介绍，文章地址：<a href="https://blog.appcanary.com/2017/http-security-headers.html" target="_blank" rel="external">https://blog.appcanary.com/2017/http-security-headers.html</a></p><p>以下的安全头被采纳，并且有默认值：</p><ul><li>X-Xss-Protection:1; mode=block</li><li>Strict-Transport-Security:max-age=631138519</li><li>X-Frame-Options:DENY</li><li>X-Content-Type-Options:nosniff</li><li>Referrer-Policy:no-referrer</li><li>Content-Security-Policy:default-src ‘self’ https:; font-src ‘self’ https: data:; img-src ‘self’ https: data:; object-src ‘none’; script-src https:; style-src ‘self’ https: ‘unsafe-inline’</li><li>X-Download-Options:noopen</li><li>X-Permitted-Cross-Domain-Policies:none</li></ul><p>如果要更改默认值，在spring.cloud.gateway.filter.secure-headers命名空间中设置适当的属性：</p><p>要更改的属性：</p><ul><li>xss-protection-header</li><li>strict-transport-security</li><li>frame-options</li><li>content-type-options</li><li>referrer-policy</li><li>content-security-policy</li><li>download-options</li><li>permitted-cross-domain-policies</li></ul><h3 id="SetPath-GatewayFilter-Factory（设置路径过滤器工厂）"><a href="#SetPath-GatewayFilter-Factory（设置路径过滤器工厂）" class="headerlink" title="SetPath GatewayFilter Factory（设置路径过滤器工厂）"></a>SetPath GatewayFilter Factory（设置路径过滤器工厂）</h3><p>设置路径过滤器工厂需要路径模板参数。 它提供了一种简单的方法来通过允许路径的模板化段来操纵请求路径。 使用了Spring框架的uri模板。 允许多个匹配段。</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: setpath_route</div><div class="line">        uri: http://example.org</div><div class="line">        predicates:</div><div class="line">        - Path=/foo/&#123;segment&#125;</div><div class="line">        filters:</div><div class="line">        - SetPath=/&#123;segment&#125;</div></pre></td></tr></table></figure><p>对于/foo/bar的请求路径，这将在进行下游请求之前将路径设置为/bar。</p><h3 id="SetResponseHeader-GatewayFilter-Factory（设置响应头网关过滤器工厂）"><a href="#SetResponseHeader-GatewayFilter-Factory（设置响应头网关过滤器工厂）" class="headerlink" title="SetResponseHeader GatewayFilter Factory（设置响应头网关过滤器工厂）"></a>SetResponseHeader GatewayFilter Factory（设置响应头网关过滤器工厂）</h3><p>设置响应头网关过滤器工厂需要参数名和参数的值的键值对参数。</p><p>配置文件application.yml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: setresponseheader_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - SetResponseHeader=X-Response-Foo, Bar</div></pre></td></tr></table></figure><p>这个网关过滤器将用给定的响应头的值替换掉原来请求响应头的值，注意不是添加而是替换。 在上面的配置中，如果下游服务器使用X-Response-Foo：1234进行响应，则将被X-Response-Foo：Bar取代，网关客户端收到的响应头为X-Response-Foo：Bar而不是X-Response-Foo：1234。</p><h3 id="SetStatus-GatewayFilter-Factory-请求响应状态网关过滤器工厂"><a href="#SetStatus-GatewayFilter-Factory-请求响应状态网关过滤器工厂" class="headerlink" title="SetStatus GatewayFilter Factory (请求响应状态网关过滤器工厂)"></a>SetStatus GatewayFilter Factory (请求响应状态网关过滤器工厂)</h3><p>The SetStatus GatewayFilter Factory takes a single <code>status</code> parameter. It must be a valid Spring <code>HttpStatus</code>. It may be the integer value <code>404</code> or the string representation of the enumeration <code>NOT_FOUND</code>.</p><blockquote><p>请求响应网关过滤器工厂需要一个<code>status</code>参数。该参数值必须是一个有效的Spring <code>HttpStatus</code>。该值可以是整型<code>404</code>或者是表示枚举类型<code>NOT_FOUND</code>的字符串。</p></blockquote><p>application.yml</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: setstatusstring_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - SetStatus=BAD_REQUEST</div><div class="line">      - id: setstatusint_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - SetStatus=401</div></pre></td></tr></table></figure><p>In either case, the HTTP status of the response will be set to 401.</p><blockquote><p>如上配置下，无论什么情况，http的响应状态都会被置为401</p></blockquote><h2 id="Global-Filters-（全局过滤器）"><a href="#Global-Filters-（全局过滤器）" class="headerlink" title="Global Filters （全局过滤器）"></a>Global Filters （全局过滤器）</h2><p>The <code>GlobalFilter</code> interface has the same signature as <code>GatewayFilter</code>. These are special filters that are conditionally applied to all routes. (This interface and usage are subject to change in future milestones).</p><blockquote><p><code>GlobalFilter</code>全局过滤器接口有和<code>GatewayFilter</code>相同的签名。这些特殊的过滤器有条件性的应用到全部路由中。（这类接口和用法将会在未来里程碑版本中发生变化）</p></blockquote><h3 id="Combined-Global-Filter-and-GatewayFilter-Ordering-（组合全局过滤器和网关过滤器定序）"><a href="#Combined-Global-Filter-and-GatewayFilter-Ordering-（组合全局过滤器和网关过滤器定序）" class="headerlink" title="Combined Global Filter and GatewayFilter Ordering （组合全局过滤器和网关过滤器定序）"></a>Combined Global Filter and GatewayFilter Ordering （组合全局过滤器和网关过滤器定序）</h3><p>TODO: document ordering</p><blockquote><p>接下来要做：文档化定序方式</p></blockquote><h3 id="Forward-Routing-Filter-（转发路由过滤器）"><a href="#Forward-Routing-Filter-（转发路由过滤器）" class="headerlink" title="Forward Routing Filter （转发路由过滤器）"></a>Forward Routing Filter （转发路由过滤器）</h3><p>The <code>ForwardRoutingFilter</code> looks for a URI in the exchange attribute <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>. If the url has a <code>forward</code> scheme (ie <code>forward:///localendpoint</code>), it will use the Spring <code>DispatcherHandler</code> to handler the request. The unmodified original url is appended to the list in the <code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code> attribute.</p><blockquote><p><code>ForwardRoutingFilter</code>通过以<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>为key在交换属性中获得URI（统一资源标识符）。如果这个url(统一资源定位符)是<code>forward</code>协议，（比如：<code>forward:///localendpoint</code>），那么就会通过Spring<code>DispatcherHandler</code> 去处理该请求。这个未修改的原始路径会被添加到以<code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>为key的列表中。</p></blockquote><h3 id="LoadBalancerClient-Filter-客户端负载均衡过滤器"><a href="#LoadBalancerClient-Filter-客户端负载均衡过滤器" class="headerlink" title="LoadBalancerClient Filter (客户端负载均衡过滤器)"></a>LoadBalancerClient Filter (客户端负载均衡过滤器)</h3><p>The <code>LoadBalancerClientFilter</code> looks for a URI in the exchange attribute <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>. If the url has a <code>lb</code> scheme (ie <code>lb://myservice</code>), it will use the Spring Cloud <code>LoadBalancerClient</code> to resolve the name (<code>myservice</code> in the previous example) to an actual host and port and replace the URI in the same attribute. The unmodified original url is appended to the list in the <code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code> attribute.</p><blockquote><p><code>LoadBalancerClientFilter</code>通过以<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>为key在交换属性中获得URI。如果这个url是<code>lb</code>协议（比如<code>lb://myservice</code>），那么就会通过Spring Cloud <code>LoadBalancerClient</code>去处理这个<code>myservice</code>（这个名字是与前面的例子中匹配的）找到真实的主机和端口，然后在uri的同类属性中进行替换。这个未修改的原始路径会被添加到以<code>ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR</code>为key的LinkedHashSet列表中。</p></blockquote><h3 id="Netty-Routing-Filter-（Netty路由过滤器）"><a href="#Netty-Routing-Filter-（Netty路由过滤器）" class="headerlink" title="Netty Routing Filter （Netty路由过滤器）"></a>Netty Routing Filter （Netty路由过滤器）</h3><p>The Netty Routing Filter runs if the url located in the <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> exchange attribute has a <code>http</code> or <code>https</code> scheme. It uses the Netty <code>HttpClient</code> to make the downstream proxy request. The response is put in the <code>ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code> exchange attribute for use in a later filter. (There is an experimental <code>WebClientHttpRoutingFilter</code> that performs the same function, but does not require netty)</p><blockquote><p>如果在交换属性中以<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>为key获得的url是以<code>http</code>或者是<code>https</code>为请求协议，那么Netty路由过滤器就会生效工作。其是使用Netty<code>HttpClient</code>去生成一个下游的代理请求。请求的响应根据<code>ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code>添加进交换属性中以供后面的过滤器使用。（有一个实验性的过滤器<code>WebClientHttpRoutingFilter</code>执行相同的函数，但是不需要Netty）</p></blockquote><h3 id="Netty-Write-Response-Filter-（Netty响应过滤器）"><a href="#Netty-Write-Response-Filter-（Netty响应过滤器）" class="headerlink" title="Netty Write Response Filter （Netty响应过滤器）"></a>Netty Write Response Filter （Netty响应过滤器）</h3><p>The <code>NettyWriteResponseFilter</code> runs if there is a Netty <code>HttpClientResponse</code> in the <code>ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR</code> exchange attribute. It is run after all other filters have completed and writes the proxy response back to the gateway client response. (There is an experimental <code>WebClientWriteResponseFilter</code> that performs the same function, but does not require netty)</p><blockquote><p>如果在交换属性中以<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>为key获得的请求响应是一个Netty的响应 <code>HttpClientResponse</code>，那么Netty响应过滤器<code>NettyWriteResponseFilter</code>就会生效工作。其是在所有的其他过滤器处理完成之后开始工作的，并且写入代理请求返回给网关客户端响应。（有一个实验性的过滤器<code>WebClientWriteResponseFilter</code>执行相同的函数，但是不需要Netty）</p></blockquote><h3 id="RouteToRequestUrl-Filter-路由到请求地址过滤器"><a href="#RouteToRequestUrl-Filter-路由到请求地址过滤器" class="headerlink" title="RouteToRequestUrl Filter (路由到请求地址过滤器)"></a>RouteToRequestUrl Filter (路由到请求地址过滤器)</h3><p>The <code>RouteToRequestUrlFilter</code> runs if there is a <code>Route</code> object in the <code>ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR</code> exchange attribute. It creates a new URI, based off of the request URI, but updated with the URI attribute of the <code>Route</code> object. The new URI is placed in the <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> exchange attribute`.</p><blockquote><p>如果在交换属性中以<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>为key获得一个<code>Route</code>对象，那么路由请求地址过滤器<code>RouteToRequestUrlFilter</code>就会生效工作。其创建一个新的URI是基于请求的URI，但是根据<code>Route</code>对象的URI属性进行更新。新的URI会以<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>为key放置到交换属性当中。</p></blockquote><h3 id="Websocket-Routing-Filter-（Websocket路由过滤器）"><a href="#Websocket-Routing-Filter-（Websocket路由过滤器）" class="headerlink" title="Websocket Routing Filter （Websocket路由过滤器）"></a>Websocket Routing Filter （Websocket路由过滤器）</h3><p>The Websocket Routing Filter runs if the url located in the <code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code> exchange attribute has a <code>ws</code> or <code>wss</code> scheme. It uses the Spring Web Socket infrastructure to forward the Websocket request downstream.</p><blockquote><p>如果在交换属性中以<code>ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR</code>为key获得的url是以<code>ws</code>或者是<code>wss</code>为请求协议，那么Netty路由过滤器就会生效工作。其使用Spring Web Socket底层代码处理，来将Websocket请求转发到下游。</p></blockquote><h2 id="Configuration-（配置）"><a href="#Configuration-（配置）" class="headerlink" title="Configuration （配置）"></a>Configuration （配置）</h2><p>Configuration for Spring Cloud Gateway is driven by a collection of <code>RouteDefinitionLocator</code> s.</p><blockquote><p>Spring Cloud Gateway的配置是被一系列的<code>RouteDefinitionLocator</code>类来管理的。</p></blockquote><p>RouteDefinitionLocator.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RouteDefinitionLocator</span> </span>&#123;</div><div class="line"><span class="function">Flux&lt;RouteDefinition&gt; <span class="title">getRouteDefinitions</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>By default, a <code>PropertiesRouteDefinitionLocator</code> loads properties using Spring Boot’s <code>@ConfigurationProperties</code> mechanism.</p><blockquote><p>默认方式下，<code>PropertiesRouteDefinitionLocator</code>是通过使用Spring Boot的 <code>@ConfigurationProperties</code> 原理来进行加载配置的。</p></blockquote><p>The configuration examples above all use a shortcut notation that uses positional arguments rather than named ones. The two examples below are equivalent:</p><blockquote><p>以上的配置例子全部都是使用一个指定位置参数（译者注：“<em>genkey</em>”+i）的快捷方式，而不是指定命名的。下面两个例子是等价的：</p></blockquote><p>application.yml</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  cloud:</div><div class="line">    gateway:</div><div class="line">      routes:</div><div class="line">      # =====================================</div><div class="line">      - id: setstatus_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - name: SetStatus</div><div class="line">          args:</div><div class="line">            status: 401</div><div class="line">      - id: setstatusshortcut_route</div><div class="line">        uri: http://example.org</div><div class="line">        filters:</div><div class="line">        - SetStatus=401</div></pre></td></tr></table></figure><p>For some usages of the gateway, properties will be adequate, but some production use cases will benefit from loading configuration from an external source, such as a database. Future milestone versions will have <code>RouteDefinitionLocator</code> implementations based off of Spring Data Repositories such as: Redis, MongoDB and Cassandra.</p><blockquote><p>在gateway网关的一些使用方法上，properties配置会是合适的，但是有些生产使用案例中使用从外部来源加载配置将会更好，比如从一个数据库。未来的里程碑版本将会有 <code>RouteDefinitionLocator</code>基于Spring Data Repositories来实现，例如：Redis, MongoDB and Cassandra。</p></blockquote><h3 id="Fluent-Java-Routes-API-（流式Java路由API）"><a href="#Fluent-Java-Routes-API-（流式Java路由API）" class="headerlink" title="Fluent Java Routes API （流式Java路由API）"></a>Fluent Java Routes API （流式Java路由API）</h3><p>To allow for simple configuration in Java, there is a fluent API defined in the <code>Routes</code> class.</p><blockquote><p>为了在Java中更简单的配置，在<code>Routes</code>类中定义了流式API。</p></blockquote><p>GatewaySampleApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// static imports from GatewayFilters and RoutePredicates</span></div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> RouteLocator <span class="title">customRouteLocator</span><span class="params">(ThrottleGatewayFilterFactory throttle)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Routes.locator()</div><div class="line">            .route(<span class="string">"test"</span>)</div><div class="line">                .predicate(host(<span class="string">"**.abc.org"</span>).and(path(<span class="string">"/image/png"</span>)))</div><div class="line">                .addResponseHeader(<span class="string">"X-TestHeader"</span>, <span class="string">"foobar"</span>)</div><div class="line">                .uri(<span class="string">"http://httpbin.org:80"</span>)</div><div class="line">            .route(<span class="string">"test2"</span>)</div><div class="line">                .predicate(path(<span class="string">"/image/webp"</span>))</div><div class="line">                .add(addResponseHeader(<span class="string">"X-AnotherHeader"</span>, <span class="string">"baz"</span>))</div><div class="line">                .uri(<span class="string">"http://httpbin.org:80"</span>)</div><div class="line">            .route(<span class="string">"test3"</span>)</div><div class="line">                .order(-<span class="number">1</span>)</div><div class="line">                .predicate(host(<span class="string">"**.throttle.org"</span>).and(path(<span class="string">"/get"</span>)))</div><div class="line">                .add(throttle.apply(tuple().of(<span class="string">"capacity"</span>, <span class="number">1</span>,</div><div class="line">                    <span class="string">"refillTokens"</span>, <span class="number">1</span>,</div><div class="line">                    <span class="string">"refillPeriod"</span>, <span class="number">10</span>,</div><div class="line">                    <span class="string">"refillUnit"</span>, <span class="string">"SECONDS"</span>)))</div><div class="line">                .uri(<span class="string">"http://httpbin.org:80"</span>)</div><div class="line">            .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>This style also allows for more custom predicate assertions. The predicates defined by <code>RouteDefinitionLocator</code> beans are combined using logical <code>and</code>. By using the fluent Java API, you can use the <code>and()</code>, <code>or()</code> and <code>negate()</code> operators on the <code>Predicate</code> class.</p><blockquote><p>这类风格也允许更多的自定义predicates断言。被 <code>RouteDefinitionLocator</code> 实例定义的predicates通过使用逻辑 <code>and</code> 来组合。通过使用Java流式API，你能使用<code>and()</code>, <code>or()</code> 和 <code>negate()</code>来操作<code>Predicate</code>类。</p></blockquote><h2 id="Actuator-API-（执行器API）"><a href="#Actuator-API-（执行器API）" class="headerlink" title="Actuator API （执行器API）"></a>Actuator API （执行器API）</h2><p>TODO: document the <code>/gateway</code> actuator endpoint</p><blockquote><p>接下来要做：<code>/gateway</code>执行器端点文档</p></blockquote><h2 id="Developer-Guide-（开发者指南）"><a href="#Developer-Guide-（开发者指南）" class="headerlink" title="Developer Guide （开发者指南）"></a>Developer Guide （开发者指南）</h2><p>TODO: overview of writing custom integrations</p><blockquote><p>接下来要做：编写自定义集成概述</p></blockquote><h3 id="Writing-Custom-Route-Predicate-Factories-（编写自定义路由Predicate工厂）"><a href="#Writing-Custom-Route-Predicate-Factories-（编写自定义路由Predicate工厂）" class="headerlink" title="Writing Custom Route Predicate Factories （编写自定义路由Predicate工厂）"></a>Writing Custom Route Predicate Factories （编写自定义路由Predicate工厂）</h3><p>TODO: document writing Custom Route Predicate Factories</p><blockquote><p>接下来要做：文档化编写自定义路由Predicate工厂</p></blockquote><h3 id="Writing-Custom-GatewayFilter-Factories-（编写自定义GatewayFilter工厂）"><a href="#Writing-Custom-GatewayFilter-Factories-（编写自定义GatewayFilter工厂）" class="headerlink" title="Writing Custom GatewayFilter Factories （编写自定义GatewayFilter工厂）"></a>Writing Custom GatewayFilter Factories （编写自定义GatewayFilter工厂）</h3><p>TODO: document writing Custom GatewayFilter Factories</p><blockquote><p>接下来要做：文档化编写自定义GatewayFilter工厂</p></blockquote><h3 id="Writing-Custom-Global-Filters-（编写自定义全局过滤器）"><a href="#Writing-Custom-Global-Filters-（编写自定义全局过滤器）" class="headerlink" title="Writing Custom Global Filters （编写自定义全局过滤器）"></a>Writing Custom Global Filters （编写自定义全局过滤器）</h3><p>TODO: document writing Custom Global Filters</p><blockquote><p>接下来要做：文档化编写自定义全局过滤器</p></blockquote><h3 id="Writing-Custom-Route-Locators-and-Writers-（编写自定义路由定位器和写入器）"><a href="#Writing-Custom-Route-Locators-and-Writers-（编写自定义路由定位器和写入器）" class="headerlink" title="Writing Custom Route Locators and Writers （编写自定义路由定位器和写入器）"></a>Writing Custom Route Locators and Writers （编写自定义路由定位器和写入器）</h3><p>TODO: document writing Custom Route Locators and Writers</p><blockquote><p>接下来要做：文档化编写自定义路由定位器和写入器</p></blockquote><h2 id="Building-a-Simple-Gateway-Using-Spring-MVC-（使用Spring-MVC构建一个简单的网关）"><a href="#Building-a-Simple-Gateway-Using-Spring-MVC-（使用Spring-MVC构建一个简单的网关）" class="headerlink" title="Building a Simple Gateway Using Spring MVC （使用Spring MVC构建一个简单的网关）"></a>Building a Simple Gateway Using Spring MVC （使用Spring MVC构建一个简单的网关）</h2><p>Spring Cloud Gateway provides a utility object called <code>ProxyExchange</code> which you can use inside a regular Spring MVC handler as a method parameter. It supports basic downstream HTTP exchanges via methods that mirror the HTTP verbs, or forwarding to a local handler via the <code>forward()</code> method.</p><blockquote><p>Spring Cloud Gateway 提供了名为 <code>ProxyExchange</code> 一个实用化对象，你可以使用它来内置一个正确的Spring MVC处理器作为方法参数。它支持通过真实的HTTP的方法来替换下游的内部HTTP，或者通过 <code>forward()</code> 方法转发到一个本地的处理器。</p></blockquote><p>Example (proxying a request to “/test” downstream to a remote server):</p><blockquote><p>例如下：（代理请求”/test”的请求到下游的一个远程服务）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewaySampleApplication</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;remote.home&#125;"</span>)</div><div class="line"><span class="keyword">private</span> URI home;</div><div class="line"></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</div><div class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; proxy(ProxyExchange&lt;Object&gt; proxy) <span class="keyword">throws</span> Exception &#123;</div><div class="line"><span class="keyword">return</span> proxy.uri(home.toString() + <span class="string">"/image/png"</span>).get();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>There are convenience methods on the <code>ProxyExchange</code> to enable the handler method to discover and enhance the URI path of the incoming request. For example you might want to extract the trailing elements of a path to pass them downstream:</p><blockquote><p>在<code>ProxyExchange</code>有简单的方式去通过处理器方法发现并完善请求的URI路径。比如你可能想提取路径后的元素，以便将它们传递到下游：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/proxy/path/**"</span>)</div><div class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; proxyPath(ProxyExchange&lt;?&gt; proxy) <span class="keyword">throws</span> Exception &#123;</div><div class="line">  String path = proxy.path(<span class="string">"/proxy/path/"</span>);</div><div class="line">  <span class="keyword">return</span> proxy.uri(home.toString() + <span class="string">"/foos/"</span> + path).get();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>All the features of Spring MVC are available to Gateway handler methods. So you can inject request headers and query parameters, for instance, and you can constrain the incoming requests with declarations in the mapping annotation. See the documentation for <code>@RequestMapping</code> in Spring MVC for more details of those features.</p><blockquote><p>所有的Spring MVC的特性都可以使用到网关的处理器方法。因此你可以注入请求头和查询参数，你可以使用映射注解声明来约束请求。 查看Spring MVC中的 <code>@RequestMapping</code> 文档可以了解更多的特性。</p></blockquote><p>Headers can be added to the downstream response using the <code>header()</code> methods on <code>ProxyExchange</code>.</p><blockquote><p>通过 <code>ProxyExchange</code> 的 <code>header()</code> 方法可以添加头信息到下游的响应中。</p></blockquote><p>You can also manipulate response headers (and anything else you like in the response) by adding a mapper to the <code>get()</code> etc. method. The mapper is a <code>Function</code> that takes the incoming <code>ResponseEntity</code> and converts it to an outgoing one.</p><blockquote><p>通过向 <code>get()</code> 之类的方法添加一个映射，你也可以操作响应头（包括在响应中你想要的）。这个映射是一个需要输入<code>ResponseEntity</code> 和转化指定输出的 <code>Function</code> 函数。 </p></blockquote><p>First class support is provided for “sensitive” headers (“cookie” and “authorization” by default) which are not passed downstream, and for “proxy” headers (<code>x-forwarded-*</code>).</p><blockquote><p>最高优先级的类支持处理让 <code>sensitive</code> 敏感头信息（<code>cookie</code>和<code>authorization</code>是默认的）不往下游传递，并且对于 <code>proxy</code> 代理头信息处理为（<code>x-forwarded-*</code>）。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;: 本文主要对Spring Cloud Gateway v2.0.0.M3&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-gateway/blob/v2.0.0.M3/docs/src/main/asciidoc/spring-cloud-gateway.adoc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原文地址&lt;/a&gt; 版本文档进行翻译,持续更新至稳定版本，然后公布。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud Gateway" scheme="http://lvqingyan.com/categories/Spring-Cloud-Gateway/"/>
    
    
      <category term="Spring Cloud Gateway" scheme="http://lvqingyan.com/tags/Spring-Cloud-Gateway/"/>
    
  </entry>
  
  <entry>
    <title>中小型互联网公司微服务实践-经验和教训</title>
    <link href="http://lvqingyan.com/sc-zq/"/>
    <id>http://lvqingyan.com/sc-zq/</id>
    <published>2017-10-19T04:23:31.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次写了一篇文章叫<a href="https://mp.weixin.qq.com/s/vnWXpH5pv-FAzLZfbgTGvg" target="_blank" rel="external">Spring Cloud在国内中小型公司能用起来吗?</a>介绍了Spring Cloud是否能在中小公司使用起来，这篇文章是它的姊妹篇。其实我们在这条路上已经走了一年多，从16年初到现在。在使用Spring Cloud之前我们对微服务实践是没有太多的体会和经验的。从最初的开源软件<a href="https://github.com/cloudfavorites/favorites-web" target="_blank" rel="external">云收藏</a>来熟悉Spring Boot，到项目中的慢慢使用，再到最后全面拥抱Spring Cloud。这篇文章就给大家介绍一下我们使用Spring Boot/Cloud一年多的经验。<br><a id="more"></a></p><p>在开始之前我们先介绍一下几个概念，什么是微服务，它的特点是什么?<br>Spring Boot/Cloud都做了那些事情？他们三者之间又有什么联系？</p><h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><h3 id="什么是微服务"><a href="#什么是微服务" class="headerlink" title="什么是微服务"></a>什么是微服务</h3><p>微服务的概念源于2014年3月Martin Fowler所写的一篇文章“<a href="http://martinfowler.com/articles/microservices.html" target="_blank" rel="external">Microservices</a>”。</p><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p><p>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。在所有情况下，每个任务代表着一个小的业务能力。</p><h3 id="微服务架构优势"><a href="#微服务架构优势" class="headerlink" title="微服务架构优势"></a>微服务架构优势</h3><p><strong>复杂度可控</strong>：在将应用分解的同时，规避了原本复杂度无止境的积累。每一个微服务专注于单一功能，并通过定义良好的接口清晰表述服务边界。由于体积小、复杂度低，每个微服务可由一个小规模开发团队完全掌控，易于保持高可维护性和开发效率。</p><p><strong>独立部署</strong>：由于微服务具备独立的运行进程，所以每个微服务也可以独立部署。当某个微服务发生变更时无需编译、部署整个应用。由微服务组成的应用相当于具备一系列可并行的发布流程，使得发布更加高效，同时降低对生产环境所造成的风险，最终缩短应用交付周期。</p><p><strong>技术选型灵活</strong>：微服务架构下，技术选型是去中心化的。每个团队可以根据自身服务的需求和行业发展的现状，自由选择最适合的技术栈。由于每个微服务相对简单，故需要对技术栈进行升级时所面临的风险就较低，甚至完全重构一个微服务也是可行的。</p><p><strong>容错</strong>：当某一组建发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，形成应用全局性的不可用。在微服务架构下，故障会被隔离在单个服务中。若设计良好，其他服务可通过重试、平稳退化等机制实现应用层面的容错。</p><p><strong>扩展</strong>：单块架构应用也可以实现横向扩展，就是将整个应用完整的复制到不同的节点。当应用的不同组件在扩展需求上存在差异时，微服务架构便体现出其灵活性，因为每个服务可以根据实际需求独立进行扩展。</p><h3 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot"></a>什么是Spring Boot</h3><p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是Spring Boot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，Spring Boot整合了所有的框架（不知道这样比喻是否合适）。</p><p>Spring Boot简化了基于Spring的应用开发，通过少量的代码就能创建一个独立的、产品级别的Spring应用。 Spring Boot为Spring平台及第三方库提供开箱即用的设置，这样你就可以有条不紊地开始。Spring Boot的核心思想就是约定大于配置，多数Spring Boot应用只需要很少的Spring配置。采用Spring Boot可以大大的简化你的开发模式，所有你想集成的常用框架，它都有对应的组件支持。</p><h3 id="Spring-Cloud都做了哪些事"><a href="#Spring-Cloud都做了哪些事" class="headerlink" title="Spring Cloud都做了哪些事"></a>Spring Cloud都做了哪些事</h3><p>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包</p><p>以下为Spring Cloud的核心功能：  </p><ul><li>分布式/版本化配置</li><li>服务注册和发现</li><li>路由</li><li>服务和服务之间的调用</li><li>负载均衡</li><li>断路器</li><li>分布式消息传递</li></ul><p>我们再来看一张图：</p><p><img src="http://www.ityouknow.com/assets/images/2017/springcloud/spring-cloud-architecture.png" alt=""></p><p>通过这张图，我们来了解一下各组件配置使用运行流程：</p><ul><li>1、请求统一通过API网关（Zuul）来访问内部服务.  </li><li>2、网关接收到请求后，从注册中心（Eureka）获取可用服务  </li><li>3、由Ribbon进行均衡负载后，分发到后端具体实例  </li><li>4、微服务之间通过Feign进行通信处理业务</li><li>5、Hystrix负责处理服务超时熔断</li><li>6、Turbine监控服务间的调用和熔断相关指标</li></ul><h3 id="Spring-Cloud体系介绍"><a href="#Spring-Cloud体系介绍" class="headerlink" title="Spring Cloud体系介绍"></a>Spring Cloud体系介绍</h3><p>上图只是Spring Cloud体系的一部分，Spring Cloud共集成了19个子项目，里面都包含一个或者多个第三方的组件或者框架！</p><p>Spring Cloud 工具框架</p><p>1、Spring Cloud Config 配置中心，利用git集中管理程序的配置。<br>2、Spring Cloud Netflix 集成众多Netflix的开源软件<br>3、Spring Cloud Bus 消息总线，利用分布式消息将服务和服务实例连接在一起，用于在一个集群中传播状态的变化<br>4、Spring Cloud for Cloud Foundry 利用Pivotal Cloudfoundry集成你的应用程序<br>5、Spring Cloud Cloud Foundry Service Broker 为建立管理云托管服务的服务代理提供了一个起点。<br>6、Spring Cloud Cluster 基于Zookeeper, Redis, Hazelcast, Consul实现的领导选举和平民状态模式的抽象和实现。<br>7、Spring Cloud Consul 基于Hashicorp Consul实现的服务发现和配置管理。<br>8、Spring Cloud Security 在Zuul代理中为OAuth2 rest客户端和认证头转发提供负载均衡<br>9、Spring Cloud Sleuth SpringCloud应用的分布式追踪系统，和Zipkin，HTrace，ELK兼容。<br>10、Spring Cloud Data Flow 一个云本地程序和操作模型，组成数据微服务在一个结构化的平台上。<br>11、Spring Cloud Stream 基于Redis,Rabbit,Kafka实现的消息微服务，简单声明模型用以在Spring Cloud应用中收发消息。<br>12、Spring Cloud Stream App Starters 基于Spring Boot为外部系统提供spring的集成<br>13、Spring Cloud Task 短生命周期的微服务，为SpringBooot应用简单声明添加功能和非功能特性。<br>14、Spring Cloud Task App Starters<br>15、Spring Cloud Zookeeper 服务发现和配置管理基于Apache Zookeeper。<br>16、Spring Cloud for Amazon Web Services 快速和亚马逊网络服务集成。<br>17、Spring Cloud Connectors 便于PaaS应用在各种平台上连接到后端像数据库和消息经纪服务。<br>18、Spring Cloud Starters （项目已经终止并且在Angel.SR2后的版本和其他项目合并）<br>19、Spring Cloud CLI 插件用Groovy快速的创建Spring Cloud组件应用。  </p><blockquote><p>当然这个数量还在一直增加…</p></blockquote><h3 id="三者之间的关系"><a href="#三者之间的关系" class="headerlink" title="三者之间的关系"></a>三者之间的关系</h3><p>微服务是一种架构的理念，提出了微服务的设计原则，从理论为具体的技术落地提供了指导思想。Spring Boot是一套快速配置脚手架，可以基于Spring Boot快速开发单个微服务；Spring Cloud是一个基于Spring Boot实现的服务治理工具包；Spring Boot专注于快速、方便集成的单个微服务个体，Spring Cloud关注全局的服务治理框架。</p><p><strong>Spring Boot/Cloud是微服务实践的最佳落地方案。</strong></p><h2 id="实战经历"><a href="#实战经历" class="headerlink" title="实战经历"></a>实战经历</h2><h3 id="遇到问题，寻找方案"><a href="#遇到问题，寻找方案" class="headerlink" title="遇到问题，寻找方案"></a>遇到问题，寻找方案</h3><p>2015年初的时候，因为公司业务的大量发展，我们开始对原有的业务进行拆分，新上的业务线也全部使用独立的项目来开发，项目和项目之间通过http接口进行访问。15年的业务发展非常迅速，项目数量也就相应急剧扩大，到了15底的时候项目达60多个，当项目数达到30几个的时候，其实我们就遇到了问题，经常某个项目因为扩展增加了新的IP地址，我们就需要被动的更新好几个相关的项目。服务越来越多，服务之间的调用关系也越来越复杂，有时候想画一张图来表示项目和项目之间的依赖关系，线条密密麻麻无法看清。网上有一张图可以表达我们的心情。</p><p><img src="http://www.ityouknow.com/assets/images/2017/architecture/calling_relation.png" alt="">  </p><p>这个时候我们就想找一种方案，可以将我们这么多分布式的服务给管理起来，到网上进行了技术调研。我们发现有两款开源软件比较适合我们，一个是Dubbo，一个是Spring Cloud。</p><p>其实刚开始我们是走了一些弯路的。这两款框架我们当时都不熟悉，当时国内使用Spring Cloud进行开发的企业非常的少，我在网上也几乎没找到太多应用的案例。但是Dubbo当时在国内的使用还是挺普遍的，相关的资料各方面都比较完善。因此在公司扩展新业务线众筹平台的时候，技术选型就先定了Dubbo，因为也是全新的业务没有什么负担，这个项目我们大概开发了六个月投产，上线之初也遇到了一些问题，但最终还比较顺利。</p><p>在新业务线选型使用Dubbo的同时，我们也没有完全放弃Spring Cloud，我们抽出了一两名开发人员学习Spring Boot我也参与其中，为了验证Spring Boot是否可以到达实战的标准，我们在业余的时间使用Spring Boot开发了一款开源软件<a href="http://favorites.ren/" target="_blank" rel="external">云收藏</a>，经过这个项目的实战验证我们对Spring Boot就有了信心。最重要的是大家体会到使用Spring Boot的各种便利之后，就再也不想使用传统的方式来进行开发了。</p><p>但是还有一个问题，在选择了Spring Boot进行新业务开发的同时，并没有解决我们上面的那个问题，服务于服务直接调用仍然比较复杂和传统，这时候我们就开始研究Spring Cloud。因为大家在前期对Spring Boot有了足够的了解，因此学习Sprig Cloud就显得顺风顺水了。所以在使用Dubbo半年之后，我们又全面开始拥抱Spring Cloud。</p><h3 id="为什么选择使用Spring-Cloud而放弃了Dubbo"><a href="#为什么选择使用Spring-Cloud而放弃了Dubbo" class="headerlink" title="为什么选择使用Spring Cloud而放弃了Dubbo"></a>为什么选择使用Spring Cloud而放弃了Dubbo</h3><p>可能大家会问，为什么选择了使用Dubbo之后，而又选择全面使用Spring Cloud呢？其中有几个原因：</p><p>1）从两个公司的背景来谈：Dubbo，是阿里巴巴服务化治理的核心框架，并被广泛应用于中国各互联网公司；Spring Cloud是大名鼎鼎的Spring家族的产品。阿里巴巴是一个商业公司，虽然也开源了很多的顶级的项目，但从整体战略上来讲，仍然是服务于自身的业务为主。Spring专注于企业级开源框架的研发，不论是在中国还是在世界上使用都非常广泛，开发出通用、开源、稳健的开源框架就是他们的主业。</p><p>2）从社区活跃度这个角度来对比，Dubbo虽然也是一个非常优秀的服务治理框架，并且在服务治理、灰度发布、流量分发这方面做的比Spring Cloud还好，除过当当网在基础上增加了rest支持外，已有两年多的时间几乎都没有任何更新了。在使用过程中出现问题，提交到github的Issue也少有回复。</p><p>相反Spring Cloud自从发展到现在，仍然在不断的高速发展，从github上提交代码的频度和发布版本的时间间隔就可以看出，现在Spring Cloud即将发布2.0版本，到了后期会更加完善和稳定。</p><p>3) 从整个大的平台架构来讲，dubbo框架只是专注于服务之间的治理，如果我们需要使用配置中心、分布式跟踪这些内容都需要自己去集成，这样无形中使用dubbo的难度就会增加。Spring Cloud几乎考虑了服务治理的方方面面，更有Spring Boot这个大将的支持，开发起来非常的便利和简单。</p><p>4）从技术发展的角度来讲，Dubbo刚出来的那会技术理念还是非常先进，解决了各大互联网公司服务治理的问题，中国的各中小公司也从中受益不少。经过了这么多年的发展，互联网行业也是涌现了更多先进的技术和理念，Dubbo一直停滞不前，自然有些掉队，有时候我个人也会感到有点可惜，如果Dubbo一直沿着当初的那个路线发展，并且延伸到周边，今天可能又是另一番景象了。</p><p>Spring 推出Spring Boot/Cloud也是因为自身的很多原因。Spring最初推崇的轻量级框架，随着不断的发展也越来越庞大，随着集成项目越来越多，配置文件也越来越混乱，慢慢的背离最初的理念。随着这么多年的发展，微服务、分布式链路跟踪等更多新的技术理念的出现，Spring急需一款框架来改善以前的开发模式，因此才会出现Spring Boot/Cloud项目，我们现在访问Spring官网，会发现Spring Boot和Spring Cloud已经放到首页最重点突出的三个项目中的前两个，可见Spring对这两个框架的重视程度。</p><p><strong>总结一下，dubbo曾经确实很牛逼，但是Spring Cloud是站在近些年技术发展之上进行开发，因此更具技术代表性。</strong></p><h3 id="如何进行微服务架构演进"><a href="#如何进行微服务架构演进" class="headerlink" title="如何进行微服务架构演进"></a>如何进行微服务架构演进</h3><p>当我们将所有的新业务都使用Spring Cloud这套架构之后，就会出现这样一个现象，公司的系统被分成了两部分，一部分是传统架构的项目，一部分是微服务架构的项目，如何让这两套配合起来使用就成为了关键，这时候Spring Cloud里面的一个关键组件解决了我们的问题，就是Zuul。在Spring Cloud架构体系内的所有微服务都通过Zuul来对外提供统一的访问入口，所有需要和微服务架构内部服务进行通讯的请求都走统一网关。如下图：</p><p><img src="http://www.ityouknow.com/assets/images/2017/architecture/framework4.jpg" alt=""></p><p>从上图可以看出我们对服务进行了分类，有四种：基础服务、业务服务、组合服务、前置服务。不同服务迁移的优先级不同</p><ul><li><strong>基础服务</strong>，是一些基础组件，与具体的业务无关。比如：短信服务、邮件服务。这里的服务最容易摘出来做微服务，也是我们第一优先级分离出来的服务。</li><li><strong>业务服务</strong>，是一些垂直的业务系统，只处理单一的业务类型，比如：风控系统、积分系统、合同系统。这类服务职责比较单一，根据业务情况来选择是否迁移，比如：如果突然有需求对积分系统进行大优化，我们就趁机将积分系统进行改造，是我们的第二优先级分离出来的服务。</li><li><strong>前置服务</strong>，前置服务一般为服务的接入或者输出服务，比如网站的前端服务、app的服务接口这类，这是我们第三优先级分离出来的服务。</li><li><strong>组合服务</strong>，组合服务就是涉及到了具体的业务，比如买标过程，需要调用很多垂直的业务服务，这类的服务我们一般放到最后再进行微服务化架构来改造，因为这类服务最为复杂，除非涉及到大的业务逻辑变更，我们是不会轻易进行迁移。</li></ul><p>在这四类服务之外，新上线的业务全部使用Sprng Boot/Cloud这套技术栈。就这样，我们从开源项目<a href="https://github.com/cloudfavorites/favorites-web" target="_blank" rel="external">云收藏</a>开始，上线几个Spring Boot项目，到现在公司绝大部分的项目都是在Spring Cloud这个架构体系中。</p><h2 id="经验和教训"><a href="#经验和教训" class="headerlink" title="经验和教训"></a>经验和教训</h2><h3 id="架构演化的步骤"><a href="#架构演化的步骤" class="headerlink" title="架构演化的步骤"></a>架构演化的步骤</h3><ul><li>在确定使用Spring Boot/Cloud这套技术栈进行微服务改造之前，先梳理平台的服务，对不同的服务进行分类，以确认演化的节奏。</li><li>先让团队熟悉Spring Boot技术，并且优先在基础服务上进行技术改造，推动改动后的项目投产上线</li><li>当团队熟悉Spring Boot之后，再推进使用Spring Cloud对原有的项目进行改造。</li><li>在进行微服务改造过程中，优先应用于新业务系统，前期可以只是少量的项目进行了微服务化改造，随着大家对技术的熟悉度增加，可以加快加大微服务改造的范围</li><li>传统项目和微服务项目共存是一个很常见的情况，除非公司业务有大的变化，不建议直接迁移核心项目。</li></ul><h3 id="服务拆分原则"><a href="#服务拆分原则" class="headerlink" title="服务拆分原则"></a>服务拆分原则</h3><p>服务拆分有以下几个原则和大家分享</p><p><strong>横向拆分</strong>。按照不同的业务域进行拆分，例如订单、营销、风控、积分资源等。形成独立的业务领域微服务集群。</p><p><strong>纵向拆分</strong>。把一个业务功能里的不同模块或者组件进行拆分。例如把公共组件拆分成独立的原子服务，下沉到底层，形成相对独立的原子服务层。这样一纵一横，就可以实现业务的服务化拆分。</p><p>要做好微服务的分层：梳理和抽取核心应用、公共应用，作为独立的服务下沉到核心和公共能力层，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求</p><p>服务拆分是越小越好吗？微服务的大与小是相对的。比如在初期，我们把交易拆分为一个微服务，但是随着业务量的增大，可能一个交易系统已经慢慢变得很大，并且并发流量也不小，为了支撑更多的交易量，我会把交易系统，拆分为订单服务、投标服务、转让服务等。因此微服务的拆分力度需与具体业务相结合，总的原则是<strong>服务内部高内聚，服务之间低耦合。</strong></p><h3 id="微服务vs传统开发"><a href="#微服务vs传统开发" class="headerlink" title="微服务vs传统开发"></a>微服务vs传统开发</h3><p>使用微服务有一段时间了，这种开发模式和传统的开发模式对比，有很大的不同。</p><ul><li>分工不同，以前我们可能是一个一个模块，现在可能是一人一个系统。 </li><li>架构不同，服务的拆分是一个技术含量很高的问题，拆分是否合理对以后发展影响巨大。  </li><li>部署方式不同，如果还像以前一样部署估计累死了，自动化运维不可不上。  </li><li>容灾不同，好的微服务可以隔离故障避免服务整体down掉，坏的微服务设计仍然可以因为一个子服务出现问题导致连锁反应。</li></ul><h3 id="给数据库带来的挑战"><a href="#给数据库带来的挑战" class="headerlink" title="给数据库带来的挑战"></a>给数据库带来的挑战</h3><p>每个微服务都有自己独立的数据库，那么后台管理的联合查询怎么处理？这应该是大家会普遍遇到的一个问题，有三种处理方案。</p><p>1）严格按照微服务的划分来做，微服务相互独立，各微服务数据库也独立，后台需要展示数据时，调用各微服务的接口来获取对应的数据，再进行数据处理后展示出来，这是标准的用法，也是最麻烦的用法。</p><p>2) 将业务高度相关的表放到一个库中，将业务关系不是很紧密的表严格按照微服务模式来拆分，这样既可以使用微服务，也避免了数据库分散导致后台系统统计功能难以实现，是一个折中的方案。</p><p>3）数据库严格按照微服务的要求来切分，以满足业务高并发，实时或者准实时将各微服务数据库数据同步到NoSQL数据库中，在同步的过程中进行数据清洗，用来满足后台业务系统的使用，推荐使用MongoDB、HBase等。</p><p>三种方案在不同的公司我都使用过，第一种方案适合业务较为简单的小公司；第二种方案，适合在原有系统之上，慢慢演化为微服务架构的公司；第三种适合大型高并发的互联网公司。</p><h3 id="微服务的经验和建议"><a href="#微服务的经验和建议" class="headerlink" title="微服务的经验和建议"></a>微服务的经验和建议</h3><p>1、建议尽量不要使用Jsp，页面开发推荐使用Thymeleaf。Web项目建议独立部署Tomcat，不要使用内嵌的Tomcat，内嵌Tomcat部署Jsp项目会偶现龟速访问的情况。</p><p>2、服务编排是个好东西，主要的作用是减少项目中的相互依赖。比如现在有项目a调用项目b，项目b调用项目c…一直到h，是一个调用链，那么项目上线的时候需要先更新最底层的h再更新g…更新c更新b最后是更新项目a。这只是这一个调用链，在复杂的业务中有非常多的调用，如果要记住每一个调用链对开发运维人员来说就是灾难。</p><p>有这样一个好办法可以尽量的减少项目的相互依赖，就是服务编排，一个核心的业务处理项目，负责和各个微服务打交道。比如之前是a调用b，b掉用c，c调用d，现在统一在一个核心项目W中来处理，W服务使用a的时候去调用b，使用b的时候W去调用c，举个例子：在第三方支付业务中，有一个核心支付项目是服务编排，负责处理支付的业务逻辑，W项目使用商户信息的时候就去调用“商户系统”，需要校验设备的时候就去调用“终端系统”，需要风控的时候就调用“风控系统”，各个项目需要的依赖参数都由W来做主控。以后项目部署的时候，只需要最后启动服务编排项目即可。</p><p>3、不要为了追求技术而追求技术，确定进行微服务架构改造之前，需要考虑以下几方面的因素：<br>1）团队的技术人员是否已经具备相关技术基础。<br>2）公司业务是否适合进行微服务化改造，并不是所有的平台都适合进行微服务化改造，比如：传统行业有很多复杂垂直的业务系统。<br>3）Spring Cloud生态的技术有很多，并不是每一种技术方案都需要用上，适合自己的才是最好的。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Spring Cloud对于中小型互联网公司来说是一种福音</strong>，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p><hr><p><strong>作者：纯洁的微笑</strong><br><strong>出处：<a href="http://www.ityouknow.com/springcloud/2017/10/19/micro-service-practice.html" target="_blank" rel="external">http://www.ityouknow.com/</a></strong><br><strong>版权所有，欢迎保留原文链接进行转载：)</strong> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次写了一篇文章叫&lt;a href=&quot;https://mp.weixin.qq.com/s/vnWXpH5pv-FAzLZfbgTGvg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud在国内中小型公司能用起来吗?&lt;/a&gt;介绍了Spring Cloud是否能在中小公司使用起来，这篇文章是它的姊妹篇。其实我们在这条路上已经走了一年多，从16年初到现在。在使用Spring Cloud之前我们对微服务实践是没有太多的体会和经验的。从最初的开源软件&lt;a href=&quot;https://github.com/cloudfavorites/favorites-web&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;云收藏&lt;/a&gt;来熟悉Spring Boot，到项目中的慢慢使用，再到最后全面拥抱Spring Cloud。这篇文章就给大家介绍一下我们使用Spring Boot/Cloud一年多的经验。&lt;br&gt;
    
    </summary>
    
      <category term="社区" scheme="http://lvqingyan.com/categories/%E7%A4%BE%E5%8C%BA/"/>
    
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Zuul遗失的世界(三)</title>
    <link href="http://lvqingyan.com/sc-zuul-s3/"/>
    <id>http://lvqingyan.com/sc-zuul-s3/</id>
    <published>2017-08-15T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>摘要</strong>:  接着上一篇《Spring Cloud Zuul遗失的世界(二)》，本文主要介绍Netflix Zuul core模块的Filter链的设计和Fifter Loader和Filter Manager相关代码的设计与分析。</p><a id="more"></a><h2 id="一-Zuul-Filter的抽象设计"><a href="#一-Zuul-Filter的抽象设计" class="headerlink" title="一.Zuul Filter的抽象设计"></a>一.Zuul Filter的抽象设计</h2><h3 id="1-1-自定义Zuul-Filter"><a href="#1-1-自定义Zuul-Filter" class="headerlink" title="1.1 自定义Zuul Filter"></a>1.1 自定义Zuul Filter</h3><p>当我们使用Spring Cloud Zuul都会直接继承ZuulFilter，覆盖实现抽象类中定义的方法，如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PreFilter.class);</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="string">"pre"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">RequestContext ctx = RequestContext.getCurrentContext();</div><div class="line">String token = ctx.getRequest().getHeader(HttpHeaders.AUTHORIZATION);</div><div class="line"></div><div class="line">String labels = TOKEN_LABEL_MAP.get(token);</div><div class="line"></div><div class="line">logger.info(<span class="string">"label: "</span> + labels);</div><div class="line"></div><div class="line">CoreHeaderInterceptor.initHystrixRequestContext(labels); <span class="comment">// zuul本身调用微服务</span></div><div class="line">ctx.addZuulRequestHeader(CoreHeaderInterceptor.HEADER_LABEL, labels); <span class="comment">// 传递给后续微服务</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-2-IZuulFilter代码"><a href="#1-2-IZuulFilter代码" class="headerlink" title="1.2  IZuulFilter代码"></a>1.2  IZuulFilter代码</h3><p>定义 IZuulFilter interface，共同的常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IZuulFilter</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * a "true" return from this method means that the run() method should be invoked</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> true if the run() method should be invoked. false will not invoke the run() method</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * if shouldFilter() is true, this method will be invoked. this method is the core method of a ZuulFilter</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> Some arbitrary artifact may be returned. Current implementation ignores it.</div><div class="line">     */</div><div class="line">    <span class="function">Object <span class="title">run</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-2-抽象类ZuulFilter代码"><a href="#1-2-抽象类ZuulFilter代码" class="headerlink" title="1.2  抽象类ZuulFilter代码"></a>1.2  抽象类ZuulFilter代码</h3><p>抽象类ZuulFilter实现IZuulFilter，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulFilter</span> <span class="keyword">implements</span> <span class="title">IZuulFilter</span>, <span class="title">Comparable</span>&lt;<span class="title">ZuulFilter</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DynamicBooleanProperty filterDisabled =</div><div class="line">            DynamicPropertyFactory.getInstance().getBooleanProperty(disablePropertyName(), <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">//filter类型</span></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   </div><div class="line">    <span class="comment">// Filter的执行顺序</span></div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   </div><div class="line">   <span class="comment">//是否是静态Filter</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStaticFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">disablePropertyName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"zuul."</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">"."</span> + filterType() + <span class="string">".disable"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Filter是否启动</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFilterDisabled</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> filterDisabled.get();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> ZuulFilterResult <span class="title">runFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        ZuulFilterResult zr = <span class="keyword">new</span> ZuulFilterResult();</div><div class="line">        <span class="keyword">if</span> (!isFilterDisabled()) &#123;</div><div class="line">            <span class="keyword">if</span> (shouldFilter()) &#123;</div><div class="line">                Tracer t = TracerFactory.instance().startMicroTracer(<span class="string">"ZUUL::"</span> + <span class="keyword">this</span>.getClass().getSimpleName());</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Object res = run();</div><div class="line">                    zr = <span class="keyword">new</span> ZuulFilterResult(res, ExecutionStatus.SUCCESS);</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                    t.setName(<span class="string">"ZUUL::"</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" failed"</span>);</div><div class="line">                    zr = <span class="keyword">new</span> ZuulFilterResult(ExecutionStatus.FAILED);</div><div class="line">                    zr.setException(e);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    t.stopAndLog();</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                zr = <span class="keyword">new</span> ZuulFilterResult(ExecutionStatus.SKIPPED);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> zr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(ZuulFilter filter)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.filterOrder(), filter.filterOrder());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="二-Spring-Cloud-Zuul的Filter管理"><a href="#二-Spring-Cloud-Zuul的Filter管理" class="headerlink" title="二.Spring Cloud Zuul的Filter管理"></a>二.Spring Cloud Zuul的Filter管理</h2><p>  zuul支持动加载Filter类文件。实现原理是监控存放Filter文件的目录，定期扫描这些目录，如果发现有新Filter源码文件或者Filter源码文件有改动，则对文件进行编译加载。目前zuul支持使用Groovy编写的Filter。</p><h3 id="2-1-FilterFileManager"><a href="#2-1-FilterFileManager" class="headerlink" title="2.1 FilterFileManager"></a>2.1 FilterFileManager</h3><p> groovy的文件filter加载,通过FilterFileManager，开启一个线程，开始轮询GroovyFilterFile的目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterFileManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(FilterFileManager.class);</div><div class="line"></div><div class="line">    String[] aDirectories;</div><div class="line">    <span class="keyword">int</span> pollingIntervalSeconds;</div><div class="line">    Thread poller;</div><div class="line">    <span class="keyword">boolean</span> bRunning = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> FilenameFilter FILENAME_FILTER;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> FilterFileManager INSTANCE;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FilterFileManager</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setFilenameFilter</span><span class="params">(FilenameFilter filter)</span> </span>&#123;</div><div class="line">        FILENAME_FILTER = filter;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Initialized the GroovyFileManager.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> pollingIntervalSeconds the polling interval in Seconds</div><div class="line">     * <span class="doctag">@param</span> directories            Any number of paths to directories to be polled may be specified</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     * <span class="doctag">@throws</span> IllegalAccessException</div><div class="line">     * <span class="doctag">@throws</span> InstantiationException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> pollingIntervalSeconds, String... directories)</span> <span class="keyword">throws</span> Exception, IllegalAccessException, InstantiationException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) INSTANCE = <span class="keyword">new</span> FilterFileManager();</div><div class="line"></div><div class="line">        INSTANCE.aDirectories = directories;</div><div class="line">        INSTANCE.pollingIntervalSeconds = pollingIntervalSeconds;</div><div class="line">        INSTANCE.manageFiles();</div><div class="line">        INSTANCE.startPoller();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FilterFileManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Shuts down the poller</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">        INSTANCE.stopPoller();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stopPoller</span><span class="params">()</span> </span>&#123;</div><div class="line">        bRunning = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 开启一个线程，开始轮询</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startPoller</span><span class="params">()</span> </span>&#123;</div><div class="line">        poller = <span class="keyword">new</span> Thread(<span class="string">"GroovyFilterFileManagerPoller"</span>) &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">while</span> (bRunning) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        sleep(pollingIntervalSeconds * <span class="number">1000</span>);</div><div class="line">                        manageFiles();</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        poller.setDaemon(<span class="keyword">true</span>);</div><div class="line">        poller.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns the directory File for a path. A Runtime Exception is thrown if the directory is in valid</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> sPath</div><div class="line">     * <span class="doctag">@return</span> a File representing the directory path</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">getDirectory</span><span class="params">(String sPath)</span> </span>&#123;</div><div class="line">        File  directory = <span class="keyword">new</span> File(sPath);</div><div class="line">        <span class="keyword">if</span> (!directory.isDirectory()) &#123;</div><div class="line">            URL resource = FilterFileManager.class.getClassLoader().getResource(sPath);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                directory = <span class="keyword">new</span> File(resource.toURI());</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOG.error(<span class="string">"Error accessing directory in classloader. path="</span> + sPath, e);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!directory.isDirectory()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(directory.getAbsolutePath() + <span class="string">" is not a valid directory"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> directory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns a List&lt;File&gt; of all Files from all polled directories</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function">List&lt;File&gt; <span class="title">getFiles</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;File&gt; list = <span class="keyword">new</span> ArrayList&lt;File&gt;();</div><div class="line">        <span class="keyword">for</span> (String sDirectory : aDirectories) &#123;</div><div class="line">            <span class="keyword">if</span> (sDirectory != <span class="keyword">null</span>) &#123;</div><div class="line">                File directory = getDirectory(sDirectory);</div><div class="line">                File[] aFiles = directory.listFiles(FILENAME_FILTER);</div><div class="line">                <span class="keyword">if</span> (aFiles != <span class="keyword">null</span>) &#123;</div><div class="line">                    list.addAll(Arrays.asList(aFiles));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * puts files into the FilterLoader. The FilterLoader will only addd new or changed filters</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> aFiles a List&lt;File&gt;</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     * <span class="doctag">@throws</span> InstantiationException</div><div class="line">     * <span class="doctag">@throws</span> IllegalAccessException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">processGroovyFiles</span><span class="params">(List&lt;File&gt; aFiles)</span> <span class="keyword">throws</span> Exception, InstantiationException, IllegalAccessException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (File file : aFiles) &#123;</div><div class="line">            <span class="comment">//更新则通过FilterLoader.putFilter()置入FilterRegistr</span></div><div class="line">            FilterLoader.getInstance().putFilter(file);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//每次轮询，处理目录内的所有*.groovy文件，即调用FilterLoader.getInstance().putFilter(file);</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manageFiles</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IllegalAccessException, InstantiationException </span>&#123;</div><div class="line">        List&lt;File&gt; aFiles = getFiles();</div><div class="line">        processGroovyFiles(aFiles);</div><div class="line">    &#125;  </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-2-FilterLoader"><a href="#2-2-FilterLoader" class="headerlink" title="2.2 FilterLoader"></a>2.2 FilterLoader</h3><p>   com.netflix.zuul.FilterLoader，编译、加载filter文件，并且检查源文件是否有变更，除此之外，它还按照filterType组织并维护List<zuulfilter></zuulfilter></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterLoader</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">static</span> FilterLoader INSTANCE = <span class="keyword">new</span> FilterLoader();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(FilterLoader.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Long&gt; filterClassLastModified = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Long&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, String&gt; filterClassCode = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, String&gt; filterCheck = <span class="keyword">new</span> ConcurrentHashMap&lt;String, String&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, List&lt;ZuulFilter&gt;&gt; hashFiltersByType = <span class="keyword">new</span> ConcurrentHashMap&lt;String, List&lt;ZuulFilter&gt;&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">private</span> FilterRegistry filterRegistry = FilterRegistry.instance();</div><div class="line"></div><div class="line">    <span class="keyword">static</span> DynamicCodeCompiler COMPILER;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> FilterFactory FILTER_FACTORY = <span class="keyword">new</span> DefaultFilterFactory();</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets a Dynamic Code Compiler</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> compiler</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCompiler</span><span class="params">(DynamicCodeCompiler compiler)</span> </span>&#123;</div><div class="line">        COMPILER = compiler;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// overidden by tests</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilterRegistry</span><span class="params">(FilterRegistry r)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.filterRegistry = r;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets a FilterFactory</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> factory</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFilterFactory</span><span class="params">(FilterFactory factory)</span> </span>&#123;</div><div class="line">        FILTER_FACTORY = factory;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@return</span> Singleton FilterLoader</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FilterLoader <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Given source and name will compile and store the filter if it detects that the filter code has changed or</div><div class="line">     * the filter doesn't exist. Otherwise it will return an instance of the requested ZuulFilter</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> sCode source code</div><div class="line">     * <span class="doctag">@param</span> sName name of the filter</div><div class="line">     * <span class="doctag">@return</span> the ZuulFilter</div><div class="line">     * <span class="doctag">@throws</span> IllegalAccessException</div><div class="line">     * <span class="doctag">@throws</span> InstantiationException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> ZuulFilter <span class="title">getFilter</span><span class="params">(String sCode, String sName)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (filterCheck.get(sName) == <span class="keyword">null</span>) &#123;</div><div class="line">            filterCheck.putIfAbsent(sName, sName);</div><div class="line">            <span class="keyword">if</span> (!sCode.equals(filterClassCode.get(sName))) &#123;</div><div class="line">                LOG.info(<span class="string">"reloading code "</span> + sName);</div><div class="line">                filterRegistry.remove(sName);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ZuulFilter filter = filterRegistry.get(sName);</div><div class="line">        <span class="keyword">if</span> (filter == <span class="keyword">null</span>) &#123;</div><div class="line">            Class clazz = COMPILER.compile(sCode, sName);</div><div class="line">            <span class="keyword">if</span> (!Modifier.isAbstract(clazz.getModifiers())) &#123;</div><div class="line">                filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> filter;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@return</span> the total number of Zuul filters</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterInstanceMapSize</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> filterRegistry.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * From a file this will read the ZuulFilter source code, compile it, and add it to the list of current filters</div><div class="line">     * a true response means that it was successful.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> file</div><div class="line">     * <span class="doctag">@return</span> true if the filter in file successfully read, compiled, verified and added to Zuul</div><div class="line">     * <span class="doctag">@throws</span> IllegalAccessException</div><div class="line">     * <span class="doctag">@throws</span> InstantiationException</div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putFilter</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String sName = file.getAbsolutePath() + file.getName();</div><div class="line">        <span class="comment">// 如果文件在上次加载后发生了变化，重新编译加载</span></div><div class="line">        <span class="keyword">if</span> (filterClassLastModified.get(sName) != <span class="keyword">null</span> &amp;&amp; (file.lastModified() != filterClassLastModified.get(sName))) &#123;</div><div class="line">            LOG.debug(<span class="string">"reloading filter "</span> + sName);</div><div class="line">            filterRegistry.remove(sName);</div><div class="line">        &#125;</div><div class="line">        ZuulFilter filter = filterRegistry.get(sName);</div><div class="line">        <span class="keyword">if</span> (filter == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 编译、加载文件</span></div><div class="line">            Class clazz = COMPILER.compile(file);</div><div class="line">            <span class="keyword">if</span> (!Modifier.isAbstract(clazz.getModifiers())) &#123;</div><div class="line">                filter = (ZuulFilter) FILTER_FACTORY.newInstance(clazz);</div><div class="line">                <span class="comment">// 清空filter.filterType()类型的List&lt;Filter&gt;缓存，重新构建</span></div><div class="line">                List&lt;ZuulFilter&gt; list = hashFiltersByType.get(filter.filterType());</div><div class="line">                <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//重新构建某种类型Filter的List</span></div><div class="line">                    hashFiltersByType.remove(filter.filterType()); <span class="comment">//rebuild this list</span></div><div class="line">                &#125;</div><div class="line">                <span class="comment">//向Filter Registry放入新的Filter</span></div><div class="line">                filterRegistry.put(file.getAbsolutePath() + file.getName(), filter);</div><div class="line">                filterClassLastModified.put(sName, file.lastModified());</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据Filter类型返回同一类型的Filter</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> filterType</div><div class="line">     * <span class="doctag">@return</span> a List&lt;ZuulFilter&gt;</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;ZuulFilter&gt; <span class="title">getFiltersByType</span><span class="params">(String filterType)</span> </span>&#123;</div><div class="line"></div><div class="line">        List&lt;ZuulFilter&gt; list = hashFiltersByType.get(filterType);</div><div class="line">        <span class="keyword">if</span> (list != <span class="keyword">null</span>) <span class="keyword">return</span> list;</div><div class="line"></div><div class="line">        list = <span class="keyword">new</span> ArrayList&lt;ZuulFilter&gt;();</div><div class="line"></div><div class="line">        Collection&lt;ZuulFilter&gt; filters = filterRegistry.getAllFilters();</div><div class="line">        <span class="keyword">for</span> (Iterator&lt;ZuulFilter&gt; iterator = filters.iterator(); iterator.hasNext(); ) &#123;</div><div class="line">            ZuulFilter filter = iterator.next();</div><div class="line">            <span class="keyword">if</span> (filter.filterType().equals(filterType)) &#123;</div><div class="line">                list.add(filter);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//根据</span></div><div class="line">        Collections.sort(list); </div><div class="line"></div><div class="line">        hashFiltersByType.putIfAbsent(filterType, list);</div><div class="line">        <span class="keyword">return</span> list;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>把Groovy源码进行编译并加载进jvm里。</p></blockquote><h3 id="2-3-FilterRegistry"><a href="#2-3-FilterRegistry" class="headerlink" title="2.3 FilterRegistry"></a>2.3 FilterRegistry</h3><p> com.netflix.zuul.filters.FilterRegistry可以理解为就是用ConcurrentHashMap，在运行过程中存储Filter的数据结构，进行Put或Revome操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FilterRegistry INSTANCE = <span class="keyword">new</span> FilterRegistry();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> FilterRegistry <span class="title">instance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ZuulFilter&gt; filters = <span class="keyword">new</span> ConcurrentHashMap&lt;String, ZuulFilter&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FilterRegistry</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ZuulFilter <span class="title">remove</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filters.remove(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ZuulFilter <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filters.get(key);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ZuulFilter filter)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.filters.putIfAbsent(key, filter);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filters.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ZuulFilter&gt; <span class="title">getAllFilters</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.filters.values();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-4-DynamicCodeCompiler"><a href="#2-4-DynamicCodeCompiler" class="headerlink" title="2.4 DynamicCodeCompiler"></a>2.4 DynamicCodeCompiler</h3><p> com.netflix.zuul.DynamicCodeCompiler.java,主要是一个接口，定义两种加载编译源码的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DynamicCodeCompiler</span> </span>&#123;</div><div class="line">    <span class="function">Class <span class="title">compile</span><span class="params">(String sCode, String sName)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">    <span class="function">Class <span class="title">compile</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="三-参考文章"><a href="#三-参考文章" class="headerlink" title="三.参考文章"></a>三.参考文章</h2><p> <a href="http://microservices.io/patterns/apigateway.html" target="_blank" rel="external">http://microservices.io/patterns/apigateway.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;摘要&lt;/strong&gt;:  接着上一篇《Spring Cloud Zuul遗失的世界(二)》，本文主要介绍Netflix Zuul core模块的Filter链的设计和Fifter Loader和Filter Manager相关代码的设计与分析。&lt;/p&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Zuul遗失的世界(二)</title>
    <link href="http://lvqingyan.com/sc-zuul-s2/"/>
    <id>http://lvqingyan.com/sc-zuul-s2/</id>
    <published>2017-08-14T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>摘要</strong>:  接着上一篇《Spring Cloud Zuul遗失的世界(一)》，ZuulController继承了ServletWrappingController，将当前应用中的ZuulServlet直接包装为一个Controller，暴露为入口访问，在本篇文章中介绍etflix-zuul-core的代码Zuul的执行的生命周期等。</p><h2 id="一-Netflix-zuul-core源码分析"><a href="#一-Netflix-zuul-core源码分析" class="headerlink" title="一.Netflix zuul core源码分析"></a>一.Netflix zuul core源码分析</h2><p>com.netflix.zuul.http.ZuulServlet是ZuulFilter链执行的入口，通过service方法，提取请求到RequestContext，然后通过调用ZuulRunner，依次按顺序执行每种类型的Filter，完成整个Filter的生命周期，架构图如下所示。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2279594-2e6134e4743b0483.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zuul.png"></p><h3 id="1-1-ZuulServlet代码分析"><a href="#1-1-ZuulServlet代码分析" class="headerlink" title="1.1 ZuulServlet代码分析"></a>1.1 ZuulServlet代码分析</h3><p><a href="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" alt="zuul-request-lifecycle"></a></p><p>在ZuulConfiguration中点击com.netflix.zuul.http.ZuulServlet打开代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3374242278843351500L</span>;</div><div class="line">    <span class="keyword">private</span> ZuulRunner zuulRunner;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init(config);</div><div class="line"></div><div class="line">        String bufferReqsStr = config.getInitParameter(<span class="string">"buffer-requests"</span>);</div><div class="line">        <span class="keyword">boolean</span> bufferReqs = bufferReqsStr != <span class="keyword">null</span> &amp;&amp; bufferReqsStr.equals(<span class="string">"true"</span>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        zuulRunner = <span class="keyword">new</span> ZuulRunner(bufferReqs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//调用zuulRunner.init(servletRequest, servletResponse)进行请求上下文的传递</span></div><div class="line">            init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</div><div class="line"></div><div class="line">            <span class="comment">// Marks this request as having passed through the "Zuul engine", as opposed to servlets</span></div><div class="line">            <span class="comment">// explicitly bound in web.xml, for which requests will not have the same data attached</span></div><div class="line">            RequestContext context = RequestContext.getCurrentContext();</div><div class="line">            context.setZuulEngineRan();</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                preRoute();</div><div class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                error(e);</div><div class="line">                postRoute();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                route();</div><div class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                error(e);</div><div class="line">                postRoute();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postRoute();</div><div class="line">            &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                error(e);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNHANDLED_EXCEPTION_"</span> + e.getClass().getName()));</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            RequestContext.getCurrentContext().unset();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行 "post" ZuulFilters</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> ZuulException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">        zuulRunner.postRoute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行 "route" filters</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> ZuulException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">route</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">        zuulRunner.route();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行 "pre" filters</div><div class="line">     *</div><div class="line">     * <span class="doctag">@throws</span> ZuulException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preRoute</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</div><div class="line">        zuulRunner.preRoute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * initializes request</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> servletRequest</div><div class="line">     * <span class="doctag">@param</span> servletResponse</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</div><div class="line">        zuulRunner.init(servletRequest, servletResponse);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * sets error context info and executes "error" filters</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> e</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(ZuulException e)</span> </span>&#123;</div><div class="line">        RequestContext.getCurrentContext().setThrowable(e);</div><div class="line">        zuulRunner.error();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>如上所示，ZuulServlet其实就是一个Servlet，service方法包含了Zuul的整个生命周期。</p></blockquote><h4 id="1-1-1-ZuulServlet-init代码拆解分析"><a href="#1-1-1-ZuulServlet-init代码拆解分析" class="headerlink" title="1.1.1 ZuulServlet init代码拆解分析"></a>1.1.1 ZuulServlet init代码拆解分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//init() - 注册一个ZuulRunner用于调用整个filter 链</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</div><div class="line">        zuulRunner.init(servletRequest, servletResponse);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h4 id="1-1-2-ZuulServlet-service代码分析"><a href="#1-1-2-ZuulServlet-service代码分析" class="headerlink" title="1.1.2 ZuulServlet service代码分析"></a>1.1.2 ZuulServlet service代码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 调用init将req,res置入上下文.获取并标记上下文此session已经通过进入</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">         init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</div><div class="line"></div><div class="line">         <span class="comment">// Marks this request as having passed through the "Zuul engine", as opposed to servlets</span></div><div class="line">         <span class="comment">// explicitly bound in web.xml, for which requests will not have the same data attached</span></div><div class="line">         RequestContext context = RequestContext.getCurrentContext();</div><div class="line">         context.setZuulEngineRan();</div><div class="line"></div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             preRoute();</div><div class="line">         &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">             error(e);</div><div class="line">             postRoute();</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             route();</div><div class="line">         &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">             error(e);</div><div class="line">             postRoute();</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             postRoute();</div><div class="line">         &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">             error(e);</div><div class="line">             <span class="keyword">return</span>;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">         error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNHANDLED_EXCEPTION_"</span> + e.getClass().getName()));</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         RequestContext.getCurrentContext().unset();</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure><blockquote><p>正常情况下，请求只经过pre -&gt; route -&gt; post。<br>两层try…catch，内层只捕获ZuulException，而其他异常由外层捕获。<br>内层3个try…catch语句，只有pre,route抛出ZuulException时，才会执行errror，再执行post。而当post(88行)抛出ZuulException后，只会执行error。<br>外层捕获其他异常(内层try语句块中抛出的非ZuulException异常以及内层catch语句中抛出的所有异常)后，将HTTP状态码设置为500，同时交给error处理。<br>整个流程的终点有两个：post及error；而非只有post一个。</p></blockquote><h3 id="1-2-Zuul的请求上下文-RequestContext"><a href="#1-2-Zuul的请求上下文-RequestContext" class="headerlink" title="1.2 Zuul的请求上下文 RequestContext"></a>1.2 Zuul的请求上下文 RequestContext</h3><p> com.netflix.zuul.context.RequestContext继承了ConcurrentHashMap<string, object="">，是Zuul Filter生命周期中处理http请求上下文,是一个threadlocal的Map.</string,></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestContext</span> <span class="keyword">extends</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(RequestContext.class);</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Class&lt;? extends RequestContext&gt; contextClass = RequestContext.class;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RequestContext testContext = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;? extends RequestContext&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;RequestContext&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> RequestContext <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">return</span> contextClass.newInstance();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//其余省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-3-ContextLifecycleFilter"><a href="#1-3-ContextLifecycleFilter" class="headerlink" title="1.3  ContextLifecycleFilter"></a>1.3  ContextLifecycleFilter</h3><p> com.netflix.zuul.context.ContextLifecycleFilter是调用链外围finally中remove上文中threadlocal.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLifecycleFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException, ServletException &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            chain.doFilter(req, res);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            RequestContext.getCurrentContext().unset();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-4-Zuul的运行执行器-ZuulRunner"><a href="#1-4-Zuul的运行执行器-ZuulRunner" class="headerlink" title="1.4 Zuul的运行执行器-ZuulRunner"></a>1.4 Zuul的运行执行器-ZuulRunner</h3><p>com.netflix.zuul.ZuulRunner，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulRunner</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> bufferRequests;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates a new &lt;code&gt;ZuulRunner&lt;/code&gt; instance.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZuulRunner</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.bufferRequests = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> bufferRequests - whether to wrap the ServletRequest in HttpServletRequestWrapper and buffer the body.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZuulRunner</span><span class="params">(<span class="keyword">boolean</span> bufferRequests)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.bufferRequests = bufferRequests;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * sets HttpServlet request and HttpResponse</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> servletRequest</div><div class="line">     * <span class="doctag">@param</span> servletResponse</div><div class="line">     */</div><div class="line">    <span class="comment">// ZuulRunner内传入的req/res就会被替换为wrapper类增强功能:</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HttpServletRequest servletRequest, HttpServletResponse servletResponse)</span> </span>&#123;</div><div class="line"></div><div class="line">        RequestContext ctx = RequestContext.getCurrentContext();</div><div class="line">        <span class="keyword">if</span> (bufferRequests) &#123;</div><div class="line">            ctx.setRequest(<span class="keyword">new</span> HttpServletRequestWrapper(servletRequest));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ctx.setRequest(servletRequest);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ctx.setResponse(<span class="keyword">new</span> HttpServletResponseWrapper(servletResponse));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>com.netflix.zuul.filters.ZuulServletFilter跟跟ZuulServlet是同一份代码.<br>com.netflix.zuul.monitoring，预留了CounterFactory与TracerFactory的接口，用来扩展实现counter与timer.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;strong&gt;摘要&lt;/strong&gt;:  接着上一篇《Spring Cloud Zuul遗失的世界(一)》，ZuulController继承了ServletWrappingController，将当前应用中的ZuulServlet直接包装为一个Controller，暴露为入口访问，在本篇文章中介绍etflix-zuul-core的代码Zuul的执行的生命周期等。&lt;/p&gt;
&lt;h2 id=&quot;一-Netflix-zuul-core源码分析&quot;&gt;&lt;a href=&quot;#一-Netflix-zuul-core源码分析&quot; class=&quot;headerlink&quot; title=&quot;一.Netflix zuul core源码分析&quot;&gt;&lt;/a&gt;一.Netflix zuul core源码分析&lt;/h2&gt;&lt;p&gt;com.netflix.zuul.http.ZuulServlet是ZuulFilter链执行的入口，通过service方法，提取请求到RequestContext，然后通过调用ZuulRunner，依次按顺序执行每种类型的Filter，完成整个Filter的生命周期，架构图如下所示。&lt;/p&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Zuul遗失的世界(一)</title>
    <link href="http://lvqingyan.com/sc-zuul-s1/"/>
    <id>http://lvqingyan.com/sc-zuul-s1/</id>
    <published>2017-08-13T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>摘要</strong>:  Zuul作为java网关届的鼻祖，2016年自研网关中间件的时候，对其源码看了很多次，经过两大互联网公司中间件的洗礼之后，目前轮到自己设计一个网关中间件纳管Spring Cloud。最近抽空把自己的理解，备注一下。由于Spring cloud整合Zuul的代码过多。本文主要介绍Spring Cloud对Netflix Zuul高度抽象封装整合部分。即spring-cloud-netflix-core的代码。</p> <a id="more"></a><h2 id="一-Spring-Cloud-Zuul源码分析"><a href="#一-Spring-Cloud-Zuul源码分析" class="headerlink" title="一.Spring Cloud Zuul源码分析"></a>一.Spring Cloud Zuul源码分析</h2><h3 id="1-1-EnableZuulProxy与-EnableZuulServer"><a href="#1-1-EnableZuulProxy与-EnableZuulServer" class="headerlink" title="1.1 @EnableZuulProxy与@EnableZuulServer"></a>1.1 @EnableZuulProxy与@EnableZuulServer</h3><p>如下主应用程序代码所示，我们使用Spring Cloud Zuul只需要加上@EnableZuulProxy或@EnableZuulServer两种注解就可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableZuulProxy</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudZuulApplication</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(SpringCloudZuulApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>@EnableZuulProxy与@EnableZuulServer,<br>@EnableZuulServer - 普通Zuul Server,只支持基本的route与filter功能.<br>@EnableZuulProxy - 普通Zuul Server+服务发现与熔断等功能的增强版,具有反向代理功能.</p></blockquote><h3 id="1-2-EnableZuulProxy注解入口"><a href="#1-2-EnableZuulProxy注解入口" class="headerlink" title="1.2 @EnableZuulProxy注解入口"></a>1.2 @EnableZuulProxy注解入口</h3><p> 点开注解@EnableZuulProxy，进入到org.springframework.cloud.netflix.zuul.EnableZuulProxy，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableCircuitBreaker</span></div><div class="line"><span class="meta">@EnableDiscoveryClient</span></div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Import</span>(ZuulProxyConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableZuulProxy &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-3-ZuulProxyConfiguration代码"><a href="#1-3-ZuulProxyConfiguration代码" class="headerlink" title="1.3 ZuulProxyConfiguration代码"></a>1.3 ZuulProxyConfiguration代码</h3><p>@Import(ZuulProxyConfiguration.class)，查看导入的类org.springframework.cloud.netflix.zuul.ZuulProxyConfiguration，如下所示，可以看到org.springframework.cloud.netflix.zuul.ZuulProxyConfiguration,继承了上文的ZuulConfiguration,新增了服务与实例等概念，核心重要代码已经加入注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Import</span>(&#123; RibbonCommandFactoryConfiguration.RestClientRibbonConfiguration.class,</div><div class="line">RibbonCommandFactoryConfiguration.OkHttpRibbonConfiguration.class,</div><div class="line">RibbonCommandFactoryConfiguration.HttpClientRibbonConfiguration.class &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulProxyConfiguration</span> <span class="keyword">extends</span> <span class="title">ZuulConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</div><div class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line"><span class="keyword">private</span> List&lt;RibbonRequestCustomizer&gt; requestCustomizers = Collections.emptyList();</div><div class="line"></div><div class="line">    <span class="comment">// DiscoveryClient肩负着从Eureka中获取服务列表,获取对应实例的功能</span></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> DiscoveryClient discovery;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> ServiceRouteMapper serviceRouteMapper;</div><div class="line">   </div><div class="line">    <span class="comment">// zuulFeature 依然是将Zuul标识为Discovery模式.</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> HasFeatures <span class="title">zuulFeature</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> HasFeatures.namedFeature(<span class="string">"Zuul (Discovery)"</span>, ZuulProxyConfiguration.class);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line"><span class="meta">@ConditionalOnMissingBean</span>(DiscoveryClientRouteLocator.class)</div><div class="line"><span class="function"><span class="keyword">public</span> DiscoveryClientRouteLocator <span class="title">discoveryRouteLocator</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> DiscoveryClientRouteLocator(<span class="keyword">this</span>.server.getServletPrefix(), <span class="keyword">this</span>.discovery, <span class="keyword">this</span>.zuulProperties,</div><div class="line"><span class="keyword">this</span>.serviceRouteMapper);</div><div class="line">&#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 依然是注册了这么个ApplicationEvent来触发上文中的dirty状态.</span></div><div class="line">    <span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ApplicationListener&lt;ApplicationEvent&gt; <span class="title">zuulDiscoveryRefreshRoutesListener</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> ZuulDiscoveryRefreshListener();</div><div class="line">&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulDiscoveryRefreshListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> HeartbeatMonitor monitor = <span class="keyword">new</span> HeartbeatMonitor();</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> ZuulHandlerMapping zuulHandlerMapping;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> InstanceRegisteredEvent) &#123;</div><div class="line">reset();</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ParentHeartbeatEvent) &#123;</div><div class="line">ParentHeartbeatEvent e = (ParentHeartbeatEvent) event;</div><div class="line">resetIfNeeded(e.getValue());</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> HeartbeatEvent) &#123;</div><div class="line">HeartbeatEvent e = (HeartbeatEvent) event;</div><div class="line">resetIfNeeded(e.getValue());</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetIfNeeded</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.monitor.update(value)) &#123;</div><div class="line">reset();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">this</span>.zuulHandlerMapping.setDirty(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">//其余省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>DiscoveryClientRouteLocator类中的locateRoutes()方法，将path与上文的ZuulRoute通过DiscoveryClientRouteLocator.locateRoutes()的对应在一起.<br>点击查看其父类，org.springframework.cloud.netflix.zuul.ZuulConfiguration,如下我们可以看到Netflix的Zuul-core的入口，ZuulServlet。</p></blockquote><h3 id="1-4-DiscoveryClientRouteLocator中locateRoutes"><a href="#1-4-DiscoveryClientRouteLocator中locateRoutes" class="headerlink" title="1.4 DiscoveryClientRouteLocator中locateRoutes"></a>1.4 DiscoveryClientRouteLocator中locateRoutes</h3><p>DiscoveryClientRouteLocator类中的locateRoutes的大概流程</p><ol><li>将上文SimpleRouteLocator中解析出来的Route列表灌入内部的LinkedHashMap</li><li>抽取Route自带的serviceId,将其作为key,形成一个<code>staticServices</code>的map</li><li>遍历DiscoveryClient拿到的serviceId列表,匹配正则形式定义的serviceId并将对应的ZuulRoute与之对应</li><li>调整LinkedHashMap内路由顺序,将/**挪到最后</li><li>微调map内容,将key值加上/或者自定义prefix</li></ol><h3 id="1-5-ZuulConfiguration"><a href="#1-5-ZuulConfiguration" class="headerlink" title="1.5 ZuulConfiguration"></a>1.5 ZuulConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123; ZuulProperties.class &#125;)</div><div class="line"><span class="meta">@ConditionalOnClass</span>(ZuulServlet.class)</div><div class="line"><span class="comment">// Make sure to get the ServerProperties from the same place as a normal web app would</span></div><div class="line"><span class="meta">@Import</span>(ServerPropertiesAutoConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//zuulProperties 对应配置文件的内容</span></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">protected</span> ZuulProperties zuulProperties;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">protected</span> ServerProperties server;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line"><span class="keyword">private</span> ErrorController errorController;</div><div class="line"></div><div class="line">    <span class="comment">//告知actuator监控当前模式:Simple/Discovery</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> HasFeatures <span class="title">zuulFeature</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> HasFeatures.namedFeature(<span class="string">"Zuul (Discovery)"</span>, ZuulProxyConfiguration.class);</div><div class="line">&#125;</div><div class="line">    </div><div class="line">   <span class="comment">//通过继承ServletWrappingController接管了上文定义的ZuulServlet,因此ZuulController就是Zuul的入口</span></div><div class="line">   <span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ZuulController <span class="title">zuulController</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> ZuulController();</div><div class="line">&#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    *ZuulHandlerMapping,响应器模式,其实目前就是把所有路径的请求导入到ZuulController上.&lt;/br&gt;</div><div class="line">    *另外的功效是当觉察RouteLocator路由表变更,则更新自己dirty状态,重新注册所有Route到ZuulController.</div><div class="line">    */</div><div class="line">   <span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ZuulHandlerMapping <span class="title">zuulHandlerMapping</span><span class="params">(RouteLocator routes)</span> </span>&#123;</div><div class="line">ZuulHandlerMapping mapping = <span class="keyword">new</span> ZuulHandlerMapping(routes, zuulController());</div><div class="line">mapping.setErrorController(<span class="keyword">this</span>.errorController);</div><div class="line"><span class="keyword">return</span> mapping;</div><div class="line">&#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">   * ZuulRefreshListener,</div><div class="line">   */</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulRefreshListener</span></span></div><div class="line"><span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEvent</span>&gt; &#123;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> ZuulHandlerMapping zuulHandlerMapping;</div><div class="line"></div><div class="line"><span class="keyword">private</span> HeartbeatMonitor heartbeatMonitor = <span class="keyword">new</span> HeartbeatMonitor();</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</div><div class="line">            <span class="comment">// Simple模式下注册RoutesRefreshedEvent,解析配置文件,</span></div><div class="line">            <span class="comment">// 维护路由表并监听变化,将请求都导向ZuulController去历经filters</span></div><div class="line"><span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextRefreshedEvent</div><div class="line">|| event <span class="keyword">instanceof</span> RefreshScopeRefreshedEvent</div><div class="line">|| event <span class="keyword">instanceof</span> RoutesRefreshedEvent) &#123;</div><div class="line"><span class="keyword">this</span>.zuulHandlerMapping.setDirty(<span class="keyword">true</span>);</div><div class="line">&#125; </div><div class="line">            <span class="comment">// Endpoint模式下又添加了HeartbeatEvent</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> HeartbeatEvent) &#123;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.heartbeatMonitor.update(((HeartbeatEvent) event).getValue())) &#123;</div><div class="line"><span class="keyword">this</span>.zuulHandlerMapping.setDirty(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">   <span class="comment">//其余省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>从ZuulConfiguration中可以拿到Simple模式下所有bean.</p></blockquote><h3 id="1-6-ZuulController整合访问的桥梁"><a href="#1-6-ZuulController整合访问的桥梁" class="headerlink" title="1.6  ZuulController整合访问的桥梁"></a>1.6  ZuulController整合访问的桥梁</h3><p> ZuulController继承了ServletWrappingController，将当前应用中的某个Servlet直接包装为一个Controller，所有到ServletWrappingController的请求实际上是由它内部所包装的这个Servlet 实例来处理的，也就是说内部封装的Servlet实例并不对外开放，对于程序的其他范围是不可见的，适配所有的HTTP请求到内部封装的Servlet实例进行处理。它通常用于对已存的Servlet的逻辑重用上。其实这也就是Spring Cloud与Netflix Zuul整合的关键点。</p><p> <img src="/images/sc-study/zuulc.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulController</span> <span class="keyword">extends</span> <span class="title">ServletWrappingController</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZuulController</span><span class="params">()</span> </span>&#123;</div><div class="line">setServletClass(ZuulServlet.class);</div><div class="line">setServletName(<span class="string">"zuul"</span>);</div><div class="line">setSupportedMethods((String[]) <span class="keyword">null</span>); <span class="comment">// Allow all</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">// We don't care about the other features of the base class, just want to</span></div><div class="line"><span class="comment">// handle the request</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">super</span>.handleRequestInternal(request, response);</div><div class="line">&#125;</div><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line"><span class="comment">// @see com.netflix.zuul.context.ContextLifecycleFilter.doFilter</span></div><div class="line">RequestContext.getCurrentContext().unset();</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1-7-ZuulProperties"><a href="#1-7-ZuulProperties" class="headerlink" title="1.7 ZuulProperties"></a>1.7 ZuulProperties</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">zuul.ignoredServices</div><div class="line">zuul.routes</div><div class="line"></div><div class="line">zuul:</div><div class="line">  ignored-services:</div><div class="line">  routes:</div></pre></td></tr></table></figure><blockquote><p>其中routes对应着内部类定义ZuulRoute.</p></blockquote><h3 id="1-8-其它补充说明"><a href="#1-8-其它补充说明" class="headerlink" title="1.8 其它补充说明"></a>1.8 其它补充说明</h3><p>org.springframework.cloud.netflix.zuul.filters.Route,是Spring Cloud 的抽象,就是上文<code>RouteLocator</code>潜移默化转换的部分. </p><p>org.springframework.cloud.netflix.zuul.ZuulFilterInitializer,实现<code>ServletContextListener</code>,servlet内容来自tomcat。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;摘要&lt;/strong&gt;:  Zuul作为java网关届的鼻祖，2016年自研网关中间件的时候，对其源码看了很多次，经过两大互联网公司中间件的洗礼之后，目前轮到自己设计一个网关中间件纳管Spring Cloud。最近抽空把自己的理解，备注一下。由于Spring cloud整合Zuul的代码过多。本文主要介绍Spring Cloud对Netflix Zuul高度抽象封装整合部分。即spring-cloud-netflix-core的代码。&lt;/p&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>《Spring Cloud中国社区上海网关专题会议》</title>
    <link href="http://lvqingyan.com/sc-gw/"/>
    <id>http://lvqingyan.com/sc-gw/</id>
    <published>2017-08-05T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>网关在微服务中的地位尤其重要，如果网关挂了或者出现任何抖动，用户请求的流量将会损耗，将会造成巨大的损失。因此Spring Cloud中国社区联合上海秦苍科技，走进企业畅聊Spring Cloud实战经验，以及网关经验。</p><h2 id="一-会议内容"><a href="#一-会议内容" class="headerlink" title="一.会议内容"></a>一.会议内容</h2><p>1.主题《Spring Cloud中国社区上海网关专题》<br>2.时间:2017年8月20，会议方式:闭门会议<br>3.地点:上海市浦东新区峨山路91弄陆家嘴软件园9号楼（北楼）8楼<br>4.主办方Spring Cloud中国社区+上海秦苍科技<br>5.预计参会人数: 40-50人之间，先到先得，名额满关闭报名通道。<br>6.分享方式(分享人分享+讨论+头脑风暴)</p><a id="more"></a><h2 id="二-分享内容"><a href="#二-分享内容" class="headerlink" title="二.分享内容"></a>二.分享内容</h2><ol><li><p>Spring Cloud Zuul与GPRC服务治理体系整合，来源于Spring Cloud中国社区开源项目saluki。</p></li><li><p>基于Netty自研网关中间件纳管Spring Cloud。</p></li><li><p>如何压测和自动化测试网关</p></li><li><p>上海秦苍科技(买单侠)Spring Cloud生产实战分享(包括Zuul)</p></li></ol><blockquote><p>PS:分享嘉宾保密，闭门会议，您懂得。</p></blockquote><h2 id="三-报名方式"><a href="#三-报名方式" class="headerlink" title="三.报名方式"></a>三.报名方式</h2><p>扫支付宝二维码，支付完毕之后，加管理员微信Software_King，进入微信群，同时会进入Spring Cloud中国社区VIP会员群。<br><img src="/images/sc-gwz.png" width="250px" height="350px"></p><blockquote><p>报名费-&gt;用于茶歇+请分享嘉宾喝咖啡</p></blockquote>]]></content>
    
    <summary type="html">
    
      网关在微服务中的地位尤其重要，如果网关挂了或者出现任何抖动，用户请求的流量将会损耗，将会造成巨大的损失。因此Spring Cloud中国社区联合上海秦苍科技，走进企业畅聊Spring Cloud实战经验，以及网关经验。
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/tags/Spring-Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Gateway离开孵化器的变化</title>
    <link href="http://lvqingyan.com/sc-gateway/"/>
    <id>http://lvqingyan.com/sc-gateway/</id>
    <published>2017-07-08T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>: Spring Cloud对Netflix的Zuul进行封装之后，Spring Cloud Zuul作为Spring Cloud的网关一直被大家使用用至今，在Spring Cloud的核心项目开发者<code>Spencergibb</code>的一篇博客<a href="https://spencergibb.netlify.com/preso/detroit-cf-api-gateway-2017-03/#/" target="_blank" rel="external">The API Gateway is Dead! Long Live the API Gateway!</a>中介绍了Zuul，Zuul 2以及为什么会有Spring Cloud Gateway,大家有兴趣可以看一下。本文将会对spring-cloud-gateway-mvc源码进行demo演示和简单分析。</p><h2 id="一-Spring-Cloud-Gateway概况"><a href="#一-Spring-Cloud-Gateway概况" class="headerlink" title="一.Spring Cloud Gateway概况"></a>一.Spring Cloud Gateway概况</h2><h3 id="1-1-什么是Spring-Cloud-GateWay"><a href="#1-1-什么是Spring-Cloud-GateWay" class="headerlink" title="1.1 什么是Spring Cloud GateWay"></a>1.1 什么是Spring Cloud GateWay</h3><p>A Gateway built on Spring Framework 5.0 and Spring Boot 2.0 providing routing and more。</p><blockquote><p>Spring Cloud Gateway是基于Spring 框架5.0版本和Spring Boot 2.0的版本构建，提供路由等功能。</p></blockquote><a id="more"></a><h3 id="1-2-Spring-Cloud-GateWay的功能"><a href="#1-2-Spring-Cloud-GateWay的功能" class="headerlink" title="1.2 Spring Cloud GateWay的功能"></a>1.2 Spring Cloud GateWay的功能</h3><p>Spring Cloud GateWay具有以下特征</p><ul><li>Java 8/Spring 5/Boot 2</li><li>WebFlux/Reactor</li><li>HTTP/2 and Websockets</li><li>Finchley Release Train (Q4 2017)</li></ul><blockquote><p>由于Spring 5.0支持Netty，Http2，而Spring Boot 2.0支持Spring 5.0，因此Spring Cloud Gateway支持Netty和Http2顺理成章。至于2017年Q4季度是否发布完整的Spring Cloud Gateway我们拭目以待。</p></blockquote><h3 id="1-3-Spring-Cloud-GateWay离开孵化器"><a href="#1-3-Spring-Cloud-GateWay离开孵化器" class="headerlink" title="1.3 Spring Cloud GateWay离开孵化器"></a>1.3 Spring Cloud GateWay离开孵化器</h3><p>从2016年12月份以后，在Github上出现了Spring Cloud Gateway的项目，地址为:<a href="https://github.com/spring-cloud-incubator/spring-cloud-gateway" target="_blank" rel="external">https://github.com/spring-cloud-incubator/spring-cloud-gateway</a>,如下图所示。<br><img src="/images/sc-study/sc-gateway01.png" alt=""></p><blockquote><p>Spring Cloud GateWay离开孵化器之后master分支有MVC模块,需要查看完整的其它的模块请切换分支到<a href="https://github.com/spring-cloud/spring-cloud-gateway/tree/2.0.x" target="_blank" rel="external">2.X</a> 。因此在本文不分析core里面的设计和实现,后面将会补一篇文章介绍。</p></blockquote><hr><blockquote><p>2.Spring Cloud Gateway的设计核心代码主要在spring-cloud-gateway-core,但是由于目前离开孵化器之后spring-cloud-gateway-core的代码挪到了<a href="https://github.com/spring-cloud/spring-cloud-gateway/tree/2.0.x" target="_blank" rel="external">2.X</a>中,点击访问会自动转发到<a href="https://github.com/spring-cloud/spring-cloud-gateway" target="_blank" rel="external">https://github.com/spring-cloud/spring-cloud-gateway</a></p></blockquote><p><img src="/images/sc-study/sc-gateway02.png" alt=""><br>如上图所示，目前<code>master分支</code>中gateway没有core和starter，相对而言增加了一个<code>spring-cloud-gateway-mvc</code>模块，在下面章节将会对该模块进行demo和源码分析。</p><h3 id="1-3-用Spring-MVC的方式构建Gateway"><a href="#1-3-用Spring-MVC的方式构建Gateway" class="headerlink" title="1.3 用Spring MVC的方式构建Gateway"></a>1.3 用Spring MVC的方式构建Gateway</h3><h4 id="1-3-1-How-to-Include-Spring-Cloud-Gateway"><a href="#1-3-1-How-to-Include-Spring-Cloud-Gateway" class="headerlink" title="1.3.1 How to Include Spring Cloud Gateway"></a>1.3.1 How to Include Spring Cloud Gateway</h4><p>To include Spring Cloud Gateway in your project add a dependency with group org.springframework.cloud and artifact id spring-cloud-gateway-mvc. See the Spring Cloud Project page for details on setting up your build system with the current Spring Cloud Release Train.</p><blockquote><p>使用spring-cloud-gateway-mvc，只要引入对应的spring-cloud-gateway-mvc的依赖坐标。</p></blockquote><h4 id="1-3-2-Building-a-Gateway-Using-Spring-MVC"><a href="#1-3-2-Building-a-Gateway-Using-Spring-MVC" class="headerlink" title="1.3.2 Building a Gateway Using Spring MVC"></a>1.3.2 Building a Gateway Using Spring MVC</h4><p>Spring Cloud Gateway provides a utility object called ProxyExchange which you can use inside a regular Spring MVC handler as a method parameter. It supports basic downstream HTTP exchanges via methods that mirror the HTTP verbs, or forwarding to a local handler via the forward() method.</p><p>Example (proxying a request to “/test” downstream to a remote server):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@RestController</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewaySampleApplication</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;remote.home&#125;"</span>)</div><div class="line"><span class="keyword">private</span> URI home;</div><div class="line"></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test"</span>)</div><div class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt; proxy(ProxyExchange&lt;Object&gt; proxy) <span class="keyword">throws</span> Exception &#123;</div><div class="line"><span class="keyword">return</span> proxy.uri(home.toString() + <span class="string">"/image/png"</span>).get();</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>Spring Cloud Gateway 提供了一个实用的对象叫ProxyExchange，你可以用它像使用Spring MVC Handler的方式去转发，重定向构建网关。</p></blockquote><p>更多信息参考:<a href="https://github.com/spring-cloud/spring-cloud-gateway/blob/master/docs/src/main/asciidoc/spring-cloud-gateway.adoc" target="_blank" rel="external">https://github.com/spring-cloud/spring-cloud-gateway/blob/master/docs/src/main/asciidoc/spring-cloud-gateway.adoc</a></p><h2 id="二-Spring-Cloud-Gateway的MVC模块源码分析"><a href="#二-Spring-Cloud-Gateway的MVC模块源码分析" class="headerlink" title="二.Spring Cloud Gateway的MVC模块源码分析"></a>二.Spring Cloud Gateway的MVC模块源码分析</h2><h3 id="2-1-构建Spring-Cloud-Gateway的Demo"><a href="#2-1-构建Spring-Cloud-Gateway的Demo" class="headerlink" title="2.1 构建Spring Cloud Gateway的Demo"></a>2.1 构建Spring Cloud Gateway的Demo</h3><p>Spring Cloud Gateway的工程里已经给我提供了一个，spring-cloud-gateway-sample的工程，该工程项目依赖于spring-cloud-gateway-mvc，因此要对其源码分析，只需让才sample 正常work就ok。<br><img src="/images/sc-study/sc-gateway03.png" alt=""></p><blockquote><p>从工程截图来看，和我之前看的core模块来说，mvc模块只是做了个请求的转发。</p></blockquote><h3 id="2-2-Spring-Cloud-Gateway模块源码分析"><a href="#2-2-Spring-Cloud-Gateway模块源码分析" class="headerlink" title="2.2 Spring Cloud Gateway模块源码分析"></a>2.2 Spring Cloud Gateway模块源码分析</h3><p>1.在spring-cloud-gateway-sample中application.yml增加应用名和端口配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="attr"> server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8080</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">sc-gw</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="attr">management:</span></div><div class="line"><span class="attr">  security:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></div><div class="line"><span class="attr">remote:</span></div><div class="line"><span class="attr">  home:</span> <span class="attr">http://httpbin.org</span>  <span class="comment">#请求转发的目标服务Url</span></div></pre></td></tr></table></figure><p>2.org.springframework.cloud.gateway.sample.GatewaySampleApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@RestController</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewaySampleApplication</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;remote.home&#125;"</span>)</div><div class="line"><span class="keyword">private</span> URI home;</div><div class="line"></div><div class="line">  <span class="comment">//该方法需要传递head为x-host=png.abc.org方可调用</span></div><div class="line"><span class="meta">@GetMapping</span>(path=<span class="string">"/test"</span>, headers=<span class="string">"x-host=png.abc.org"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">proxy</span><span class="params">(ProxyExchange&lt;Object&gt; proxy)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="keyword">return</span> proxy.uri(home.toString() + <span class="string">"/image/png"</span>)</div><div class="line">.get(header(<span class="string">"X-TestHeader"</span>, <span class="string">"foobar"</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test2"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">proxyFoos</span><span class="params">(ProxyExchange&lt;Object&gt; proxy)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="keyword">return</span> proxy.uri(home.toString() + <span class="string">"/image/webp"</span>).get(header(<span class="string">"X-AnotherHeader"</span>, <span class="string">"baz"</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> Function&lt;ResponseEntity&lt;Object&gt;, ResponseEntity&lt;Object&gt;&gt; header(String key,</div><div class="line">String value) &#123;</div><div class="line"><span class="keyword">return</span> response -&gt; ResponseEntity.status(response.getStatusCode())</div><div class="line">.headers(response.getHeaders()).header(key, value)</div><div class="line">.body(response.getBody());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">SpringApplication.run(GatewaySampleApplication.class, args);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="2-3-代码分析"><a href="#2-3-代码分析" class="headerlink" title="2.3 代码分析"></a>2.3 代码分析</h3><ul><li>启动GatewaySampleApplication主应用程序，访问<a href="http://localhost:8080/test2,Debug流程如下。" target="_blank" rel="external">http://localhost:8080/test2,Debug流程如下。</a></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test2"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Object&gt; <span class="title">proxyFoos</span><span class="params">(ProxyExchange&lt;Object&gt; proxy)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line"><span class="keyword">return</span> proxy.uri(home.toString() + <span class="string">"/image/webp"</span>).get(header(<span class="string">"X-AnotherHeader"</span>, <span class="string">"baz"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在ProxyExchange.java中的237行代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ProxyExchange&lt;T&gt; <span class="title">uri</span><span class="params">(String uri)</span> </span>&#123;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line"><span class="comment">//将uri:http://httpbin.org/image/webp，new URI对象返回</span></div><div class="line"><span class="keyword">this</span>.uri = <span class="keyword">new</span> URI(uri);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (URISyntaxException e) &#123;</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot create URI"</span>, e);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在RestTemplate.java中的628行doExecute去使用对应的httpClient实现远程调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(URI url, HttpMethod method, RequestCallback requestCallback,</span></span></div><div class="line">ResponseExtractor&lt;T&gt; responseExtractor) <span class="keyword">throws</span> RestClientException &#123;</div><div class="line"></div><div class="line"><span class="keyword">return</span> doExecute(url, method, requestCallback, responseExtractor);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最终调用代码如下图所示,由于源码比较简单，因此有些细节流程略过，有兴趣可以自己跟踪理解。</p><p><img src="/images/sc-study/sc-gateway04.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;: Spring Cloud对Netflix的Zuul进行封装之后，Spring Cloud Zuul作为Spring Cloud的网关一直被大家使用用至今，在Spring Cloud的核心项目开发者&lt;code&gt;Spencergibb&lt;/code&gt;的一篇博客&lt;a href=&quot;https://spencergibb.netlify.com/preso/detroit-cf-api-gateway-2017-03/#/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The API Gateway is Dead! Long Live the API Gateway!&lt;/a&gt;中介绍了Zuul，Zuul 2以及为什么会有Spring Cloud Gateway,大家有兴趣可以看一下。本文将会对spring-cloud-gateway-mvc源码进行demo演示和简单分析。&lt;/p&gt;
&lt;h2 id=&quot;一-Spring-Cloud-Gateway概况&quot;&gt;&lt;a href=&quot;#一-Spring-Cloud-Gateway概况&quot; class=&quot;headerlink&quot; title=&quot;一.Spring Cloud Gateway概况&quot;&gt;&lt;/a&gt;一.Spring Cloud Gateway概况&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是Spring-Cloud-GateWay&quot;&gt;&lt;a href=&quot;#1-1-什么是Spring-Cloud-GateWay&quot; class=&quot;headerlink&quot; title=&quot;1.1 什么是Spring Cloud GateWay&quot;&gt;&lt;/a&gt;1.1 什么是Spring Cloud GateWay&lt;/h3&gt;&lt;p&gt;A Gateway built on Spring Framework 5.0 and Spring Boot 2.0 providing routing and more。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Cloud Gateway是基于Spring 框架5.0版本和Spring Boot 2.0的版本构建，提供路由等功能。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Gateway" scheme="http://lvqingyan.com/tags/Spring-Cloud-Gateway/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Zuul异常处理</title>
    <link href="http://lvqingyan.com/sc-zuul-excpetion/"/>
    <id>http://lvqingyan.com/sc-zuul-excpetion/</id>
    <published>2017-06-24T04:23:31.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到了一个GitHub issue在讨论如何在post类型的zuul filter中设置response body，其中涉及到异常情况下，如何返回一个自定义的response body。正好我在升级spring-cloud，也想弄清楚，spring-cloud-zuul是如何处理异常情况的，所以就仔细看了看这部分的实现细节，现在做个笔记记录下来。</p><a id="more"></a><h2 id="1-zull请求的生命周期图"><a href="#1-zull请求的生命周期图" class="headerlink" title="1.zull请求的生命周期图"></a>1.zull请求的生命周期图</h2><p>关于zuul是如何工作的，这里不再介绍，具体可以参看<a href="https://github.com/Netflix/zuul/wiki/How-it-Works" target="_blank" rel="external">这里</a>。官方给了一个zull请求的生命周期图：</p><p><a href="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" target="_blank" rel="external"><img src="https://camo.githubusercontent.com/4eb7754152028cdebd5c09d1c6f5acc7683f0094/687474703a2f2f6e6574666c69782e6769746875622e696f2f7a75756c2f696d616765732f7a75756c2d726571756573742d6c6966656379636c652e706e67" alt="zuul-request-lifecycle"></a></p><p>上图中，实线表示请求必然经过的路径，而虚线表示可能经过的路径；从这张图中可以看出：</p><ul><li>所有请求都必然按照<code>pre</code>-&gt; <code>route</code> -&gt; <code>post</code>的顺序执行。</li><li><code>post</code>返回response。</li><li>如果<code>pre</code>中有自定义filter，则执行自定义filter。</li><li>如果<code>pre</code>,<code>route</code>,<code>post</code>发生错误则执行<code>error</code>，然后再执行<code>post</code>。</li></ul><p>这张图忽略了很多细节；最明显的就是，自定义的filter可以是<code>pre</code>,<code>route</code>,<code>post</code>,<code>error</code>中的任何一种；其次假如<code>post</code>中发生了异常，执行流程交给<code>error</code>处理完之后，又重新回到<code>post</code>中，会不会又有问题？</p><p>所以还是看看代码比较靠谱。以下基于spring-cloud Dalston.RELEASE做代码分析。</p><p>调试一下，就可以看到请求进入zuul之后的整个调用链，简单来说如下：<code>ZuulServlet#service</code> -&gt; <code>FilterProcessor#processZuulFilter</code> -&gt; <code>ZuulFilter#runFilter</code> -&gt; <code>[Concret]ZuulFilter#run</code>。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h2><h3 id="ZuulServlet-service"><a href="#ZuulServlet-service" class="headerlink" title="ZuulServlet#service"></a>ZuulServlet#service</h3><p>首先找到请求进入zuul filters的入口：<a href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/http/ZuulServlet.java#L64" target="_blank" rel="external">ZuulServlet#service(ServletRequest, ServletResponse)</a>。</p><p>下面抽出这个函数的主干：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">           </div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                preRoute();</div><div class="line">             &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                 error(e);</div><div class="line">                 postRoute();</div><div class="line">                 <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">try</span> &#123;</div><div class="line">                 route();</div><div class="line">             &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                 error(e);</div><div class="line">                 postRoute();</div><div class="line">                 <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">try</span> &#123;</div><div class="line">                 postRoute();</div><div class="line">             &#125; <span class="keyword">catch</span> (ZuulException e) &#123;</div><div class="line">                 error(e);</div><div class="line">                 <span class="keyword">return</span>;</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">             error(<span class="keyword">new</span> ZuulException(e, <span class="number">500</span>, <span class="string">"UNHANDLED_EXCEPTION_"</span> + e.getClass().getName()));</div><div class="line">         &#125;</div></pre></td></tr></table></figure><p>这个函数基本遵从但不完全符合官网给出的生命周期图：</p><ul><li>正常情况下，请求只经过<code>pre</code> -&gt; <code>route</code> -&gt; <code>post</code>。</li><li>两层<code>try...catch</code>，内层只捕获<code>ZuulException</code>，而其他异常由外层捕获。</li><li>内层3个<code>try...catch</code>语句，只有<code>pre</code>,<code>route</code>抛出<code>ZuulException</code>时，才会执行<code>errror</code>，再执行<code>post</code>。而当<code>post</code>(88行)抛出<code>ZuulException</code>后，只会执行<code>error</code>。</li><li>外层捕获其他异常(内层<code>try</code>语句块中抛出的非<code>ZuulException</code>异常以及内层<code>catch</code>语句中抛出的所有异常)后，将HTTP状态码设置为500，同时交给<code>error</code>处理。</li><li>整个流程的终点有两个：<code>post</code>及<code>error</code>；而非只有<code>post</code>一个。</li></ul><p>另外看一下<code>error(ZuulException)</code>这个函数到底做了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(ZuulException e)</span> </span>&#123;</div><div class="line">    RequestContext.getCurrentContext().setThrowable(e);</div><div class="line">    zuulRunner.error();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>异常信息是在这里被加入到<code>RequestContext</code>中的，以供后续的filter使用，然后调用<code>error</code> filters。</p><p>至此我们可以得到一个流程图(感觉还不如代码看得清晰<strong>-_-</strong>!!)：</p><p><a href="https://github.com/lowzj/note-book/blob/master/img/springcloud/sc-ZuulServlet.jpeg" target="_blank" rel="external"><img src="https://github.com/lowzj/note-book/raw/master/img/springcloud/sc-ZuulServlet.jpeg" alt="sc-ZuulServlet"></a></p><h3 id="FilterProcessor-processZuulFilter"><a href="#FilterProcessor-processZuulFilter" class="headerlink" title="FilterProcessor#processZuulFilter"></a>FilterProcessor#processZuulFilter</h3><p><a href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/FilterProcessor.java#L173" target="_blank" rel="external">FilterPreocessor#processZuulFilter</a>，这个函数调用ZuulFilter，并且会将异常重新抛出，如果是非<code>ZuulException</code>的异常，则转为状态码为500的<code>ZuulException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">   </div><div class="line">            Throwable t = <span class="keyword">null</span>;</div><div class="line">   </div><div class="line">            ZuulFilterResult result = filter.runFilter();</div><div class="line">            ExecutionStatus s = result.getStatus();</div><div class="line">   </div><div class="line">            <span class="keyword">switch</span> (s) &#123;</div><div class="line">                <span class="keyword">case</span> FAILED:</div><div class="line">                    t = result.getException();</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">   </div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">throw</span> t;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ZuulException) &#123;</div><div class="line">                <span class="keyword">throw</span> (ZuulException) e;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ZuulException ex = <span class="keyword">new</span> ZuulException(e, <span class="string">"Filter threw Exception"</span>, <span class="number">500</span>, filter.filterType() + <span class="string">":"</span> + filterName);</div><div class="line">                <span class="keyword">throw</span> ex;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>如果ZuulFilter执行失败，即结果状态为<code>FAILED</code>，则从ZuulFilter的执行结果ZuulFilterResult中提取出异常信息(199行)，然后抛出(214)；在<code>catch</code>语句块中，捕获刚才抛出的异常，判断是否为<code>ZuulException</code>，如果是则直接抛出，否则转化为状态为500的<code>ZuulException</code>再抛出。</p><p>看到这里，基本确认的一点是，ZuulFilter中抛出的任何形式的异常，最终都会转化为<code>ZuulException</code>抛给上层调用者，即<code>ZuulServlet#service</code>。但是这里并不是通过<code>try...catch</code>来捕获ZuulFilter执行中抛出的异常，而是从返回结果ZuulFilterResult中直接获取的，这是怎么一回事，需要再看下<code>ZuulFilter#runFilter</code>的实现逻辑。</p><h3 id="ZuulFilter-runFilter"><a href="#ZuulFilter-runFilter" class="headerlink" title="ZuulFilter#runFilter"></a>ZuulFilter#runFilter</h3><p>下面是从<a href="https://github.com/Netflix/zuul/blob/1.x/zuul-core/src/main/java/com/netflix/zuul/ZuulFilter.java#L110" target="_blank" rel="external">ZuulFilter#runFilter()</a>抽取出来的核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ZuulFilterResult zr = <span class="keyword">new</span> ZuulFilterResult();</div><div class="line">    </div><div class="line">                 <span class="keyword">try</span> &#123;</div><div class="line">                     Object res = run();</div><div class="line">                     zr = <span class="keyword">new</span> ZuulFilterResult(res, ExecutionStatus.SUCCESS);</div><div class="line">                 &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                     zr = <span class="keyword">new</span> ZuulFilterResult(ExecutionStatus.FAILED);</div><div class="line">                     zr.setException(e);</div><div class="line">                 &#125;</div><div class="line">    </div><div class="line">         <span class="keyword">return</span> zr;</div></pre></td></tr></table></figure><p>这段代码会调用某个具体的ZuulFilter实现的<code>run</code>方法，如果不抛出异常，则返回状态为<code>ExecutionStatus.SUCCESS</code>的ZuulFilterResult(117行)；若有任何异常，则将返回结果的状态设置为<code>ExecutionStatus.FAILED</code>(120)，同时将异常信息设置到返回结果中(121)。即我们实现一个ZuulFilter，如果不抛出异常，则会被认为是成功的，否则就会被当作失败的。</p><p>结合上面两节的代码分析，ZuulFilter中一旦有异常抛出，必然是(或被转化为)<code>ZuulException</code>，然后必然进入到<code>error</code> filters中处理。由此，我们简化一下上面的流程图：</p><p><a href="https://github.com/lowzj/note-book/blob/master/img/springcloud/sc-ZuulServlet-simple.jpeg" target="_blank" rel="external"><img src="https://github.com/lowzj/note-book/raw/master/img/springcloud/sc-ZuulServlet-simple.jpeg" alt="sc-ZuulServlet-simple"></a></p><h2 id="3-SpringCloud中的SendErrorFilter"><a href="#3-SpringCloud中的SendErrorFilter" class="headerlink" title="3.SpringCloud中的SendErrorFilter"></a>3.SpringCloud中的SendErrorFilter</h2><p>在<code>Dalston.RELEASE</code>之前，spring-cloud-netflix中并不包含<code>error</code>类型的Filter；而处理错误情况的filter为<code>SendErrorFilter</code>，其类型为<code>post</code>，<code>order</code>为0，比<code>SendResponseFilter</code>优先级高(1000)，即更早调用。先来分析一下<code>Dalston.RELEASE</code>之前版本的<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/v1.2.7.RELEASE/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/zuul/filters/post/SendErrorFilter.java#L34" target="_blank" rel="external">SendErrorFilter</a>，下面的代码片段摘自<code>spring-cloud-netflix 1.2.7.RELEASE</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;error.path:/error&#125;"</span>)</div><div class="line">     <span class="keyword">private</span> String errorPath;</div><div class="line">   </div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">         RequestContext ctx = RequestContext.getCurrentContext();</div><div class="line">         <span class="comment">// only forward to errorPath if it hasn't been forwarded to already</span></div><div class="line">         <span class="keyword">return</span> ctx.containsKey(<span class="string">"error.status_code"</span>)</div><div class="line">                 &amp;&amp; !ctx.getBoolean(SEND_ERROR_FILTER_RAN, <span class="keyword">false</span>);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   </div><div class="line">             <span class="keyword">int</span> statusCode = (Integer) ctx.get(<span class="string">"error.status_code"</span>);</div><div class="line">             request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>, statusCode);</div><div class="line">   </div><div class="line">             Object e = ctx.get(<span class="string">"error.exception"</span>);</div><div class="line">             request.setAttribute(<span class="string">"javax.servlet.error.exception"</span>, e);</div><div class="line">   </div><div class="line">             String message = (String) ctx.get(<span class="string">"error.message"</span>);</div><div class="line">             request.setAttribute(<span class="string">"javax.servlet.error.message"</span>, message);</div><div class="line">   </div><div class="line">             RequestDispatcher dispatcher = request.getRequestDispatcher(</div><div class="line">                     <span class="keyword">this</span>.errorPath);</div><div class="line">   </div><div class="line">             dispatcher.forward(request, ctx.getResponse());</div><div class="line">   </div><div class="line">     &#125;</div></pre></td></tr></table></figure><p>从上面的代码中可以得出以下几点：</p><ul><li><code>SendErrorFilter</code>的进入条件是：<code>RequestContext</code>中包含<code>error.status_code</code>，且之前从未执行过该filter。(55, 56)</li><li>会将错误信息转发给<code>errorPath</code>执行；<code>errorPath</code>可由配置项<code>error.paht</code>指定，默认为<code>/error</code>。(38, 79, 84)</li><li>转发的错误信息是从<code>RequestContext</code>中的三个<code>key</code>得到：<code>error.status_code</code>, <code>error.exception</code>, <code>error.message</code>。(65~76)</li><li>如果要使用<code>SendErrorFilter</code>，则我们在自己实现自定义ZuulFilter做异常处理的时候，需要注意：</li><li><p>如果是<code>pre</code>, <code>route</code>类型的filter，则捕获所有内部异常，将异常信息设置到<code>error.message</code>中，设置所需返回的HTTP状态码到<code>error.status_code</code>中；然后抛出一个异常。抛出异常是为了将执行流程交给<code>error-&gt;post</code>这个执行分支；否则，当前filter会被认为执行成功，继续执行后续的filter。<code>run()</code>方法抛出的异常需是(或继承)<code>RuntimeException</code>，因为<code>IZuulFilter#run()</code>接口没有显示抛出异常。</p></li><li><p>如果是 post类型：</p><ul><li>设置该filter的<code>order</code>，小于0(这是<code>SendErrorFilter</code>)。</li><li>仔细考虑<code>shouldFilter()</code>的实现细节，因为异常流也会进入<code>post</code> filters，确定是否需要处理。</li><li><code>run()</code>方法中捕获所有异常，然后设置<code>error.status_code</code>, <code>error.message</code>, <code>error.exception</code>，并且不再抛出异常。否则会进入<code>error</code> filters，但是现在没有，由<code>SendErrorFilter</code>替代；除非自己实现一个<code>error</code> filter，然后禁掉<code>SendErrorFilter</code>。</li></ul></li></ul><p>这个版本中，spring-cloud-netflix提供的这个<code>SendErrorFilter</code>有明显的缺陷，无法处理由<code>post</code> filters抛出的异常，也不符合zuul请求的生命周期图。所以在<code>Dalston.RELEASE</code>之后，即<code>spring-cloud-netflix 1.3.0.RELEASE</code>，将<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/v1.3.0.RELEASE/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/zuul/filters/post/SendErrorFilter.java#L43" target="_blank" rel="external">SendErrorFilter</a>的类型改为了<code>error</code>。</p><p>下面的代码片段摘自<code>spring-cloud-netflix 1.3.0.RELEASE</code>的<code>SendErrorFilter</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ERROR_TYPE;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        RequestContext ctx = RequestContext.getCurrentContext();</div><div class="line">        <span class="comment">// only forward to errorPath if it hasn't been forwarded to already</span></div><div class="line">        <span class="keyword">return</span> ctx.getThrowable() != <span class="keyword">null</span></div><div class="line">                &amp;&amp; !ctx.getBoolean(SEND_ERROR_FILTER_RAN, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  </div><div class="line">            ZuulException exception = findZuulException(ctx.getThrowable());</div><div class="line">  </div><div class="line">            request.setAttribute(<span class="string">"javax.servlet.error.status_code"</span>, exception.nStatusCode);</div><div class="line">            request.setAttribute(<span class="string">"javax.servlet.error.exception"</span>, exception);</div><div class="line">            request.setAttribute(<span class="string">"javax.servlet.error.message"</span>, exception.errorCause);</div><div class="line">  </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">   <span class="function">ZuulException <span class="title">findZuulException</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (throwable.getCause() <span class="keyword">instanceof</span> ZuulRuntimeException) &#123;</div><div class="line">           <span class="comment">// this was a failure initiated by one of the local filters</span></div><div class="line">           <span class="keyword">return</span> (ZuulException) throwable.getCause().getCause();</div><div class="line">       &#125;</div><div class="line">  </div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>需要注意几点：</p><ul><li>类型为<code>error</code>(53行)。</li><li>进入条件为：<code>RequestContext</code>中有异常，并且该filter从未执行过(65, 66)。异常对象是在<code>ZuulServlet#error(ZuulException)</code>方法中设置的。</li><li><code>run()</code>方法中提取错误信息不再是从<code>RequestContext</code>的三个<code>key</code>(<code>error.status_code</code>, <code>error.message</code>, <code>error.exception</code>)中获取；而是直接从<code>ZuulException</code>对象中获取(73~82)。</li><li>如何取得<code>ZuulException</code>对象(100<del>118)，最重要的一点是从<code>ZuulRuntimeException</code>中提取<code>ZuulException</code>对象(101</del>103)，而<code>ZuulRuntimeException</code>继承<code>RuntimeException</code>。</li><li>注意101行代码，是判断<code>throwable.getCause()</code>是否为<code>ZuulRuntimeException</code>，这是因为所有非<code>ZuulException</code>的异常在<code>FilterProcessor#processZuulFilter()</code>(227行)中会被转化为<code>ZuulException</code>。</li><li><code>findZuulException</code>没有贴全，其会优先从自定义filter中抛出的<code>ZuulRuntimeException</code>中提取<code>ZuulException</code>对象。这样就允许我们返回我们想要的错误信息和HTTP状态码。</li></ul><p>那基于1.3.0.RELEASE，我们在写自定义filter时，如何做异常处理呢：</p><ul><li>将filter内部异常转化为<code>ZuulException</code>，设置自己需要返回的HTTP状态码，然后包装为<code>ZuulRuntimeException</code>抛出。</li><li>如若不封装为<code>ZuulRuntimeException</code>，则返回的HTTP状态码为500。</li></ul><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// do something</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZuulRuntimeException(<span class="keyword">new</span> ZuulException(t, HttpStatus.BAD_REQUEST.value(), t.getMessage()));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果想自定义返回的异常信息的response body的格式，最简单的方法是仿照<code>BasicErrorController</code>重写一下<code>/error</code>接口。</p>]]></content>
    
    <summary type="html">
    
      最近看到了一个GitHub issue在讨论如何在post类型的zuul filter中设置response body，其中涉及到异常情况下，如何返回一个自定义的response body。正好我在升级spring-cloud，也想弄清楚，spring-cloud-zuul是如何处理异常情况的，所以就仔细看了看这部分的实现细节，现在做个笔记记录下来。
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud项目中通过Feign进行内部服务调用发生401\407错误无返回信息的问题</title>
    <link href="http://lvqingyan.com/sc-feign-4xx/"/>
    <id>http://lvqingyan.com/sc-feign-4xx/</id>
    <published>2017-06-16T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong> 最近好几个小伙伴，问Spring Cloud项目中通过Feign进行内部服务调用发生401\407错误无返回信息的问题。这个问题如果没有自定义异常自定义Code或者系统中没有自定义code为401或407的code，基本很少能碰到。刚好Spring Cloud中国社区的VIP会员<a href="http://www.jianshu.com/p/44e877e395a9" target="_blank" rel="external">任聪博客原文</a>也遇到这个，经过和他交流之后。整理出这篇文章希望能帮助更多的人快速定位问题。<br><a id="more"></a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近在使用Spring Cloud改造现有服务的工作中，在内部服务的调用方式上选择了Feign组件，由于服务与服务之间有权限控制，发现通过Feign来进行调用时如果发生了401、407错误时，调用方不能够取回被调用方返回的错误信息。</p><h2 id="产生原因分析"><a href="#产生原因分析" class="headerlink" title="产生原因分析"></a>产生原因分析</h2><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>Feign默认使用java.net.HttpURLConnection进行通信，通过查看其子类sun.net.www.protocol.http.HttpURLConnection源码发现代码中在进行通信时单独对错误码为401\407的错误请求做了处理，当请求的错误码为401\407时，会关闭请求流，由于此时还并没有将返回的错误信息写入响应流中，所以接收的返回信息中仅仅能获取到response.status()，而response.body()为null。<br><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/sun/net/www/protocol/http/HttpURLConnection.java#1079" target="_blank" rel="external">HttpURLConnection相关信息的源码链接</a></p><h3 id="问题源代码示例"><a href="#问题源代码示例" class="headerlink" title="问题源代码示例"></a>问题源代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (respCode == HTTP_UNAUTHORIZED) &#123;</div><div class="line">    <span class="keyword">if</span> (streaming()) &#123;</div><div class="line">        disconnectInternal();</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException (RETRY_MSG2, HTTP_UNAUTHORIZED);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//其余代码省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>java.net.HttpURLConnection中的HTTP_UNAUTHORIZED的定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HTTP_UNAUTHORIZED = <span class="number">401</span>;</div></pre></td></tr></table></figure><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>关于此问题产生的原因已经很明显了，就是feign.Client实现通信的方式选用了我们不想使用的HttpURLConnection。想到通常在Spring的代码中OCP都是运用得很好的，所以基本上有解决此问题的信心了，最不济就是自己扩展Feign，实现一个自己想要的feign.Client，当然这种事情Spring Cloud基本都会自己搞定，这也是Spring Cloud强大完善的一个地方。<br>通过这个思路查看源码，果然看到了Spring Cloud在使用Feign提前内置了三种通信方式（feign.Client.Default，feign.httpclient.ApacheHttpClient，feign.okhttp.OkHttpClient），其中缺省的情况使用的就是feign.Client.Default，这个就是使用HttpURLConnection通信的方式。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>在Spring Cloud项目中使用了Ribbon的组件，其会帮助我们管理使用Feign，查看org.springframework.cloud.netflix.feign.ribbon.FeignRibbonClientAutoConfiguration源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ConditionalOnClass</span>(&#123; ILoadBalancer.class, Feign.class &#125;)</div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@AutoConfigureBefore</span>(FeignAutoConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignRibbonClientAutoConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@ConditionalOnMissingBean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></div><div class="line">            SpringClientFactory clientFactory) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(<span class="keyword">new</span> Client.Default(<span class="keyword">null</span>, <span class="keyword">null</span>),</div><div class="line">                cachingFactory, clientFactory);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Configuration</span></div><div class="line">    <span class="meta">@ConditionalOnClass</span>(ApacheHttpClient.class)</div><div class="line">    <span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"feign.httpclient.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientFeignLoadBalancedConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line">        <span class="keyword">private</span> HttpClient httpClient;</div><div class="line"></div><div class="line">        <span class="meta">@Bean</span></div><div class="line">        <span class="meta">@ConditionalOnMissingBean</span>(Client.class)</div><div class="line">        <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></div><div class="line">                SpringClientFactory clientFactory) &#123;</div><div class="line">            ApacheHttpClient delegate;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.httpClient != <span class="keyword">null</span>) &#123;</div><div class="line">                delegate = <span class="keyword">new</span> ApacheHttpClient(<span class="keyword">this</span>.httpClient);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                delegate = <span class="keyword">new</span> ApacheHttpClient();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Configuration</span></div><div class="line">    <span class="meta">@ConditionalOnClass</span>(OkHttpClient.class)</div><div class="line">    <span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"feign.okhttp.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpFeignLoadBalancedConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line">        <span class="keyword">private</span> okhttp3.OkHttpClient okHttpClient;</div><div class="line"></div><div class="line">        <span class="meta">@Bean</span></div><div class="line">        <span class="meta">@ConditionalOnMissingBean</span>(Client.class)</div><div class="line">        <span class="function"><span class="keyword">public</span> Client <span class="title">feignClient</span><span class="params">(CachingSpringLoadBalancerFactory cachingFactory,</span></span></div><div class="line">                SpringClientFactory clientFactory) &#123;</div><div class="line">            OkHttpClient delegate;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.okHttpClient != <span class="keyword">null</span>) &#123;</div><div class="line">                delegate = <span class="keyword">new</span> OkHttpClient(<span class="keyword">this</span>.okHttpClient);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                delegate = <span class="keyword">new</span> OkHttpClient();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>从feignClient(CachingSpringLoadBalancerFactory cachingFactory, SpringClientFactory clientFactory) 方法结合其上注解我们可以很清楚的知道，当没有feign.ClientBean的时候会默认生成feign.Client.Default来进行通信，这就是之前说的缺省通信方式</li><li>从HttpClientFeignLoadBalancedConfiguration、OkHttpFeignLoadBalancedConfiguration，我们可以看到其生效的条件，当classpath中有feign.httpclient.ApacheHttpClient并且配置feign.httpclient.enabled=true（缺省为true）、feign.okhttp.OkHttpClient并且配置feign.okhttp.enabled=true（缺省为true）</li><li>当使用ApacheHttpClient或者OkHttpClient进行通信时就不会导致发生401\407错误时，取不到返回的错误信息了</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>通过其上的分析，解决方法已经显而易见了替换默认的Client</p><h3 id="pom-xml文件中新增依赖"><a href="#pom-xml文件中新增依赖" class="headerlink" title="pom.xml文件中新增依赖"></a>pom.xml文件中新增依赖</h3><h4 id="替换为默认为okhttp-Client"><a href="#替换为默认为okhttp-Client" class="headerlink" title="替换为默认为okhttp Client"></a>替换为默认为okhttp Client</h4><ol><li>增加依赖</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">         &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</div><div class="line">         &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;</div><div class="line">         &lt;version&gt;8.18.0&lt;/version&gt;</div><div class="line">   &lt;/dependency&gt;</div></pre></td></tr></table></figure><p>2.在application.properties增加配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">feign.okhttp.enabled=true</div></pre></td></tr></table></figure><blockquote><p>如何把默认的Client替换为okhttp在这里不做过多阐述，可以参考：<a href="https://segmentfault.com/a/1190000009071952" target="_blank" rel="external">spring cloud feign使用okhttp3</a></p></blockquote><h4 id="替换为httpclient"><a href="#替换为httpclient" class="headerlink" title="替换为httpclient"></a>替换为httpclient</h4><ol><li>增加依赖</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">        &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</div><div class="line">        &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;</div><div class="line">        &lt;version&gt;8.18.0&lt;/version&gt;</div><div class="line">  &lt;/dependency&gt;</div></pre></td></tr></table></figure><p>2.在application.properties增加配置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">feign.httpclient.enabled=true</div></pre></td></tr></table></figure><blockquote><p>可以参考<a href="http://xujin.org/sc/sc-fegin01/#更换Feign默认使用的HTTP-Client" target="_blank" rel="external">更换Feign默认使用的HTTP Client</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>由于新增的依赖没有被start管理，并且缺省不会导致程序启动异常，并且返回响应为null与此依赖没有直接关系，因此不方便定位到问题，特此记录下来，希望能帮助到遇到同样问题的人，如对文章有不同的看法，望给予指正。</li><li>本文建立在已经搭建完成Feign的调用基础之上，没有讲述Feign的使用，因为此类文章很多，在此就不重复了，更多的信息可以参考如下文章。</li></ul><p><a href="http://xujin.org/sc/sc-fegin01/" target="_blank" rel="external">快速使用Spring Cloud Feign作为客户端调用服务提供者</a><br><a href="https://segmentfault.com/a/1190000009071952" target="_blank" rel="external">spring cloud feign使用okhttp3</a></p>]]></content>
    
    <summary type="html">
    
      最近好几个小伙伴，问Spring Cloud项目中通过Feign进行内部服务调用发生401\407错误无返回信息的问题。这个问题如果没有自定义异常自定义Code或者系统中没有自定义code为401或407的code，基本很少能碰到。
    
    </summary>
    
      <category term="Spring Cloud" scheme="http://lvqingyan.com/categories/Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Feign" scheme="http://lvqingyan.com/tags/Spring-Cloud-Feign/"/>
    
  </entry>
  
  <entry>
    <title>在Spring Cloud中实现降级之权重路由和标签路由</title>
    <link href="http://lvqingyan.com/sc-ribbon-demoted/"/>
    <id>http://lvqingyan.com/sc-ribbon-demoted/</id>
    <published>2017-06-03T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong> 限流、降级、灰度是服务治理的一个很重要的功能。本文参考<a href="http://www.jianshu.com/p/37ee1e84900a" target="_blank" rel="external">Spring Cloud中国社区的VIP会员-何鹰的博客-整理</a><br>Dubbo自带服务降级、限流功能，spring cloud并没有提供此功能，只能由我们自行实现。这里的限流、降级、灰度都是针对服务实例级别，并不是整个服务级别，整个服务级别可以通过实例部署数量来实现。</p><h2 id="限流降级设计"><a href="#限流降级设计" class="headerlink" title="限流降级设计"></a>限流降级设计</h2><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>服务A，部署了3个实例A1、A2、A3。spring cloud默认客户端负载均衡策略是采用轮询方式，A1、A2、A3三个实例流量均分，各1/3。如果这个时候需要将服务A由1.0版升级至2.0版，我们需要做的步骤是：将A1的流量降为0，柔性下线，关闭A1实例并升级到2.0，将A1流量提升为10%观察2.0线上运行情况，如果情况稳定，则逐步开放流量至不限制及1/3。依次在A2，A3上执行上述操作。<br>在上述步骤中，我们想让特别的人使用2.0，其他人还是使用1.0版，稳定后再全员开放。<br><a id="more"></a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>分析，服务A的流量产生有两个方面，一个是外部流量，外网通过zuul过来的流量，一个是内部流量，服务间调用，服务B调用服务A的这类流量。不管是zuul还是内部服务来的，都是要通过ribbon做客户端负载均衡，我们可以修改ribbon负载均衡策略来实现上述限流、降级、灰度功能。</p><p>要实现这些想法，我们需要对spring-cloud的各个组件、数据流非常熟悉，这样才能知道该在哪里做扩展。一个典型的调用：外网-》Zuul网关-》服务A-》服务B。。。</p><p>spring-cloud跟dubbo一样都是客户端负载均衡，所有调用均由Ribbon来做负载均衡选择服务器，所有调用前后会套一层hystrix做隔离、熔断。服务间调用均用带LoadBalanced注解的RestTemplate发出。RestTemplate-》Ribbon-》hystrix</p><p>通过上述分析我们可以看到，我们的扩展点就在Ribbon，Ribbon根据我们的规则，选择正确的服务器即可。</p><p>我们先来一个dubbo自带的功能：基于权重的流量控制。dubbo自带的控制台可以设置服务实例粒度的半权，倍权。其实就是在客户端负载均衡时，选择服务器带上权重即可，spring-cloud默认是ZoneAvoidanceRule，优先选择相同Zone下的实例，实例间采用轮询方式做负载均衡。我们的想把基于轮询改为基于权重即可。接下来的问题是，每个实例的权重信息保存在哪里？从哪里取？dubbo放在zookeeper中，spring-cloud放在eureka中。我们只需从eureka拿每个实例的权重信息，然后根据权重来选择服务器即可。具体代码LabelAndWeightMetadataRule（先忽略里面的优先匹配label相关代码）。</p><h2 id="工程案例演示"><a href="#工程案例演示" class="headerlink" title="工程案例演示"></a>工程案例演示</h2><p><img src="/images/sc-study/sc-r-d02.png" alt="工程目录"></p><blockquote><p><a href="https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-ribbon-demoted" target="_blank" rel="external">https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-ribbon-demoted</a></p></blockquote><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ol><li><p>config 配置中心<br>端口：8888，方便起见直接读取配置文件，生产环境可以读取git。application-dev.properties为全局配置。先启动配置中心，所有服务的配置（包括注册中心的地址）均从配置中心读取。</p></li><li><p>consumer 服务消费者<br>端口：18090，调用服务提供者，为了演示header传递。</p></li><li><p>core 框架核心包<br>核心jar包，所有微服务均引用该包，使用AutoConfig实现免配置，模拟生产环境下spring-cloud的使用。</p></li><li><p>eureka 注册中心<br>端口：8761，/metadata端点实现metadata信息配置。</p></li><li><p>provider 服务提供者<br>端口：18090，服务提供者，无特殊逻辑。</p></li><li><p>zuul 网关<br>端口：8080，演示解析token获得label并放入header往后传递</p></li></ol><h2 id="案例具体实现"><a href="#案例具体实现" class="headerlink" title="案例具体实现"></a>案例具体实现</h2><h3 id="基于权重的实现思路"><a href="#基于权重的实现思路" class="headerlink" title="基于权重的实现思路"></a>基于权重的实现思路</h3><p>LabelAndWeightMetadataRule写好了，那么我们如何使用它，使之生效呢？有3种方式。</p><p>1）写个AutoConfig将LabelAndWeightMetadataRule声明成@Bean，用来替换默认的ZoneAvoidanceRule。这种方式在技术验证、开发测试阶段使用短平快。但是这种方式是强制全局设置，无法个性化。</p><p>2）由于spring-cloud的Ribbon并没有实现netflix Ribbon的所有配置项。netflix配置全局rule方式为：ribbon.NFLoadBalancerRuleClassName=package.YourRule，spring-cloud并不支持，spring-cloud直接到服务粒度，只支持SERVICE_ID.ribbon.NFLoadBalancerRuleClassName=package.YourRule。</p><blockquote><p>我们可以扩展org.springframework.cloud.netflix.ribbon.PropertiesFactory修正spring cloud ribbon未能完全支持netflix ribbon配置的问题。这样我们可以将全局配置写到配置中心的application-dev.properties全局配置中，然后各个微服务还可以根据自身情况做个性化定制。但是PropertiesFactory属性均为私有，应该是spring cloud不建议在此扩展。参见<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1741。" target="_blank" rel="external">https://github.com/spring-cloud/spring-cloud-netflix/issues/1741。</a></p></blockquote><p>3）使用spring cloud官方建议的@RibbonClient方式。该方式仅存在于spring-cloud单元测试中（在我提问后，现在还存在于spring-cloud issue list）。具体代码参见DefaultRibbonConfiguration.java、CoreAutoConfiguration.java。</p><blockquote><p>目前采用第三种方式处理</p></blockquote><h3 id="基于权重的路由测试"><a href="#基于权重的路由测试" class="headerlink" title="基于权重的路由测试"></a>基于权重的路由测试</h3><p>依次开启 config eureka provide（开两个实例，通过启动参数server.port指定不同端口区分） consumer zuul<br>访问 <a href="http://localhost:8761/metadata.html" target="_blank" rel="external">http://localhost:8761/metadata.html</a> 这是我手写的一个简单的metadata管理界面，分别设置两个provider实例的weight值（设置完需要一段2分钟才能生效），然后访问 <a href="http://localhost:8080/provider/user" target="_blank" rel="external">http://localhost:8080/provider/user</a> 多刷几次来测试zuul是否按权重发送请求，也可以访问 <a href="http://localhost:8080/consumer/test" target="_blank" rel="external">http://localhost:8080/consumer/test</a> 多刷几次来测试consumer是否按权重来调用provide服务。</p><h3 id="基于标签的路由处理"><a href="#基于标签的路由处理" class="headerlink" title="基于标签的路由处理"></a>基于标签的路由处理</h3><p>基于权重的搞定之后，接下来才是重头戏：基于标签的路由。入口请求含有各种标签，然后我们可以根据标签幻化出各种各样的路由规则。例如只有标注为粉丝的用户才使用新版本（灰度、AB、金丝雀），例如标注为中国的用户请求必须发送到中国的服务器（全球部署），例如标注为写的请求必须发送到专门的写服务实例（读写分离），等等等等，唯一限制你的就是你的想象力。</p><h4 id="基于标签的路由实现思路"><a href="#基于标签的路由实现思路" class="headerlink" title="基于标签的路由实现思路"></a>基于标签的路由实现思路</h4><p>根据标签的控制，我们当然放到之前写的Ribbon的rule中，每个实例配置的不同规则也是跟之前一样放到注册中心的metadata中。需要解决以下几个问题:</p><p><strong>Q:关键是标签数据如何传过来?</strong></p><blockquote><p>A:权重随机的实现思路里面有答案，请求都通过zuul进来，因此我们可以在zuul里面给请求打标签，基于用户，IP或其他看你的需求，然后将标签信息放入ThreadLocal中，然后在Ribbon Rule中从ThreadLocal拿出来使用就可以了。</p><p>然而，按照这个方式去实验时，发现有问题，拿不到ThreadLocal。原因是有hystrix这个东西，回忆下hystrix的原理，为了做到故障隔离，hystrix启用了自己的线程，不在同一个线程ThreadLocal失效。</p></blockquote><p>那么还有什么办法能够将标签信息一传到底呢，想想之前有没有人实现过类似的东西，没错sleuth，它的链路跟踪就能够将span传递下去，翻翻sleuth源码，找找其他资料，发现可以使用HystrixRequestVariableDefault，这里不建议直接使用HystrixConcurrencyStrategy，会和sleuth的strategy冲突。代码参见CoreHeaderInterceptor.java。现在可以测试zuul里面的rule，看能否拿到标签内容了。</p><blockquote><p>标签传到HystrixRequestVariableDefault这里的，如果项目中没有使用Hystrix就用不了了,这个时候需要做一个判断在restTemple里面做个判断，没有hystrix就直接threadlocal取。</p></blockquote><p><strong>Q:这里还不是终点，解决了zuul的路由，服务A调服务B这里的路由怎么处理呢？zuul算出来的标签如何往后面依次传递下去呢?</strong></p><p>   我们还是抄sleuth：把标签放入header，服务A调服务B时，将服务A header里面的标签放到服务B的header里，依次传递下去。这里的关键点就是：内部的微服务在接收到发来的请求时(zuul-&gt;A，A-&gt;B）我们将请求放入ThreadLocal，哦，不对，是HystrixRequestVariableDefault，还记得上面说的原因么：）。<br>   这个容易处理，写一个spring mvc拦截器即可，代码参见CoreHeaderInterceptor。然后发送请求时自动带上这个里面保存的标签信息，参见RestTemplate的拦截器CoreHttpRequestInterceptor。到此为止，技术上全部走通实现。</p><blockquote><p>总结一下：zuul依据用户或IP等计算标签，并将标签放入header里向后传递，后续的微服务通过拦截器，将header里的标签放入RestTemplate请求的header里继续向后接力传递。标签的内容通过放入类似于ThreadLocal的全局变量（HystrixRequestVariableDefault），使Ribbon Rule可以使用。</p></blockquote><h3 id="基于标签路由的测试"><a href="#基于标签路由的测试" class="headerlink" title="基于标签路由的测试"></a>基于标签路由的测试</h3><p>参见PreFilter源码，模拟了几个用户的标签，参见LabelAndWeightMetadataRule源码，模拟了OR AND两种标签处理策略。依次开启 config eureka provide（开两个实例，通过启动参数server.port指定不同端口区分） consumer zuul.</p><p><img src="/images/sc-study/sc-r-d03.png" alt="测试"></p><hr><p><img src="/images/sc-study/sc-r-d01.png" alt="测试"><br>访问 <a href="http://localhost:8761/metadata.html" target="_blank" rel="external">http://localhost:8761/metadata.html</a> 设置第一个provide 实例 orLabel为 CN,Test 发送请求头带入Authorization: emt 访问<a href="http://localhost:8080/provider/user" target="_blank" rel="external">http://localhost:8080/provider/user</a> 多刷几次，可以看到zuul所有请求均路由给了第一个实例。访问<a href="http://localhost:8080/consumer/test" target="_blank" rel="external">http://localhost:8080/consumer/test</a> 多刷几次，可以看到，consumer调用均路由给了第一个实例。</p><p>设置第二个provide 实例 andLabel为 EN,Male 发送请求头带入Authorization: em 访问<a href="http://localhost:8080/provider/user" target="_blank" rel="external">http://localhost:8080/provider/user</a> 多刷几次，可以看到zuul所有请求均路由给了第二个实例。访问<a href="http://localhost:8080/consumer/test" target="_blank" rel="external">http://localhost:8080/consumer/test</a> 多刷几次，可以看到，consumer调用均路由给了第二个实例。</p><p>Authorization头还可以设置为PreFilter里面的模拟token来做测试，至此所有内容讲解完毕，技术路线拉通，剩下的就是根据需求来完善你自己的路由策略啦。</p><h2 id="伪代码分析实现流程"><a href="#伪代码分析实现流程" class="headerlink" title="伪代码分析实现流程"></a>伪代码分析实现流程</h2><h3 id="伪代码示例"><a href="#伪代码示例" class="headerlink" title="伪代码示例"></a>伪代码示例</h3><p>Ribbon默认采用ZoneAvoidanceRule，优先选择同zone下的实例。我们继承这个rule并扩展我们自己的限流功能，仔细阅读ZoneAvoidanceRule及其父类源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedMetadataRule</span> <span class="keyword">extends</span> <span class="title">ZoneAvoidanceRule</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String META_DATA_KEY_WEIGHT = <span class="string">"weight"</span>;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">choose</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    List&lt;Server&gt; serverList = <span class="keyword">this</span>.getPredicate().getEligibleServers(<span class="keyword">this</span>.getLoadBalancer().getAllServers(), key);</div><div class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(serverList)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 计算总值并剔除0权重节点</span></div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    Map&lt;Server, Integer&gt; serverWeightMap = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (Server server : serverList) &#123;</div><div class="line">        String strWeight = ((DiscoveryEnabledServer) server).getInstanceInfo().getMetadata().get(META_DATA_KEY_WEIGHT);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> weight = <span class="number">100</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            weight = Integer.parseInt(strWeight);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            <span class="comment">// 无需处理</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (weight &lt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        serverWeightMap.put(server, weight);</div><div class="line">        sum += weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 权重随机</span></div><div class="line">    <span class="keyword">int</span> random = (<span class="keyword">int</span>) (Math.random() * sum);</div><div class="line">    <span class="keyword">int</span> current = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Map.Entry&lt;Server, Integer&gt; entry : serverWeightMap.entrySet()) &#123;</div><div class="line">        current += entry.getValue();</div><div class="line">        <span class="keyword">if</span> (random &lt; current) &#123;</div><div class="line">            <span class="keyword">return</span> entry.getKey();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使上述代码生效，在zuul网关中加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">weightedMetadataRule</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> WeightedMetadataRule();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="代码示例测试"><a href="#代码示例测试" class="headerlink" title="代码示例测试"></a>代码示例测试</h3><p>打断点测试是否进入WeightedMetadataRule，开启多个服务A实例，通过zuul访问服务A。<br>成功进入断点，代码生效后，我们再来看如何指定metadata。<br>访问eureka restful API （我的eureka服务器端口为8100，修改为你自己的eureka端口）<br>Get <a href="http://localhost:8100/eureka/apps" target="_blank" rel="external">http://localhost:8100/eureka/apps</a><br>这个api可以看到所有服务<br>Get <a href="http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME" target="_blank" rel="external">http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME</a><br>这个api可以看到你的服务信息，包括部署了哪些实例<br>Get <a href="http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME/INSTANCE_ID" target="_blank" rel="external">http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME/INSTANCE_ID</a><br>这个api可以看到服务实例的信息，注意其中的metadata节点，目前为empty<br>Put <a href="http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME/INSTANCE_ID/metadata?weight=10" target="_blank" rel="external">http://localhost:8100/eureka/apps/YOUR_SERVICE_NAME/INSTANCE_ID/metadata?weight=10</a><br>通过put方式可以修改metadata的内容，放入weight，设为10</p><p>然后稍等两分钟，让zuul更新注册中心中的信息，接着重新访问，调试就可以看到metadata的内容了，并且也是按照权重随机来进行流量限制的，至此hello world搞定。</p><h3 id="生产上使用WeightedMetadataRule"><a href="#生产上使用WeightedMetadataRule" class="headerlink" title="生产上使用WeightedMetadataRule"></a>生产上使用WeightedMetadataRule</h3><p>接下来，在生产环境中，我们如何应用这个WeightedMetadataRule呢，有如下几种方式：</p><h3 id="手动指定服务策略，"><a href="#手动指定服务策略，" class="headerlink" title="手动指定服务策略，"></a>手动指定服务策略，</h3><p>spring cloud ribbon并没有完整实现netflix ribbon的所有配置功能，负载策略默认只能配置微服务级别，无法配置全局默认值。<br>例如：只能配置 SOME_SERVICE_ID.ribbon.NFLoadBalancerRuleClassName=package.WeightedMetadataRule<br>而不支持配置全局默认值 ribbon.NFLoadBalancerRuleClassName=package.WeightedMetadataRule<br>这种方案明显不符合我们的要求。</p><h3 id="通过声明Irule-spring-bean配置全局负载策略"><a href="#通过声明Irule-spring-bean配置全局负载策略" class="headerlink" title="通过声明Irule spring bean配置全局负载策略"></a>通过声明Irule spring bean配置全局负载策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">weightedMetadataRule</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> WeightedMetadataRule();</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>这种方式也就是我们上面用的hello world方式，配置后强制所有微服务使用该策略，没有例外，微服务无法个性化定制策略，符合目前需求，但不适于长期规划。</p></blockquote><h3 id="继承重写PropertiesFactory"><a href="#继承重写PropertiesFactory" class="headerlink" title="继承重写PropertiesFactory"></a>继承重写PropertiesFactory</h3><p>继承重写org.springframework.cloud.netflix.ribbon.PropertiesFactory类，修正spring cloud ribbon未能完全支持netflix ribbon的问题。但是PropertiesFactory属性均为私有，应该是spring cloud不建议在此扩展。参见<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1741" target="_blank" rel="external">https://github.com/spring-cloud/spring-cloud-netflix/issues/1741</a></p><h3 id="使用spring-cloud官方建议的-RibbonClient方式"><a href="#使用spring-cloud官方建议的-RibbonClient方式" class="headerlink" title="使用spring cloud官方建议的@RibbonClient方式"></a>使用spring cloud官方建议的@RibbonClient方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@RibbonClients</span>(defaultConfiguration = DefaultRibbonConfiguration.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRibbonConfiguration</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;ribbon.client.name:#&#123;null&#125;&#125;"</span>)</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</div><div class="line">    <span class="keyword">private</span> IClientConfig config;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> PropertiesFactory propertiesFactory;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule.class, config, name);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 默认配置</span></div><div class="line">        WeightedMetadataRule rule = <span class="keyword">new</span> WeightedMetadataRule();</div><div class="line">        rule.initWithNiwsConfig(config);</div><div class="line">        <span class="keyword">return</span> rule;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于权重随机的性能，上述代码用的数组分段查找法，还可以采用TreeMap二分查找法。可以将权重数组或权重TreeMap缓存起来。<br>根据测试，在实例数量为50个时 缓存权重数组和权重TreeMap，数组分段查找百万次耗时78-125ms，TreeMap二分耗时50-80ms。</p><p>这篇文章只是把技术打通，至于如何根据服务器负载情况，自动降级，限流等需求，只需要监控服务器状况，调用eureka接口设置metadata即可（其实我个人建议这方面需求通过docker的自动扩容缩容完成，只是有朋友问到如何通过spring cloud实现）。</p><p>下一篇会写基于标签的流量控制。如何控制部分用户使用服务A2.0，其他用户使用服务A1.0。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://calvin1978.blogcn.com/articles/routing.html" target="_blank" rel="external">江南白衣-服务化之－路由</a><br><a href="http://www.jianshu.com/p/37ee1e84900a" target="_blank" rel="external">SpringCloud Ribbon 降级、限流、灰度发布</a></p>]]></content>
    
    <summary type="html">
    
      限流、降级、灰度是服务治理的一个很重要的功能。 Dubbo自带服务降级、限流功能，spring cloud并没有提供此功 能，只能由我们自行实现。这里的限流、降级、灰度都是针对服务 实例级别，并不是整个服务级别，整个服务级别可以通过实例部署 数量来实现。
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Ribbon" scheme="http://lvqingyan.com/tags/Spring-Cloud-Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>快速使用Spring Cloud Feign作为客户端调用服务提供者</title>
    <link href="http://lvqingyan.com/sc-fegin01/"/>
    <id>http://lvqingyan.com/sc-fegin01/</id>
    <published>2017-05-13T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong> 在使用Spring Cloud开发微服务应用时中，各个微服务服务提供者都是以HTTP接口的形式对外提供服务，因此服务消费者在调用服务提供者时，通过HTTP Client的方式访问。当然我们可以使用JDK原生的<code>URLConnection</code>、<code>Apache的Http Client</code>、<code>Netty的异步HTTP Client</code>, Spring的<code>RestTemplate</code>去实现服务间的调用。Spring Cloud对Fegin进行了增强，使Fegin支持了Spring MVC的注解，并整合了Ribbon和Eureka，从而让Fegin的使用更加方便。</p><h2 id="Feign简介"><a href="#Feign简介" class="headerlink" title="Feign简介"></a>Feign简介</h2><p>Feign是一种声明式、模板化的HTTP客户端。在<strong>Spring Cloud</strong>中使用Feign, 可以做到使用HTTP<strong>请求远程服务</strong>时能就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。<a href="https://github.com/openfeign/feign" target="_blank" rel="external">Feign的Github网址</a>,比如：<br>Feign具有如下特性：</p><ul><li>可插拔的注解支持，包括Feign注解和JAX-RS注解</li><li>支持可插拔的HTTP编码器和解码器</li><li>支持Hystrix和它的Fallback</li><li>支持Ribbon的负载均衡</li><li>支持HTTP请求和响应的压缩<a id="more"></a>Feign是一个声明式的<strong>Web Service</strong>客户端，它的目的就是让<strong>Web Service</strong>调用更加简单。它整合了<code>Ribbon</code>和<code>Hystrix</code>，从而不再需要显式地使用这两个组件。Feign还提供了HTTP请求的模板，通过编写简单的接口和注解，就可以定义好HTTP请求的参数、格式、地址等信息。接下来，Feign会完全代理HTTP的请求，我们只需要像调用方法一样调用它就可以完成服务请求。<h2 id="Feign-示例工程"><a href="#Feign-示例工程" class="headerlink" title="Feign 示例工程"></a>Feign 示例工程</h2></li></ul><p><img src="/images/sc-study/sc-feign-ml.png" alt="工程目录"><br>链接：<a href="https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-feign-first" target="_blank" rel="external">https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-feign-first</a></p><blockquote><p>本文最终修改时间：2017-05-20 18:47:23，为了解决<code>问题1和2</code>最终使用版本:Spring Boot的版本为<code>1.5.3.RELEASE</code>，Spring Cloud版本为<code>Dalston.RELEASE</code></p></blockquote><h3 id="服务消费者中sc-feign-first-consumer的Feign的定义"><a href="#服务消费者中sc-feign-first-consumer的Feign的定义" class="headerlink" title="服务消费者中sc-feign-first-consumer的Feign的定义"></a>服务消费者中sc-feign-first-consumer的Feign的定义</h3><p>为了让Feign知道在调用方法时应该向哪个地址发请求以及请求需要带哪些参数，我们需要定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xujin.sc.feign.user.service;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.feign.FeignClient;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</div><div class="line"><span class="keyword">import</span> org.xujin.sc.feign.user.model.OrderModel;</div><div class="line"></div><div class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"sc-feign-first-provider"</span>)<span class="comment">//【A】</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserFeignService</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/sc/order/&#123;id&#125;"</span>, method = RequestMethod.GET)<span class="comment">//【B】</span></div><div class="line"><span class="function"><span class="keyword">public</span> OrderModel <span class="title">findOrderById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>; <span class="comment">//【C】</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>A: @FeignClient用于通知Feign组件对该接口进行代理(不需要编写接口实现)，使用者可直接通过@Autowired注入，如下代码所示。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 注入服务提供者,远程的Http服务</span></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> UserFeignService userFeignService;</div></pre></td></tr></table></figure><blockquote><p>B: @RequestMapping表示在调用该方法时需要向/sc/order/{id}发送GET请求。</p><p>C: @PathVariable与SpringMVC中对应注解含义相同</p></blockquote><h3 id="服务消费者中Feign的使用"><a href="#服务消费者中Feign的使用" class="headerlink" title="服务消费者中Feign的使用"></a>服务消费者中Feign的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xujin.sc.feign.user.controller;</div><div class="line"><span class="keyword">import</span> org.slf4j.Logger;</div><div class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</div><div class="line"><span class="keyword">import</span> org.xujin.sc.feign.user.model.OrderModel;</div><div class="line"><span class="keyword">import</span> org.xujin.sc.feign.user.service.UserFeignService;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * UserController</div><div class="line"> * <span class="doctag">@author</span> xujin</div><div class="line"> */</div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(UserController.class);</div><div class="line"></div><div class="line"><span class="comment">// 注入服务提供者,远程的Http服务</span></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> UserFeignService userFeignService;</div><div class="line"></div><div class="line"><span class="comment">// 服务消费者对位提供的服务</span></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/sc/user/&#123;id&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> OrderModel <span class="title">findByIdByEurekaServer</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> userFeignService.findOrderById(id);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>如上代码所示，通过@Autowired将声明的Feign依赖注入即可，调用userFeignService.findOrderById(id)使用。开发者通过userFeignService.findOrderById()就能完成发送HTTP请求和解码HTTP返回结果并封装成对象的过程。</p></blockquote><h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><p>依次按顺序启动如下工程<br>注册中心: sc-fegin-first-server<br>服务提供者1:sc-fegin-first-provider01<br>服务提供者2:sc-fegin-first-provider02<br>以上工程能正常启动work，但是当启动服务消费者: sc-fegin-first-consumer报错如下。</p><blockquote><p>使用的示例工程的Spring Boot的版本为1.5.2.RELEASE，Spring Cloud版本为Dalston.RELEASE会出现以下错误。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 引入spring boot的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 引入spring cloud的依赖 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div></pre></td></tr></table></figure><p>访问<a href="http://localhost:8010/sc/user/1" target="_blank" rel="external">http://localhost:8010/sc/user/1</a> ,出现以下错误即：<br><code>【问题一】</code>feign/Feign$Builder<br>Caused by: java.lang.NoClassDefFoundError: feign/Feign$Builder<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalStateException: ApplicationEventMulticaster not initialized - call &apos;refresh&apos; before multicasting events via the context: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@2d140a7: startup date [Sun May 14 22:44:43 CST 2017]; parent: org.springframework.context.annotation.AnnotationConfigApplicationContext@4bf48f6</div><div class="line">at org.springframework.context.support.AbstractApplicationContext.getApplicationEventMulticaster(AbstractApplicationContext.java:404) [spring-context-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.context.support.ApplicationListenerDetector.postProcessBeforeDestruction(ApplicationListenerDetector.java:97) ~[spring-context-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:253) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:578) [spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:554) [spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:961) [spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:523) [spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:968) [spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1033) [spring-context-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555) [spring-context-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:737) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:370) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:314) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1162) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1151) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.xujin.sc.feign.user.UserConsumerApplication.main(UserConsumerApplication.java:15) [classes/:na]</div><div class="line"></div><div class="line">2017-05-14 22:44:44.079 ERROR 2372 --- [           main] o.s.boot.SpringApplication               : Application startup failed</div><div class="line"></div><div class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;methodValidationPostProcessor&apos; defined in class path resource [org/springframework/boot/autoconfigure/validation/ValidationAutoConfiguration.class]: Unsatisfied dependency expressed through method &apos;methodValidationPostProcessor&apos; parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;org.xujin.sc.feign.user.service.UserFeignService&apos;: Failed to introspect bean class [org.springframework.cloud.netflix.feign.FeignClientFactoryBean] for lookup method metadata: could not find class that it depends on; nested exception is java.lang.NoClassDefFoundError: feign/Feign$Builder</div><div class="line">at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:467) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1173) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1067) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:223) ~[spring-context-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:702) ~[spring-context-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:527) ~[spring-context-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122) ~[spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:737) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:370) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:314) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1162) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:1151) [spring-boot-1.5.2.RELEASE.jar:1.5.2.RELEASE]</div><div class="line">at org.xujin.sc.feign.user.UserConsumerApplication.main(UserConsumerApplication.java:15) [classes/:na]</div><div class="line">Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;org.xujin.sc.feign.user.service.UserFeignService&apos;: Failed to introspect bean class [org.springframework.cloud.netflix.feign.FeignClientFactoryBean] for lookup method metadata: could not find class that it depends on; nested exception is java.lang.NoClassDefFoundError: feign/Feign$Builder</div><div class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(AutowiredAnnotationBeanPostProcessor.java:269) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.determineConstructorsFromBeanPostProcessors(AbstractAutowireCapableBeanFactory.java:1118) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1091) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getSingletonFactoryBeanForTypeCheck(AbstractAutowireCapableBeanFactory.java:923) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.getTypeForFactoryBean(AbstractAutowireCapableBeanFactory.java:804) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.isTypeMatch(AbstractBeanFactory.java:558) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.doGetBeanNamesForType(DefaultListableBeanFactory.java:432) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanNamesForType(DefaultListableBeanFactory.java:395) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.BeanFactoryUtils.beanNamesForTypeIncludingAncestors(BeanFactoryUtils.java:220) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1260) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1101) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">... 19 common frames omitted</div><div class="line">Caused by: java.lang.NoClassDefFoundError: feign/Feign$Builder</div><div class="line">at java.lang.Class.getDeclaredMethods0(Native Method) ~[na:1.8.0_112]</div><div class="line">at java.lang.Class.privateGetDeclaredMethods(Class.java:2701) ~[na:1.8.0_112]</div><div class="line">at java.lang.Class.getDeclaredMethods(Class.java:1975) ~[na:1.8.0_112]</div><div class="line">at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:613) ~[spring-core-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:524) ~[spring-core-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:510) ~[spring-core-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(AutowiredAnnotationBeanPostProcessor.java:247) ~[spring-beans-4.3.7.RELEASE.jar:4.3.7.RELEASE]</div><div class="line">... 32 common frames omitted</div><div class="line">Caused by: java.lang.ClassNotFoundException: feign.Feign$Builder</div><div class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:381) ~[na:1.8.0_112]</div><div class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_112]</div><div class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331) ~[na:1.8.0_112]</div><div class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_112]</div><div class="line">... 39 common frames omitted</div></pre></td></tr></table></figure></p><p><img src="/images/sc-study/sc-feign1.png" alt="sc-feign1"></p><hr><p>经查找解决问题2天查看无果(捂脸，后面写源码分析定位)，因此决定将Spring Boot的版本改变为1.4.3.RELEASE，Spring Cloud版本为Camden.SR5之后,按上面的顺序启动，之后测试<a href="http://localhost:8010/sc/user/1" target="_blank" rel="external">http://localhost:8010/sc/user/1</a> ,可以正常work。</p><h2 id="Fegin的work原理"><a href="#Fegin的work原理" class="headerlink" title="Fegin的work原理"></a>Fegin的work原理</h2><p>Spring Cloud应用在启动时，Feign会<code>扫描标有@FeignClient</code>注解的接口，<code>生成代理</code>，并注册到<code>Spring容器中</code>。生成代理时Feign会为<code>每个接口方法创建一个RequetTemplate对象</code>，该对象<code>封装了HTTP请求</code>需要的全部信息，请求参数名、请求方法等信息都是在这个过程中确定的，Feign的模板化就体现在这里。<br>在本例中，我们将Feign与Eureka和Ribbon组合使用，@FeignClient(name = “sc-feign-first-provider”)意为通知Feign在调用该接口方法时要向Eureka中查询名为ea的服务，从而得到服务URL。</p><h2 id="Fegin的常见应用"><a href="#Fegin的常见应用" class="headerlink" title="Fegin的常见应用"></a>Fegin的常见应用</h2><h3 id="Feign的Encoder、Decoder和ErrorDecoder"><a href="#Feign的Encoder、Decoder和ErrorDecoder" class="headerlink" title="Feign的Encoder、Decoder和ErrorDecoder"></a>Feign的Encoder、Decoder和ErrorDecoder</h3><p>Feign将方法签名中方法参数对象序列化为请求参数放到HTTP请求中的过程，是由编码器(Encoder)完成的。同理，将HTTP响应数据反序列化为java对象是由解码器(Decoder)完成的。</p><p>默认情况下，Feign会将标有@RequestParam注解的参数转换成字符串添加到URL中，将没有注解的参数通过Jackson转换成json放到请求体中。</p><blockquote><p>注意，如果在@RequetMapping中的method将请求方式指定为GET，那么所有未标注解的参数将会被忽略，例如：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/group/&#123;groupId&#125;"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(@PathVariable(<span class="string">"groupId"</span>)</span> Integer groupId, @<span class="title">RequestParam</span><span class="params">(<span class="string">"groupName"</span>)</span> String groupName, DataObject obj)</span>;</div></pre></td></tr></table></figure><p>此时因为声明的是GET请求没有请求体，所以obj参数就会被忽略。</p><ul><li>在Spring Cloud环境下，Feign的Encoder只会用来编码没有添加注解的参数。如果你自定义了Encoder, 那么只有在编码obj参数时才会调用你的Encoder。</li><li>对于Decoder, 默认会委托给SpringMVC中的MappingJackson2HttpMessageConverter类进行解码。只有当状态码不在200 ~ 300之间时ErrorDecoder才会被调用。</li><li>ErrorDecoder的作用是可以根据HTTP响应信息返回一个异常，该异常可以在调用Feign接口的地方被捕获到。<br>我们目前就通过ErrorDecoder来使Feign接口抛出业务异常以供调用者处理。</li></ul><h3 id="更换Feign默认使用的HTTP-Client"><a href="#更换Feign默认使用的HTTP-Client" class="headerlink" title="更换Feign默认使用的HTTP Client"></a>更换Feign默认使用的HTTP Client</h3><p>Feign在默认情况下使用的是JDK原生的<code>URLConnection</code>发送HTTP请求，没有连接池，但是对每个地址会保持一个长连接，即利用HTTP的persistence connection 。我们可以用Apache的<code>HTTP Client</code>替换Feign原始的http client, 从而获取<code>连接池、超时时间</code>等与性能息息相关的控制能力。Spring Cloud从Brixtion.SR5版本开始支持这种替换，首先在项目中声明Apache HTTP Client和feign-httpclient依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 使用Apache HttpClient替换Feign原生httpclient --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.17.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>然后在<code>application.yml</code>中添加如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">feign:</div><div class="line">  httpclient:</div><div class="line">    enabled: true</div></pre></td></tr></table></figure></p><p><a href="https://segmentfault.com/a/1190000009071952" target="_blank" rel="external">spring cloud feign使用okhttp3参考</a></p><h2 id="spring-cloud-feign常见问题"><a href="#spring-cloud-feign常见问题" class="headerlink" title="spring cloud feign常见问题"></a>spring cloud feign常见问题</h2><h3 id="参数不会自动传递"><a href="#参数不会自动传递" class="headerlink" title="参数不会自动传递"></a>参数不会自动传递</h3><p>服务消费者端调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name, @<span class="title">RequestParam</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age) </span>&#123;</div><div class="line"><span class="keyword">return</span> userFeignService.hello(name, age);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>服务提供者Controller对外服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name, @<span class="title">RequestParam</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age) </span>&#123;</div><div class="line"><span class="keyword">return</span> name + age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>Fegin客户端定义调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name, @RequestParam(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>;</div></pre></td></tr></table></figure></p><p>启动的时候sc-fegin-first-consumer工程不报错。但是当访问<a href="http://localhost:8010/test?name=xujin&amp;age=25" target="_blank" rel="external">http://localhost:8010/test?name=xujin&amp;age=25</a> ,报错如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">feign.FeignException: status 405 reading UserFeignService#hello(String,int); content:</div><div class="line">&#123;&quot;timestamp&quot;:1494856464666,&quot;status&quot;:405,&quot;error&quot;:&quot;Method Not Allowed&quot;,&quot;exception&quot;:&quot;org.springframework.web.HttpRequestMethodNotSupportedException&quot;,&quot;message&quot;:&quot;Request method &apos;POST&apos; not supported&quot;,&quot;path&quot;:&quot;/hello&quot;&#125;</div><div class="line">at feign.FeignException.errorStatus(FeignException.java:62) ~[feign-core-9.3.1.jar:na]</div></pre></td></tr></table></figure></p><p>Fegin客户端定义修改如下OK，原因是name被自动放到request body。只要有body，就会被feign认为是post请求，所以整个hello是被当作带有request parameter和body的post请求发送出去了，因此出现上面的错误提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span> String name, @<span class="title">RequestParam</span><span class="params">(<span class="string">"age"</span>)</span> <span class="keyword">int</span> age)</span>;</div></pre></td></tr></table></figure><h3 id="POST多参数调用"><a href="#POST多参数调用" class="headerlink" title="POST多参数调用"></a>POST多参数调用</h3><ul><li>POST多参数 Feign端定义：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test/post"</span>, method = RequestMethod.POST)</div><div class="line"><span class="function"><span class="keyword">public</span> OrderModel <span class="title">post</span><span class="params">(OrderModel orderModel)</span></span>;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test/post"</span>, method = RequestMethod.POST)</div><div class="line"><span class="function"><span class="keyword">public</span> OrderModel <span class="title">post</span><span class="params">(@RequestBody OrderModel orderModel)</span></span>;</div></pre></td></tr></table></figure><blockquote><p>以上两种定义方式等价</p></blockquote><ul><li>服务提供者的定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostMapping</span>(<span class="string">"/test/post"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> OrderModel <span class="title">testPost</span><span class="params">(@RequestBody OrderModel orderModel)</span> </span>&#123;</div><div class="line">orderModel.setOrderNo(<span class="number">2222222L</span>);</div><div class="line"><span class="keyword">return</span> orderModel;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>修改订单号返回证明，服务提供者接到从Feign POST请求过来的数据。</p></blockquote><ul><li>服务消费者端的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@PostMapping</span>(<span class="string">"/test/post"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> OrderModel <span class="title">testPost</span><span class="params">(@RequestBody OrderModel orderModel)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> userFeignService.post(orderModel);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>测试<br>当修改了Feign默认的http Client之后，出现如下错误，具体出错原因还在排查之中，本文会随时更改。<br><code>【问题二】</code>更换了Feign默认的Client出现HystrixRuntimeException<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"timestamp"</span>: <span class="number">1494947172990</span>,</div><div class="line">    <span class="attr">"status"</span>: <span class="number">500</span>,</div><div class="line">    <span class="attr">"error"</span>: <span class="string">"Internal Server Error"</span>,</div><div class="line">    <span class="attr">"exception"</span>: <span class="string">"com.netflix.hystrix.exception.HystrixRuntimeException"</span>,</div><div class="line">    <span class="attr">"message"</span>: <span class="string">"UserFeignService#post(OrderModel) failed and no fallback available."</span>,</div><div class="line">    <span class="attr">"path"</span>: <span class="string">"/test/post"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">java.lang.IllegalArgumentException: MIME type may not contain reserved characters</div><div class="line">at org.apache.http.util.Args.check(Args.java:36) ~[httpcore-4.4.5.jar:4.4.5]</div><div class="line">at org.apache.http.entity.ContentType.create(ContentType.java:182) ~[httpcore-4.4.5.jar:4.4.5]</div><div class="line">at feign.httpclient.ApacheHttpClient.getContentType(ApacheHttpClient.java:159) ~[feign-httpclient-8.17.0.jar:8.17.0]</div><div class="line">at feign.httpclient.ApacheHttpClient.toHttpUriRequest(ApacheHttpClient.java:140) ~[feign-httpclient-8.17.0.jar:8.17.0]</div><div class="line">at feign.httpclient.ApacheHttpClient.execute(ApacheHttpClient.java:83) ~[feign-httpclient-8.17.0.jar:8.17.0]</div></pre></td></tr></table></figure><p> 当关闭之后，访问正常如下所示，醉了同样的代码(PS:捂脸)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">feign:</span></div><div class="line"><span class="attr">  httpclient:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">false</span></div></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">"createTime"</span>:<span class="number">1494944311023</span>,<span class="attr">"orderNo"</span>:<span class="number">33333</span>,<span class="attr">"payTime"</span>:<span class="number">1494944311023</span>&#125;</div></pre></td></tr></table></figure><p><img src="/images/sc-study/sc-feign-post.png" alt="sc-feign-post.png"></p><h3 id="GET多参数调用"><a href="#GET多参数调用" class="headerlink" title="GET多参数调用"></a>GET多参数调用</h3><p>当服务之间GET调用为多参数时，可以使用Map来构建参数传递<br>Feign接口中的示例定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test/get"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">(@RequestParam Map&lt;String, Object&gt; map)</span></span>;</div></pre></td></tr></table></figure></p><p>服务消费者的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/test/get"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">()</span> </span>&#123;</div><div class="line">HashMap&lt;String, Object&gt; map = Maps.newHashMap();</div><div class="line">map.put(<span class="string">"orderNo"</span>, <span class="string">"1"</span>);</div><div class="line">map.put(<span class="string">"createTime"</span>, <span class="keyword">new</span> Date());</div><div class="line">map.put(<span class="string">"payTime"</span>, <span class="keyword">new</span> Date());</div><div class="line"><span class="keyword">return</span> userFeignService.testGet(map);</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>个人看来，如果是GET的多参数通过Map进行传递，当参数比较多时，个人建议使用面向对象的思维，通过POST的方式传递对象相对较好。</p></blockquote><p>服务提供者的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test/get"</span>, method = RequestMethod.GET)</div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">(@RequestParam Map&lt;String, Object&gt; map)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> String.valueOf(map);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>访问URL:<a href="http://localhost:8010/test/get" target="_blank" rel="external">http://localhost:8010/test/get</a> ,测试OK.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;orderNo=1, createTime=Sat May 20 19:47:38 CST 2017, payTime=Sat May 20 19:47:38 CST 2017&#125;</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 本文主要介绍了Feign的基本的定义，以及Feign的work原理和使用Feign的注意事项和常见问题。最后介绍了一下更换Feign默认使用的HTTP Client。主要是遇到一个奇葩的问题，最终没解决更换版本。在下一篇文章中将介绍Feign的其它的使用，例如Feign的继承，日志级别，以及Feign源码分析等</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1253" target="_blank" rel="external">希望Feign能够支持参数请求使用POJO的Issue</a><br><a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/659" target="_blank" rel="external">建议使用Feign原生的注解的Issue</a><br><a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1360" target="_blank" rel="external">建议增强Feign的功能</a><br><a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1047" target="_blank" rel="external">建议支持可选的Request Body（目前Feign当POST一个null时，会报异常）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt; 在使用Spring Cloud开发微服务应用时中，各个微服务服务提供者都是以HTTP接口的形式对外提供服务，因此服务消费者在调用服务提供者时，通过HTTP Client的方式访问。当然我们可以使用JDK原生的&lt;code&gt;URLConnection&lt;/code&gt;、&lt;code&gt;Apache的Http Client&lt;/code&gt;、&lt;code&gt;Netty的异步HTTP Client&lt;/code&gt;, Spring的&lt;code&gt;RestTemplate&lt;/code&gt;去实现服务间的调用。Spring Cloud对Fegin进行了增强，使Fegin支持了Spring MVC的注解，并整合了Ribbon和Eureka，从而让Fegin的使用更加方便。&lt;/p&gt;
&lt;h2 id=&quot;Feign简介&quot;&gt;&lt;a href=&quot;#Feign简介&quot; class=&quot;headerlink&quot; title=&quot;Feign简介&quot;&gt;&lt;/a&gt;Feign简介&lt;/h2&gt;&lt;p&gt;Feign是一种声明式、模板化的HTTP客户端。在&lt;strong&gt;Spring Cloud&lt;/strong&gt;中使用Feign, 可以做到使用HTTP&lt;strong&gt;请求远程服务&lt;/strong&gt;时能就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。&lt;a href=&quot;https://github.com/openfeign/feign&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Feign的Github网址&lt;/a&gt;,比如：&lt;br&gt;Feign具有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可插拔的注解支持，包括Feign注解和JAX-RS注解&lt;/li&gt;
&lt;li&gt;支持可插拔的HTTP编码器和解码器&lt;/li&gt;
&lt;li&gt;支持Hystrix和它的Fallback&lt;/li&gt;
&lt;li&gt;支持Ribbon的负载均衡&lt;/li&gt;
&lt;li&gt;支持HTTP请求和响应的压缩
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Fegin" scheme="http://lvqingyan.com/tags/Spring-Cloud-Fegin/"/>
    
  </entry>
  
  <entry>
    <title>API GateWay(网关)那些儿事</title>
    <link href="http://lvqingyan.com/sc-zuul/"/>
    <id>http://lvqingyan.com/sc-zuul/</id>
    <published>2017-05-10T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>:现在越来越多的技术团队开始尝试采纳微服务架构进行产品开发。而基于微服务架构后后端服务通常而言是动态的，为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度，这边文章我们就来聊聊API Gateway的那些事。<br> 关键字：<strong>API Gateway</strong>, <strong>Spring Cloud Zuul</strong>, <strong>Nginx</strong>，<strong>Consul</strong>，<strong>Consul-Template</strong>。</p><h2 id="为什么需要API-Gateway"><a href="#为什么需要API-Gateway" class="headerlink" title="为什么需要API Gateway"></a>为什么需要API Gateway</h2><ul><li>简化客户端调用复杂度</li></ul><p>在微服务架构模式下后端服务的实例数一般是动态的，对于客户端而言如何发现这些动态改变的服务实例的访问地址信息？因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。<br><a id="more"></a><br><img src="/images/sc-study/gw.png" alt=""></p><ul><li>数据裁剪以及聚合</li></ul><p>通常而言多余不同的客户端对于显示时对于数据的需求是不一致的，比如手机端或者Web端又或者在低延迟的网络环境或者高延迟的网络环境。</p><p>因此为了优化客户端的使用体验，API Gateway可以对通用性的响应数据进行裁剪以适应不同客户端的使用需求。同时还可以将多个API调用逻辑进行聚合，从而减少客户端的请求数，优化客户端用户体验</p><ul><li>多渠道支持</li></ul><p>当然我们还可以针对不同的渠道和客户端提供不同的API Gateway,对于该模式的使用由另外一个大家熟知的方式叫<strong>Backend for front-end</strong>, 在Backend for front-end模式当中，我们可以针对不同的客户端分别创建其BFF</p><p><img src="/images/sc-study/gw1.png" alt=""></p><ul><li>遗留系统的微服务化改造</li></ul><p>对于系统系统而言进行微服务改造通常是由于原有的系统存在或多或少的问题，比如技术债务，代码质量，可维护性，可扩展性等等。API Gateway的模式同样适用于这一类遗留系统的改造，通过微服务化的改造逐步实现对原有系统中的问题的修复，从而提升对于原有业务<strong>响应力</strong>的提升。<strong>通过引入抽象层，逐步使用新的实现替换旧的实现。</strong></p><p><img src="/images/sc-study/gw2.png" alt=""></p><h2 id="使用Zuul实现API网关"><a href="#使用Zuul实现API网关" class="headerlink" title="使用Zuul实现API网关"></a>使用Zuul实现API网关</h2><p>Spring Cloud的Zuul组件提供了轻量级网关的功能支持，通过定义路由规则可以快速实现一个轻量级的API网关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">zuul:</div><div class="line">  ignoredPatterns: /api/auth</div><div class="line">  sensitive-headers: &quot;*&quot;</div><div class="line">  ignoreLocalService: true</div><div class="line">  retryable: false</div><div class="line">  host:</div><div class="line">    max-total-connections: 500</div><div class="line">  routes:</div><div class="line">    service01:</div><div class="line">      path: /service01/**</div><div class="line">      serviceId: service01</div><div class="line">      stripPrefix: true</div><div class="line">    thirdpart:</div><div class="line">      pateh: /thirdpart/**</div><div class="line">      url: http://thirdpart.api.com</div></pre></td></tr></table></figure><p>同时除了通过serviceId关联已经注册到Consul的服务实例以外，我们也可以通过zuul直接定义实现对已有服务的直接集成。</p><p>这里我们就不过多介绍Zuul的细节，在实际使用中我们会发现直接使用Zuul会存在诸多问题，包括：</p><ul><li>性能问题：当存在大量请求超时后会造成Zuul阻塞，目前只能通过横向扩展Zuul实例实现对高并发的支持；</li><li>WebSocket的支持问题： Zuul中并不直接提供对WebSocket的支持，需要添加额外的过滤器实现对WebSocket的支持；<br><img src="/images/sc-study/gw-scoket.jpg" alt=""><br>为了解决以上问题，可以通过在Zuul前端部署Nginx实现对Zuul实例的反向代理，同时适当的通过添加Cache以及请求压缩减少对后端Zuul实例的压力。</li></ul><p><img src="/images/sc-study/gw3.png" alt=""></p><h2 id="实现Nginx的动态代理"><a href="#实现Nginx的动态代理" class="headerlink" title="实现Nginx的动态代理"></a>实现Nginx的动态代理</h2><p>通过Nginx我们可以实现对多实例Zuul的请求代理，同时通过添加适当的缓存以及请求压缩配置可以提升前端UI的请求响应时间。这里需要解决的问题是Nginx如何动态发现Zuul实例信息并且将请求转发到Zuul当中。</p><p><a href="https://github.com/hashicorp/consul-template" target="_blank" rel="external">consul-template</a>可以帮助我们解决以上问题,consul-template是一个命令行工具，结合consul实现配置文件的动态生成并且支持在配置文件发生变化后触发用户自定义命令。</p><p>我们使用了如下的Dockerfile用于构建我们的Nginx服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">FROM nginx:1.11.10</div><div class="line"></div><div class="line">ADD consul-template /usr/local/bin</div><div class="line"></div><div class="line">RUN mkdir /etc/consul-templates</div><div class="line"></div><div class="line"># 模板文件</div><div class="line">ADD nginx.tpl /etc/consul-templates/nginx.tpl</div><div class="line">ENV CT_FILE /etc/consul-templates/nginx.tpl</div><div class="line"></div><div class="line">ENV NX_FILE /etc/nginx/conf.d/default.conf # 目标文件</div><div class="line"></div><div class="line">ENV SERVICE identity # 注册在Consul的服务名</div><div class="line"></div><div class="line">COPY dist /usr/share/nginx/html</div><div class="line">RUN mkdir -p /data/cache</div><div class="line"></div><div class="line">CMD /usr/sbin/nginx -c /etc/nginx/nginx.conf  \</div><div class="line">  &amp; CONSUL_TEMPLATE_LOG=debug \</div><div class="line">  consul-template -consul-addr=$CONSUL -template &quot;$CT_FILE:$NX_FILE:/usr/sbin/nginx -s reload&quot;;</div></pre></td></tr></table></figure><p>Nginx配置模板文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"># nginx.tpl</div><div class="line">upstream api_server &#123;</div><div class="line">  least_conn;</div><div class="line">  &#123;&#123;range service &quot;identity&quot;&#125;&#125;</div><div class="line">  server  &#123;&#123;.Address&#125;&#125;:&#123;&#123;.Port&#125;&#125;;</div><div class="line">  &#123;&#123;else&#125;&#125;server 127.0.0.1:9191;&#123;&#123;end&#125;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  localhost;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        root   /usr/share/nginx/html;</div><div class="line">        index  index.html index.htm;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location /api &#123;</div><div class="line">      proxy_pass http://api_server;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">upstream api_server &#123;</div><div class="line">  least_conn;</div><div class="line">  &#123;&#123;range service &quot;identity&quot;&#125;&#125;</div><div class="line">  server  &#123;&#123;.Address&#125;&#125;:&#123;&#123;.Port&#125;&#125;;</div><div class="line">  &#123;&#123;else&#125;&#125;server 127.0.0.1:9191;&#123;&#123;end&#125;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>会根据当前consul中注册的所有identity服务实例进行模板渲染，并且当配置文件内容发生变化后调用nginx -s reload重新加载Nginx配置从而实现对于后端服务实例的动态代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CMD /usr/sbin/nginx -c /etc/nginx/nginx.conf  \</div><div class="line">  &amp; CONSUL_TEMPLATE_LOG=debug \</div><div class="line">  consul-template -consul-addr=$CONSUL -template &quot;$CT_FILE:$NX_FILE:/usr/sbin/nginx -s reload&quot;;</div></pre></td></tr></table></figure><h2 id="其它的一些优化建议"><a href="#其它的一些优化建议" class="headerlink" title="其它的一些优化建议"></a>其它的一些优化建议</h2><p>启用Nginx的Gzip可以对服务器端响应内容进行压缩从而减少一定的客户端响应时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gzip on;</div><div class="line">gzip_min_length 1k;</div><div class="line">gzip_buffers  4 32k;</div><div class="line">gzip_types    text/plain application/x-javascript application/javascript text/xml text/css;</div><div class="line">gzip_vary on;</div></pre></td></tr></table></figure><p>缓存图片以及其它静态资源可以减少对Zuul实例的请求量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">proxy_buffering on;</div><div class="line">proxy_cache_valid any 10m;</div><div class="line">proxy_cache_path /data/cache levels=1:2 keys_zone=my-cache:8m max_size=1000m inactive=600m;</div><div class="line">proxy_temp_path /data/temp;</div><div class="line">proxy_buffer_size 4k;</div><div class="line">proxy_buffers 100 8k;</div><div class="line"></div><div class="line">location ~* (images)    &#123;</div><div class="line">  proxy_pass http://api_server;</div><div class="line">  # cache setting</div><div class="line">  proxy_cache my-cache;</div><div class="line">  proxy_cache_valid 200;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果需要通过Nginx实现对Websocket的代理可以添加一下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">location /sockjs &#123;</div><div class="line">    proxy_pass http://api_server;</div><div class="line"></div><div class="line">    proxy_set_header X-Real-IP $remote_addr;</div><div class="line">    proxy_set_header Host $host;</div><div class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line"></div><div class="line">    # WebSocket support (nginx 1.4)</div><div class="line">    proxy_http_version 1.1;</div><div class="line">    proxy_set_header Upgrade $http_upgrade;</div><div class="line">    proxy_set_header Connection &quot;upgrade&quot;;</div><div class="line">    proxy_connect_timeout 90;</div><div class="line">    proxy_send_timeout 90;</div><div class="line">    proxy_read_timeout 90;</div><div class="line"></div><div class="line">    # !!!Support Spring Boot</div><div class="line">    proxy_pass_header X-XSRF-TOKEN;</div><div class="line">    proxy_set_header Origin &quot;http://localhost:4000&quot;;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;:现在越来越多的技术团队开始尝试采纳微服务架构进行产品开发。而基于微服务架构后后端服务通常而言是动态的，为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度，这边文章我们就来聊聊API Gateway的那些事。&lt;br&gt; 关键字：&lt;strong&gt;API Gateway&lt;/strong&gt;, &lt;strong&gt;Spring Cloud Zuul&lt;/strong&gt;, &lt;strong&gt;Nginx&lt;/strong&gt;，&lt;strong&gt;Consul&lt;/strong&gt;，&lt;strong&gt;Consul-Template&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;为什么需要API-Gateway&quot;&gt;&lt;a href=&quot;#为什么需要API-Gateway&quot; class=&quot;headerlink&quot; title=&quot;为什么需要API Gateway&quot;&gt;&lt;/a&gt;为什么需要API Gateway&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简化客户端调用复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在微服务架构模式下后端服务的实例数一般是动态的，对于客户端而言如何发现这些动态改变的服务实例的访问地址信息？因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。&lt;br&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>Spring  Cloud Zuul的URL转发和路由规则</title>
    <link href="http://lvqingyan.com/sc-zuul-01/"/>
    <id>http://lvqingyan.com/sc-zuul-01/</id>
    <published>2017-04-30T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>:最近开了《跟我学Spring Cloud》系列教程,由于最近比较忙，因此更新较慢。由于自己最近在研究基于Netty名为Janus的网关中间件分为janus-Server端和janus-console管控端，纳管Spring Cloud实现市面上网关85%以上的功能，将在2017年5月6号Spring Cloud中国社区北京技术沙龙分享。顺便抽时间把Spring Cloud Zuul相关的东西整理比较。在本篇文章中Spring Cloud的版本更换为Dalston.RELEASE，Spring Boot的版本为1.5.2.RELEASE。</p><h2 id="Spring-Cloud-Zuul"><a href="#Spring-Cloud-Zuul" class="headerlink" title="Spring Cloud Zuul"></a>Spring Cloud Zuul</h2><p> Spring Cloud Zuul 通过与 Spring Cloud Eureka 进行整合，将自身注册到 Eureka Server中，与Eureka,Ribbon,Hystrix等整合，同时从 Eureka 中获得了所有其它微服务的实例信息。这样的设计通过把网关和服务治理整合到一起，Spring Cloud Zuul可以获取到服务注册信息，结合Ribbon，Hystrix等更好的实现路由转发，负载均衡等功能。想了解更多的内容，可以参考下面的中英文对照翻译文档。或者查看官网文档。<br>   <a href="http://xujin.org/sc/docs/sc-en-zuul-01/" target="_blank" rel="external">Spring Cloud Zuul中英文对照翻译①</a>  <a href="http://xujin.org/sc/docs/sc-en-zuul-02/" target="_blank" rel="external">Spring Cloud Zuul中英文对照翻译②</a>   <a href="http://xujin.org/sc/docs/sc-en-zuul-03/" target="_blank" rel="external">Spring Cloud Zuul中英文对照翻译③</a><br><a id="more"></a><br> <img src="/images/sc-study/janus.jpg" alt="Janus网关"></p><h2 id="快速搭建SC-Zuul"><a href="#快速搭建SC-Zuul" class="headerlink" title="快速搭建SC Zuul"></a>快速搭建SC Zuul</h2><p>工程目录如下图所示:</p><p><img src="/images/sc-study/sc-zuul-01-ml.png" alt="工程目录"></p><blockquote><p>Code地址:<a href="https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-zuul-first" target="_blank" rel="external">https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-zuul-first</a></p></blockquote><h3 id="Spring-Cloud-Zuul原始的URL转发功能"><a href="#Spring-Cloud-Zuul原始的URL转发功能" class="headerlink" title="Spring Cloud Zuul原始的URL转发功能"></a>Spring Cloud Zuul原始的URL转发功能</h3><p> 由于sc-zuul-first-provider1的代码极其简单就是一个简单的服务提供者，因此不做过多介绍。下面主要介绍sc-zuul-first-zuul-no-eureka这个工程，</p><h4 id="URL路由转发功能"><a href="#URL路由转发功能" class="headerlink" title="URL路由转发功能"></a>URL路由转发功能</h4><ol><li><p>创建名为sc-zuul-first-zuul-no-eureka的maven工程,添加依赖，但注意的是该工程只有Zuul的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"> &lt;?xml version="1.0"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xujin.sc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sc-zuul-first-zuul-no-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>sc-zuul-first-zuul-no-eureka<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">  </div><div class="line"> <span class="comment">&lt;!-- 引入spring boot的依赖 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 引入spring cloud的依赖 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- 添加spring-boot的maven插件 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure><blockquote><p>说明: 对于 spring-cloud-starter-zuul 依赖，我们可以通过查看它的依赖内容了解 到：该模块中不仅包含了 Netflix Zuul 的核心依赖 zuul-core，它还包含了下面这 些网关服务需要的重要依赖。<br> spring-cloud-starter-hystrix：该依赖用来在网关服务中实现对微服务 转发时候的保护机制，通过线程隔离和断路器，防止微服务的故障引发 API 网关 资源无法释放，从而影响其他应用的对外服务。<br> spring-cloud-starter-ribbon：该依赖用来实现在网关服务进行路由转发 时候的客户端负载均衡以及请求重试。<br> spring-boot-starter-actuator ：该依赖用来提供常规的微服务管理端点。另外，在Spring Cloud Zuul中还特别提供了/routes 端点来返回当前的所有路由规则。</p></blockquote></li></ol><p>2.主入口程序代码如下，使用@EnableZuulProxy注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xujin.sc.zuul.first.zuul;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulServer;</div><div class="line"></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableZuulProxy</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudZuulApplication</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">SpringApplication.run(SpringCloudZuulApplication.class, args);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3.application.yml配置文件信息如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.port=8041</div><div class="line">spring.application.name=sc-zuul-first-zuul-no-eureka</div><div class="line"></div><div class="line">zuul.routes.api-url.path=/api-url/**</div><div class="line">zuul.routes.api-url.url=http://localhost:8000/</div></pre></td></tr></table></figure></p><p>该配置定义了发往 API 网关服务的请求中，所有符合/api-url/**规则的访问都 将 被 路 由 转 发 到  <a href="http://localhost:8000/" target="_blank" rel="external">http://localhost:8000/</a> 地 址 上 ， 也 就 是 说 当 我 们 访 问 <a href="http://localhost:8041/api-url/sc/order/1" target="_blank" rel="external">http://localhost:8041/api-url/sc/order/1</a> 可以正常的把请求的url转发到<a href="http://localhost:8000/sc/order/2" target="_blank" rel="external">http://localhost:8000/sc/order/2</a> 。其 中 ， 配 置 属 性 zuul.routes.api-url.path 中的 api-url 部分为路由的名字，可以任意定义， 但是一组 path 和 url 映射关系的路由名要相同。</p><blockquote><p>zuul.routes.api-url.url=<a href="http://localhost:8000/" target="_blank" rel="external">http://localhost:8000/</a> 这个配置了服务提供者sc-zuul-first-provider1的URL</p></blockquote><p>4.测试依次按如下顺序,把各个服务启动。<br> <em>注册中心为：sc-zuul-first-eureka-server </em>服务提供者为:sc-zuul-first-provider1，sc-zuul-first-provider2<br> <em>启动sc-zuul-first-zuul-no-eureka </em>上述Server启动之后，测试Case:</p><h4 id="URL路由转发功能测试"><a href="#URL路由转发功能测试" class="headerlink" title="URL路由转发功能测试"></a>URL路由转发功能测试</h4><p>1.当注解为@EnableZuulProxy时，测试转发。通过访问网关的URL: <a href="http://localhost:8041/api-url/sc/order/1" target="_blank" rel="external">http://localhost:8041/api-url/sc/order/1</a> 可以正常的把请求的url转发到<a href="http://localhost:8000/sc/order/2" target="_blank" rel="external">http://localhost:8000/sc/order/2</a></p><p> <img src="/images/sc-study/sc-zuul-01-zfdebug.png" alt="网关URL转发Debug"></p><blockquote><p>Tips:断点跳过之后,返回结果如下，说明当使用@EnableZuulProxy注解的时候，Zuul具有URL转发调用的功能。</p></blockquote><p> <img src="/images/sc-study/sc-zuul-01-zf.png" alt="网关URL转发"></p><p>2.关闭sc-zuul-first-zuul-no-eureka对应的服务，把主应用程序中的注解@EnableZuulProxy变为@EnableZuulServer,按第1步启动sc-zuul-first-zuul-no-eureka服务，测试。</p><p> <img src="/images/sc-study/sc-zuul-01-pts.png" alt="换为@EnableZuulServer注解变为普通的Zuul Server"></p><blockquote><p>Tips: 可以看到上图返回结果为200，但是空白。那为什么会这样呢？后面专门对Zuul的源码分析，请读者忽略或自行查看源码。</p></blockquote><h2 id="Spring-Cloud-Zuul功能"><a href="#Spring-Cloud-Zuul功能" class="headerlink" title="Spring Cloud Zuul功能"></a>Spring Cloud Zuul功能</h2><p>   大家知道Spring Cloud的服务治理的粒度是服务应用名，而如下的配置规则硬编码配置主机名和端口，由于Spring Cloud Zuul整合了Ribbon负载均衡器等因此，下面的配置方式不推荐使用比较low。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server.port=8041</div><div class="line">spring.application.name=sc-zuul-first-zuul-no-eureka</div><div class="line"></div><div class="line">zuul.routes.api-url.path=/api-url/**</div><div class="line">zuul.routes.api-url.url=http://localhost:8000/</div></pre></td></tr></table></figure></p><h3 id="Spring-Cloud-Zuul功能案例"><a href="#Spring-Cloud-Zuul功能案例" class="headerlink" title="Spring Cloud Zuul功能案例"></a>Spring Cloud Zuul功能案例</h3><p>1.为了演示面向服务名为粒度的路由规则，新建了一个名为sc-zuul-first-zuul的工程，该工程与sc-zuul-first-zuul-no-eureka的最大的区别就是在pom.xml文件中，加入spring-cloud-starter-eureka依赖,如下注释所示。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">   <span class="comment">&lt;!-- 多了eureka starter --&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div></pre></td></tr></table></figure></p><p>2.application.yml<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8040</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">sc-zuul-first-zuul</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    service-url:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></div></pre></td></tr></table></figure></p><p>3.主应用程序代码SpringCloudZuulApplication.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xujin.sc.zuul.first.zuul;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> xujin</div><div class="line"> * <span class="doctag">@EnableZuulProxy</span> 声明一个Zuul 代理，该代理使用Ribbon软负载均衡，还整合Hystrix实现熔断</div><div class="line"> */</div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableZuulProxy</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudZuulApplication</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        SpringApplication.run(SpringCloudZuulApplication.class, args);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>4.分别依次把sc-zuul-first-eureka-server，sc-zuul-first-zuul，sc-zuul-first-provider1，<br>sc-zuul-first-provider2，sc-zuul-first-consumer，sc-zuul-first-hystrix-dashboard启动。<br><img src="/images/sc-study/sc-zuul-01-eurserver.png" alt="Eureka Server"></p><h3 id="Spring-Cloud-Zuul功能演示"><a href="#Spring-Cloud-Zuul功能演示" class="headerlink" title="Spring Cloud Zuul功能演示"></a>Spring Cloud Zuul功能演示</h3><p>1.网关的默认路由规则<br>   说明默认情况下，Zuul会代理所有注册到Eureka Server的微服务，并且Zuul的路由规则如下：<br>   <a href="http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/**" target="_blank" rel="external">http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/**</a> 会被转发到serviceId对应的微服务。<br>   <a href="http://localhost:8040/sc-zuul-first-provider/sc/order/2" target="_blank" rel="external">http://localhost:8040/sc-zuul-first-provider/sc/order/2</a><br>   <img src="/images/sc-study/sc-zuul-01-t1.png" alt="默认路由规则"><br>2.网关的负载均衡<br>   <a href="http://localhost:8040/sc-zuul-first-provider/sc/order/2" target="_blank" rel="external">http://localhost:8040/sc-zuul-first-provider/sc/order/2</a><br>   通过网关访问服务提供者，负载均衡打出对应的日志<br>  <figure class="highlight console"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  2017-04-30 18:35:37.502[0;39m [32m INFO[0;39m [35m3443[0;39m [2m---[0;39m [2m[nio-8000-exec-3][0;39m [36mo.x.s.e.f.o.controller.OrderController  [0;39m [2m:[0;39m Zuul路由到服务提供者①</div><div class="line">  2017-04-30 18:34:06.764[0;39m [32m INFO[0;39m [35m3444[0;39m [2m---[0;39m [2m[nio-8001-exec-4][0;39m [36mo.x.s.e.f.o.controller.OrderController  [0;39m [2m:[0;39m Zuul路由到服务提供者②</div><div class="line">[2m2017-04-30 18:35:37.251[0;39m [32m INFO[0;39m [35m3444[0;39m [2m---[0;39m [2m[trap-executor-0][0;39m [36mc.n.d.s.r.aws.ConfigClusterResolver     [0;39m [2m:[0;39m Resolving eureka endpoints via configuration</div></pre></td></tr></table></figure></p><p>3.集成Hystrix<br> <a href="http://localhost:8040/hystrix.stream" target="_blank" rel="external">http://localhost:8040/hystrix.stream</a><br> <img src="/images/sc-study/sc-zuul-01-t2.png" alt=""></p><h2 id="Spring-Cloud-Zuul路由规则"><a href="#Spring-Cloud-Zuul路由规则" class="headerlink" title="Spring Cloud Zuul路由规则"></a>Spring Cloud Zuul路由规则</h2><h3 id="指定服务路由对外访问路径"><a href="#指定服务路由对外访问路径" class="headerlink" title="指定服务路由对外访问路径"></a>指定服务路由对外访问路径</h3> <figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="attr">zuul:</span></div><div class="line"><span class="attr"> routes:</span></div><div class="line"><span class="attr">   sc-zuul-first-provider:</span> <span class="string">/order/**</span></div></pre></td></tr></table></figure><blockquote><p>相当于把sc-zuul-first-provider映射为/order/**，访问<a href="http://localhost:8040/sc-zuul-first-provider/sc/order/2" target="_blank" rel="external">http://localhost:8040/sc-zuul-first-provider/sc/order/2</a><br>  可以等价于:<a href="http://localhost:8040/order/sc/order/2，其它路由规则，可以从官网文档中阅读尝试。" target="_blank" rel="external">http://localhost:8040/order/sc/order/2，其它路由规则，可以从官网文档中阅读尝试。</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;:最近开了《跟我学Spring Cloud》系列教程,由于最近比较忙，因此更新较慢。由于自己最近在研究基于Netty名为Janus的网关中间件分为janus-Server端和janus-console管控端，纳管Spring Cloud实现市面上网关85%以上的功能，将在2017年5月6号Spring Cloud中国社区北京技术沙龙分享。顺便抽时间把Spring Cloud Zuul相关的东西整理比较。在本篇文章中Spring Cloud的版本更换为Dalston.RELEASE，Spring Boot的版本为1.5.2.RELEASE。&lt;/p&gt;
&lt;h2 id=&quot;Spring-Cloud-Zuul&quot;&gt;&lt;a href=&quot;#Spring-Cloud-Zuul&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud Zuul&quot;&gt;&lt;/a&gt;Spring Cloud Zuul&lt;/h2&gt;&lt;p&gt; Spring Cloud Zuul 通过与 Spring Cloud Eureka 进行整合，将自身注册到 Eureka Server中，与Eureka,Ribbon,Hystrix等整合，同时从 Eureka 中获得了所有其它微服务的实例信息。这样的设计通过把网关和服务治理整合到一起，Spring Cloud Zuul可以获取到服务注册信息，结合Ribbon，Hystrix等更好的实现路由转发，负载均衡等功能。想了解更多的内容，可以参考下面的中英文对照翻译文档。或者查看官网文档。&lt;br&gt;   &lt;a href=&quot;http://xujin.org/sc/docs/sc-en-zuul-01/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud Zuul中英文对照翻译①&lt;/a&gt;  &lt;a href=&quot;http://xujin.org/sc/docs/sc-en-zuul-02/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud Zuul中英文对照翻译②&lt;/a&gt;   &lt;a href=&quot;http://xujin.org/sc/docs/sc-en-zuul-03/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud Zuul中英文对照翻译③&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Zuul" scheme="http://lvqingyan.com/tags/Spring-Cloud-Zuul/"/>
    
  </entry>
  
  <entry>
    <title>SC中Eureka Server的HA和安全身份验证</title>
    <link href="http://lvqingyan.com/sc-eureka-02/"/>
    <id>http://lvqingyan.com/sc-eureka-02/</id>
    <published>2017-03-25T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>:在《跟我学Spring Cloud》中的上一篇文章中简单介绍了使用Eureka实现服务的注册与发现。在这篇文章中主要介绍一下Eureka Server注册中心的HA以及Eureka Server的身份验证。<br><a id="more"></a></p><h2 id="什么是高可用"><a href="#什么是高可用" class="headerlink" title="什么是高可用"></a>什么是高可用</h2><h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>   High Availability，即高可用HA。在分布式情况下，我们经常说<code>4个9</code>(99.99%)或者<code>5个9</code>(99.999%)。举个简单例子，如果一个微服务分布式系统依赖于30个微服务，每个微服务可用性是99.99%，那么整个微服务系统的可用性就是99.99%的30次方 ≈ 99.7% ，也就是说有0.3%系统是不可用的，0.3%意味着如果<code>Qps很高</code>，有一亿次请求的话，那么就会有<code>30万</code>次失败。换算成时间<code>大约每月有2个小时服务不稳定</code>。特别是随着服务依赖数量的变多，微服务不稳定的概率会成指数性上升。因此要保证微服务应用的HA需要从各方面入手，下面会介绍一下如何实现Eureka Server的HA。参考工程如下所示。 </p><blockquote><p><code>Tips</code>：代码示例:<a href="https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-eureka-ha" target="_blank" rel="external">https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-eureka-ha</a></p></blockquote><p><img src="/images/sc-study/sc-eureka-ha-01.png" alt="参考工程"></p><h2 id="Eureka-Server的HA"><a href="#Eureka-Server的HA" class="headerlink" title="Eureka Server的HA"></a>Eureka Server的HA</h2><h3 id="Eureka-Server的HA-1"><a href="#Eureka-Server的HA-1" class="headerlink" title="Eureka Server的HA"></a>Eureka Server的HA</h3><h4 id="两个工程演示HA"><a href="#两个工程演示HA" class="headerlink" title="两个工程演示HA"></a>两个工程演示HA</h4><p> 如示例工程所示，我新建了两个Project分别为sc-eureka-ha-server1，sc-eureka-ha-server2， 我们知道在Eureka Server的Standalone模式下面，由于只有一个Eureka Server，所以我们通过配置如下信息关闭Eureka Server的自我注册和抓取注册信息，但是两个Eureka Server之间需要设置为True，相互注册相互感知对方注册信息的变化，从而实现信息同步。<br> 1.sc-eureka-ha-server1的application.yml配置Info 如下：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">sc-eureka-ha-server1</span></div><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8761</span>                    <span class="comment"># 指定该Eureka实例的端口</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8762/eureka/</span></div></pre></td></tr></table></figure><p> 2.sc-eureka-ha-server2的application.yml配置Info 如下</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">sc-eureka-ha-server2</span></div><div class="line">    </div><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8762</span>                    <span class="comment"># 指定该Eureka实例的端口</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></div></pre></td></tr></table></figure><p> 3.主程序入口代码没什么区别如下:<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@EnableEurekaServer</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">SpringApplication.run(EurekaServerApplication.class, args);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p> 4.分别启动sc-eureka-ha-server1和sc-eureka-ha-server2，访问<a href="http://localhost:8761/" target="_blank" rel="external">http://localhost:8761/</a> ,<a href="http://localhost:8762/" target="_blank" rel="external">http://localhost:8762/</a> ，如下:<br><img src="/images/sc-study/sc-e-ha-02.png" alt="启动Eureka Server01"></p><p><img src="/images/sc-study/sc-e-ha-03.png" alt="启动Eureka Server02"></p><p> 5.服务提供者sc-eureka-ha-provider其它代码见工程,application.yml如下所示。<br> <figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr"> server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8000</span></div><div class="line"> </div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">sc-eureka-ha-provider</span></div><div class="line">    </div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    service-url:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></div></pre></td></tr></table></figure></p><blockquote><p><code>tips:</code> 把服务提供者的服务注册信息，注册到Eureka Server 01上。</p></blockquote><p>启动服务提供者，见如下图所示。<br> <img src="/images/sc-study/sc-e-ha-04.png" alt="服务提供者注册Eureka Server01"><br>片刻服务提供者的信息也同步到Eureka Server02上面<br> <img src="/images/sc-study/sc-e-ha-05.png" alt="服务提供者信息同步到Eureka Server02"></p><h4 id="Jar方式演示HA"><a href="#Jar方式演示HA" class="headerlink" title="Jar方式演示HA"></a>Jar方式演示HA</h4><p> Eureka Server的HA，其实可以通过<code>jar的方式</code>指定使用不同的<code>profile配置</code>的方式，在本地运行两个<code>Eureka Server</code>。只需将Eureka server的application.yml修改如下：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">sc-eureka-ha-server</span>  </div><div class="line"><span class="bullet">-</span><span class="bullet">--</span> </div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">   profiles:</span> <span class="string">peer1</span>                                 </div><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">   port:</span> <span class="number">8761</span> </div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">   instance:</span></div><div class="line"><span class="attr">      hostname:</span> <span class="string">peer1.xujin.org</span>  </div><div class="line"><span class="attr">   client:</span>                                    </div><div class="line"><span class="attr">      serviceUrl:</span></div><div class="line"><span class="attr">         defaultZone:</span> <span class="attr">http://peer2.xujin.org:8762/eureka/</span> </div><div class="line"><span class="bullet">-</span><span class="bullet">--</span> </div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr"> profiles:</span> <span class="string">peer2</span> </div><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">   port:</span> <span class="number">8762</span> </div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">   instance:</span></div><div class="line"><span class="attr">      hostname:</span> <span class="string">peer2.xujin.org</span></div><div class="line"><span class="attr">   client:</span></div><div class="line"><span class="attr">     serviceUrl:</span></div><div class="line"><span class="attr">        defaultZone:</span> <span class="attr">http://peer1.xujin.org:8761/eureka/</span></div></pre></td></tr></table></figure></p><p>通过配置switcHosts或者自行配置HostName对应的IP地址,把工程打成jar之后，运行如下命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> java -jar sc-eureka-ha-server1-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2</div><div class="line"></div><div class="line">java -jar sc-eureka-ha-server1-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer1</div></pre></td></tr></table></figure></p><p>测试如下:<br><img src="/images/sc-study/sc-e-ha-06.png" alt="访问Eureka Server HA验证"><br><img src="/images/sc-study/sc-e-ha-07.png" alt="访问Eureka Server HA验证"></p><h2 id="安全身份验证"><a href="#安全身份验证" class="headerlink" title="安全身份验证"></a>安全身份验证</h2><p>   如果客户端的eureka.client.serviceUrl.defaultZone参数值(即Eureka Server的地址)中包含HTTP Basic Authentication信息，如<a href="http://user:password@localhost:8761/eureka" target="_blank" rel="external">http://user:password@localhost:8761/eureka</a>，那么客户端就会自动使用该用户名、密码信息与Eureka服务端进行验证。如果你需要更复杂的验证逻辑，你必须注册一个DiscoveryClientOptionalArgs组件，并将ClientFilter组件注入，在这里定义的逻辑会在每次客户端向服务端发起请求时执行。</p><blockquote><p><code>Tips</code>：代码示例:<a href="https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-eureka-security" target="_blank" rel="external">https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-eureka-security</a></p></blockquote><h3 id="访问Eureka-Server安全身份验证"><a href="#访问Eureka-Server安全身份验证" class="headerlink" title="访问Eureka Server安全身份验证"></a>访问Eureka Server安全身份验证</h3><ol><li><p>如工程sc-eureka-securit中的sc-eureka-security-server工程所示，在pom.xml中增加依赖如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></li><li><p>application.yml如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="attr">  server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8761</span>                    <span class="comment"># 指定该Eureka实例的端口</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line">    <span class="comment">#表示是否将自己注册到Eureka Server上，默认为true，当前应用为Eureka Server所以无需注册</span></div><div class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">false</span>  </div><div class="line">    <span class="comment">#表示是否从Eureka Server获取注册信息，默认为true。因为这是一个单点的Eureka Server，不需要同步其他的Eureka Server节点的数据，故而设为false。 </span></div><div class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">false</span></div><div class="line">    <span class="comment">#Eureka Server的访问地址，服务注册和client获取服务注册信息均通过该URL，多个服务注册地址用,隔开</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></div><div class="line">      </div><div class="line"><span class="attr">security:</span></div><div class="line"><span class="attr">  basic:</span></div><div class="line"><span class="attr">    enabled:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  user:</span></div><div class="line"><span class="attr">     name:</span> <span class="string">xujin</span></div><div class="line"><span class="attr">     password:</span> <span class="number">123</span></div></pre></td></tr></table></figure><p>3.启动Eureka server测试，如下图所示<br><img src="/images/sc-study/sc-e-s-01.png" alt="访问Eureka Server安全验证"></p><h3 id="服务提供者注册Eureka-Server安全身份验证"><a href="#服务提供者注册Eureka-Server安全身份验证" class="headerlink" title="服务提供者注册Eureka Server安全身份验证"></a>服务提供者注册Eureka Server安全身份验证</h3><p>1.服务提供者只需注册时修改application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr"> server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8000</span></div><div class="line"> </div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  application:</span></div><div class="line"><span class="attr">    name:</span> <span class="string">sc-eureka-security-provider</span></div><div class="line">    </div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    service-url:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://xujin:123@localhost:8761/eureka/</span></div></pre></td></tr></table></figure><blockquote><p>Tips:如上所示:<a href="http://用户名:密码@localhost:8761/eureka/" target="_blank" rel="external">http://用户名:密码@localhost:8761/eureka/</a></p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;:在《跟我学Spring Cloud》中的上一篇文章中简单介绍了使用Eureka实现服务的注册与发现。在这篇文章中主要介绍一下Eureka Server注册中心的HA以及Eureka Server的身份验证。&lt;br&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Eureka" scheme="http://lvqingyan.com/tags/Spring-Cloud-Eureka/"/>
    
  </entry>
  
  <entry>
    <title>使用Spring Cloud Eureka实现服务注册与发现</title>
    <link href="http://lvqingyan.com/sc-eureka-01/"/>
    <id>http://lvqingyan.com/sc-eureka-01/</id>
    <published>2017-03-23T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>:由于目前，<code>网上的Spring Cloud的学习的案列</code>，比较<code>凌乱</code>而且<code>没有形成整个体系</code>，因此特开一个专题为<code>跟我学Spring Cloud</code>，希望帮助到<code>有需要的人</code>。本文主要介绍如何使用<code>Spring Cloud中的Eureka组件</code>快速实现<code>微服务的服务注册与发现</code>。至于安全模式和Eureka Server的HA,后面的文章会详细介绍。如果您觉得，有想了解的内容，参与评论留言。<br><a id="more"></a></p><h2 id="什么是服务注册与发现"><a href="#什么是服务注册与发现" class="headerlink" title="什么是服务注册与发现"></a>什么是服务注册与发现</h2><h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p>   在服务化的早期，服务不是很多，服务的注册与发现并不是什么新鲜的名词，Nginx+内部域名服务器方式，甚至Nginx+host文件配置方式也能完成服务的注册与发现。服务上下线需要在nginx,服务器做相应的配置，一旦服务的IP端口发生变化，都需要在nginx上做相应的配置，为了解决这个问题引入服务注册中心。<br>   服务注册,即服务在启动的时候就将服务的IP,端口,版本号等EndPoint注册到注册中心(Eueka,Zookeeper,Consul)对服务进行统一管理.<br>   服务发现,简单的就是说，不管服务上下线，当对某个服务发起请求时，能够快速的从本地缓存或者注册中心的注册列表中，快速找到服务提供者。</p><h2 id="服务化早期的做法"><a href="#服务化早期的做法" class="headerlink" title="服务化早期的做法"></a>服务化早期的做法</h2><h3 id="示例工程说明"><a href="#示例工程说明" class="headerlink" title="示例工程说明"></a>示例工程说明</h3><blockquote><p><code>Tips</code>：代码示例:<a href="https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-eureka-first" target="_blank" rel="external">https://github.com/SoftwareKing/spring-cloud-study/tree/master/sc-eureka-first</a></p></blockquote><p><img src="/images/sc-study/sc-e-p.png" alt="参考工程"></p><h3 id="Spring-MVC中基于无状态的REST"><a href="#Spring-MVC中基于无状态的REST" class="headerlink" title="Spring MVC中基于无状态的REST"></a>Spring MVC中基于无状态的REST</h3><p>   工程可以参考sc-rest-demo下面的sc-rest-provider和sc-rest-consumer，具体使用如下代码所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/sc"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line"></div><div class="line"><span class="comment">// 从属性文件中读取服务提供的URL</span></div><div class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;order.orderServiceUrl&#125;"</span>)</div><div class="line"><span class="keyword">private</span> String orderServiceUrl;</div><div class="line"></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/consumer/&#123;id&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> OrderModel <span class="title">getOrderInfo</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line"><span class="comment">// this.restTemplate.getForObject("http://localhost:8000/sc/order/" +</span></div><div class="line"><span class="comment">// id,OrderModel.class);</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="keyword">this</span>.orderServiceUrl + <span class="string">"/sc/order/"</span> + id,</div><div class="line">OrderModel.class);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>大家注意到没，把<a href="http://localhost:8000" target="_blank" rel="external">http://localhost:8000</a> ,硬编码到程序中，是不是比较low。可以采用上面代码中的方式：orderServiceUrl解决。但是这样还是比较low,下面介绍一下引入Eureka实现服务注册与发现的处理。</p></blockquote><h2 id="使用Eureka实现服务的注册与发现"><a href="#使用Eureka实现服务的注册与发现" class="headerlink" title="使用Eureka实现服务的注册与发现"></a>使用Eureka实现服务的注册与发现</h2><h3 id="搭建注册中心-Eureka-Server"><a href="#搭建注册中心-Eureka-Server" class="headerlink" title="搭建注册中心-Eureka Server"></a>搭建注册中心-Eureka Server</h3><p>  1.引入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</div><div class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 引入spring boot的依赖 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sc-eureka-first-server-HA01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>sc-eureka-first-server-HA01<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 引入Spring Cloud Eureka依赖 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line">  </div><div class="line">  <span class="comment">&lt;!-- 引入spring cloud的依赖 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Camden.SR5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="comment">&lt;!-- 添加spring-boot的maven插件--&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p><ol><li>在Resources目录下创建application.yml<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8761</span>                    <span class="comment"># 指定该Eureka实例的端口</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line">    <span class="comment">#表示是否将自己注册到Eureka Server上，默认为true，当前应用为Eureka Server所以无需注册</span></div><div class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">false</span>  </div><div class="line">    <span class="comment">#表示是否从Eureka Server获取注册信息，默认为true。因为这是一个单点的Eureka Server，不需要同步其他的Eureka Server节点的数据，故而设为false。 </span></div><div class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">false</span></div><div class="line">    <span class="comment">#Eureka Server的访问地址，服务注册和client获取服务注册信息均通过该URL，多个服务注册地址用,隔开</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 参考文档：http://projects.spring.io/spring-cloud/docs/1.0.3/spring-cloud.html#_standalone_mode</span></div><div class="line"><span class="comment"># 参考文档：http://my.oschina.net/buwei/blog/618756</span></div></pre></td></tr></table></figure></li></ol><p>3.创建Spring Boot主应用程序启动代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xujin.sc.eureka.server;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Eureka Server</div><div class="line"> * <span class="doctag">@author</span> xujin</div><div class="line"> */</div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaServer</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringCloudEurekaServer</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">SpringApplication.run(SpringCloudEurekaServer.class, args);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>启动Eureka server测试：<br>  启动sc-eureka-first-server-HA01，访问<a href="http://localhost:8761/" target="_blank" rel="external">http://localhost:8761/</a> ,如下图所示:</p><p>  <img src="/images/sc-study/sc-e-1.png" alt="Eureka server"></p><h3 id="创建服务提供者"><a href="#创建服务提供者" class="headerlink" title="创建服务提供者"></a>创建服务提供者</h3><p>  1.服务提供者，为了演示在这里提供一个简单的<code>订单查询服务</code>，如工程<code>sc-eureka-first-provider01</code>和<code>sc-eureka-first-provider02</code>所示。<br>  2.主程序入口代码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xujin.sc.eureka.first.order;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 服务提供者端，加上<span class="doctag">@EnableDiscoveryClient</span>注解，完成服务注册。</div><div class="line"> * <span class="doctag">@author</span> xujin</div><div class="line"> * <span class="doctag">@site</span> http://xujin.org</div><div class="line"> */</div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableDiscoveryClient</span></div><div class="line"><span class="comment">// @EnableEurekaClient</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderProviderSpringBootAppliaction</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">SpringApplication.run(OrderProviderSpringBootAppliaction.class, args);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p><code>Tips</code>:如果使用Eureka, 可以使用@EnableEurekaClient注解，但是推荐使用@EnableDiscoveryClient代替@EnableEurekaClient注解，因为@EnableDiscoveryClient是一个高度的抽象， 来自于spring-cloud-commons， 由于Spring Cloud选型是中立的因此抽象出该接口， 当服务注册中心选型改变为Eureka，ZK，Consul时，不需要修改原有代码中的注解。</p></blockquote><p>3.服务提供者暴露的服务-OrderController.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> OrderService orderService;</div><div class="line"></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/sc/order/&#123;id&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> OrderModel <span class="title">findOrderById</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">OrderModel orderModel = orderService.findOrderByOrderId(id);</div><div class="line"><span class="keyword">return</span> orderModel;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>启动服务提供者，把服务注册信息，注册到Eureka Server注册中心<br>启动sc-eureka-first-provider01,当启动其中一个服务后刷新Eureka Server会出现安全模式,如下图所示:<br><img src="/images/sc-study/sc-e-safe.png" alt="安全模式"></p><p>启动sc-eureka-first-provider02，刷新Eureka Server如下图所示。<br><img src="/images/sc-study/sc-e-safe-2.png" alt="安全模式"></p><h3 id="创建服务消费者"><a href="#创建服务消费者" class="headerlink" title="创建服务消费者"></a>创建服务消费者</h3><p> 服务消费者主要是一个简单的用户服务，用户服务查询订单服务的订单信息。<br> 1.引入相应的依赖<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"> &lt;?xml version="1.0"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span></span></div><div class="line"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span></div><div class="line"><span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</div><div class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xujin.sc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sc-eureka-first-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>sc-eureka-first-consumer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 引入spring boot的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 引入spring cloud的依赖 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>Camden.SR4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 添加spring-boot的maven插件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure></p><p>2.主程序入口代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.xujin.sc.eureka.user;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</div><div class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</div><div class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</div><div class="line"><span class="keyword">import</span> org.springframework.web.client.RestTemplate;</div><div class="line"></div><div class="line"><span class="comment">//消费者端加入服务发现注解</span></div><div class="line"><span class="meta">@EnableDiscoveryClient</span></div><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConsumerApplication</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">SpringApplication.run(UserConsumerApplication.class, args);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ol><li>消费者调用Controller。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(UserController.class);</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> RestTemplate restTemplate;</div><div class="line"></div><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</div><div class="line"></div><div class="line"><span class="comment">// discoveryClient获取服务列表中，应用名为sc-eureka-first-provider一个服务注册信息</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serviceUrl</span><span class="params">()</span> </span>&#123;</div><div class="line">List&lt;ServiceInstance&gt; list = discoveryClient</div><div class="line">.getInstances(<span class="string">"sc-eureka-first-provider"</span>);</div><div class="line"><span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="keyword">return</span> String.valueOf(list.get(<span class="number">0</span>).getUri());</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@GetMapping</span>(<span class="string">"/sc/user/&#123;id&#125;"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Order <span class="title">findByIdByEurekaServer</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</div><div class="line">String providerServiceUrl = serviceUrl();</div><div class="line"><span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(providerServiceUrl + <span class="string">"sc/order/"</span> + id,</div><div class="line">Order.class);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>如上述代码，所示使用<code>discoveryClient.getInstances(&quot;sc-eureka-first-provider&quot;)</code>获取服务名为<code>sc-eureka-first-provider</code>的服务注册列表信息。</p></blockquote><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>先后启动sc-eureka-first-consumer,如没有异常，打开浏览器访问:<a href="http://localhost:8010/sc/user/2" target="_blank" rel="external">http://localhost:8010/sc/user/2</a> ,debug如下所示可以看到<br><img src="/images/sc-study/sc-e-consumer-1.png" alt="服务提供者端服务发现"></p><p>在刷新一下Eureka Server，如图下所示,此时安全模式关闭。<br><img src="/images/sc-study/sc-e-safe-3.png" alt="Eureka Server"></p><blockquote><p>关于安全模式，在本篇文章中，暂不讨论，后面将会专写一篇文章介绍，请暂时忽略。</p></blockquote><h3 id="获取消费者获取服务端消费列表"><a href="#获取消费者获取服务端消费列表" class="headerlink" title="获取消费者获取服务端消费列表"></a>获取消费者获取服务端消费列表</h3><ol><li><p>使用EurekaClient获取服务注册信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> EurekaClient discoveryClient;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serviceUrl</span><span class="params">()</span> </span>&#123;</div><div class="line">    InstanceInfo instance = discoveryClient.getNextServerFromEureka(<span class="string">"STORES"</span>, <span class="keyword">false</span>);</div><div class="line">    <span class="keyword">return</span> instance.getHomePageUrl();</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>使用DiscoveryClient获取服务注册信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serviceUrl</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">"STORES"</span>);</div><div class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span> ) &#123;</div><div class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>).getUri();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>参考链接：<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc" target="_blank" rel="external">https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc</a></p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p> 上面这个例子使用Eureka实现了服务的注册与发现，但是有一个问题就是获取服务注册列表的方式比较low并且太方便，还有一个问题就是没有使用负载均衡（Load Balance)，这样就没法实现微服务的HA。在后面的文章将会介绍Eureka Server的HA和使用Robbin实现LB。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;:由于目前，&lt;code&gt;网上的Spring Cloud的学习的案列&lt;/code&gt;，比较&lt;code&gt;凌乱&lt;/code&gt;而且&lt;code&gt;没有形成整个体系&lt;/code&gt;，因此特开一个专题为&lt;code&gt;跟我学Spring Cloud&lt;/code&gt;，希望帮助到&lt;code&gt;有需要的人&lt;/code&gt;。本文主要介绍如何使用&lt;code&gt;Spring Cloud中的Eureka组件&lt;/code&gt;快速实现&lt;code&gt;微服务的服务注册与发现&lt;/code&gt;。至于安全模式和Eureka Server的HA,后面的文章会详细介绍。如果您觉得，有想了解的内容，参与评论留言。&lt;br&gt;
    
    </summary>
    
      <category term="跟我学Spring Cloud" scheme="http://lvqingyan.com/categories/%E8%B7%9F%E6%88%91%E5%AD%A6Spring-Cloud/"/>
    
    
      <category term="Spring Cloud Eureka" scheme="http://lvqingyan.com/tags/Spring-Cloud-Eureka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Eureka中文翻译</title>
    <link href="http://lvqingyan.com/sc-fy-eureka/"/>
    <id>http://lvqingyan.com/sc-fy-eureka/</id>
    <published>2017-01-25T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Eureka学习文档资料：</p><ul><li><a href="https://github.com/Netflix/eureka/wiki" target="_blank" rel="external">Netflix Eureka详细文档</a></li><li><a href="http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_netflix" target="_blank" rel="external">Spring Cloud中对Eureka的介绍</a></li><li><a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc" target="_blank" rel="external">Spring Cloud Eureka工程中的文档</a></li></ul><p>说明：本文主要是对<a href="http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_netflix" target="_blank" rel="external">http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_netflix</a> ,Eureka相关的内容进行翻译更新，由于工作原因可能存在时效性敬请谅解。</p><p>Spring Cloud Netflix提供了对Netflix开源项目的集成，使得我们可以以Spring Boot编程风格使用Netflix旗下相关框架。你只需要在程序中添加注解，就能使用成熟的Netflix组件来快速实现分布式系统的常见架构模式。这些模式包括服务发现(Eureka), 断路器(Hystrix), 智能路由(Zuul)和客户端负载均衡(Ribbon)。</p><a id="more"></a><h1 id="服务发现：Eureka客户端"><a href="#服务发现：Eureka客户端" class="headerlink" title="服务发现：Eureka客户端"></a>服务发现：Eureka客户端</h1><p>服务发现是微服务架构中的一项核心服务。如果没有该服务，我们就只能为每一个服务调用者手工配置可用服务的地址，这不仅繁琐而且非常容易出错。Eureka包括了服务端和客户端两部分。服务端可以做到高可用集群部署，每一个节点可以自动同步，有相同的服务注册信息。</p><h2 id="向Eureka注册服务"><a href="#向Eureka注册服务" class="headerlink" title="向Eureka注册服务"></a>向Eureka注册服务</h2><p>当客户端向Eureka注册自己时会提供一些元信息，如主机名、端口号、获取健康信息的url和主页等。Eureka通过心跳连接判断服务是否在线，如果心跳检测失败超过指定时间，对应的服务通常就会被移出可用服务列表。</p><blockquote><p>译者注：向Eureka Server注册过的服务会每30秒向Server发送一次心跳连接, Server会根据心跳数据更新该服务的健康状态并复制到其他Server中。如果超过90秒没有收到该服务的心跳数据，则Server会将该服务移出列表。参考文档：<a href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance" target="_blank" rel="external">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a></p></blockquote><p>Eureka Client代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="meta">@EnableEurekaClient</span></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello world"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>(其实就是个普通的Spring Boot应用)。 在这个例子中我们使用了<code>@EnableEurekaClient</code>注解，但是要在使用Eureka的前提下，你也可以使用<code>@EnableDiscoveryClient</code>注解达到同样的效果。除此之外需要在Eureka server上加上配置信息，如下所示：</p><p><code>application.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka/</span></div></pre></td></tr></table></figure><p>其中，<code>defaultZone</code>的作用是给没有指定<code>Zone</code>的客户端一个默认的Eureka地址。</p><blockquote><p>译者注：客户端可以在配置文件中指定当前服务属于哪一个<code>Zone</code>，如果没有指定，则属于默认<code>Zone</code>。</p></blockquote><p>默认的应用名(Service ID)、主机名和端口号分别对应配置信息中的<code>${spring.application.name}</code>、<code>${spring.application.name}</code>和<code>${server.port}</code>参数。</p><p>使用<code>@EnableEurekaClient</code>注解后当前应用会同时变成一个Eureka服务端实例(它会注册自身)和Eureka客户端(可以查询当前服务列表)，与此相关的配置都在以<code>eureka.instance.*</code>开头的参数下。只要你指定了<code>spring.application.name</code>参数，那么就可以放心的使用默认参数而不需要修改任何配置。</p><p>要查看更详细的参数，请参阅<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaInstanceConfigBean.java" target="_blank" rel="external">EurekaInstanceConfigBean</a>和<a href="http://github.com/spring-cloud/spring-cloud-netflix/tree/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java" target="_blank" rel="external">EurekaClientConfigBean</a>。</p><h2 id="Eureka-Server的身份验证"><a href="#Eureka-Server的身份验证" class="headerlink" title="Eureka Server的身份验证"></a>Eureka Server的身份验证</h2><p>如果客户端的<code>eureka.client.serviceUrl.defaultZone</code>参数值(即Eureka Server的地址)中包含<code>HTTP Basic Authentication</code>信息，如<code>[http://user:password@localhost:8761/eureka](http://user:password@localhost:8761/eureka)</code>，那么客户端就会自动使用该用户名、密码信息与Eureka服务端进行验证。如果你需要更复杂的验证逻辑，你必须注册一个<code>DiscoveryClientOptionalArgs</code>组件，并将<code>ClientFilter</code>组件注入，在这里定义的逻辑会在每次客户端向服务端发起请求时执行。</p><blockquote><p>由于Eureka的限制，Eureka不支持单节点身份验证。</p></blockquote><h2 id="状态页和健康信息指示器"><a href="#状态页和健康信息指示器" class="headerlink" title="状态页和健康信息指示器"></a>状态页和健康信息指示器</h2><p>Eureka应用的状态页和健康信息默认的url为<code>/info</code>和<code>/health</code>，这与<code>Spring Boot Actuator</code>中对应的Endpoint是重复的，因此你必须进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    statusPageUrlPath:</span> <span class="string">$&#123;management.context-path&#125;/info</span></div><div class="line"><span class="attr">    healthCheckUrlPath:</span> <span class="string">$&#123;management.context-path&#125;/health</span></div></pre></td></tr></table></figure><p>客户端通过这些URL获取数据，并根据这些数据来判断是否可以向某个服务发起请求。</p><h2 id="使用HTTPS"><a href="#使用HTTPS" class="headerlink" title="使用HTTPS"></a>使用HTTPS</h2><p>你可以指定<code>EurekaInstanceConfig</code>类中的<code>eureka.instance.[nonSecurePortEnabled,securePortEnabled]=[false,true]</code>属性来指定是否使用HTTPS。当配置使用HTTPS时，Eureka Server会返回以<code>https</code>开头的服务地址。</p><p>即使配置了使用HTTPS，Eureka的主页依然是以普通 HTTP 方式访问的。你需要手动添加一些配置来将这些页面也通过HTTPS保护起来：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    statusPageUrl:</span> <span class="attr">https://$&#123;eureka.hostname&#125;/info</span></div><div class="line"><span class="attr">    healthCheckUrl:</span> <span class="attr">https://$&#123;eureka.hostname&#125;/health</span></div><div class="line"><span class="attr">    homePageUrl:</span> <span class="attr">https://$&#123;eureka.hostname&#125;/</span></div></pre></td></tr></table></figure><blockquote><p>注意，<code>eureka,hostname</code>是Eureka原生属性，只有新版本的Eureka才支持该属性。你也可以用Spring EL表达式代替：<code>${eureka.instance.hostName}</code></p><p>如果你的应用前端部署了代理，并且SSL的终点是此代理服务器，那么你就需要在应用中解析<code>forwarded</code>请求头。如果你在配置文件中添加了<code>X-Forwarded-*</code>相关参数，Spring Boot中的嵌入式Tomcat会自动解析该请求头。一种表明你没有处理好<code>forwarded</code>请求头的迹象就是你的应用渲染出的HTML页面中链接显示的是错误的主机名和端口号。</p></blockquote><h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>默认情况下，Eureka通过客户端发来的心跳包来判断客户端是否在线。如果你不显式指定，客户端在心跳包中不会包含当前应用的健康数据(由Spring Boot Actuator提供)。这意味着只要客户端启动时完成了服务注册，那么该客户端在主动注销之前在Eureka中的状态会永远是<code>UP</code>状态。我们可以通过配置修改这一默认行为，即在客户端发送心跳包时会带上自己的健康信息。这样做的后果是只有当该服务的状态是<code>UP</code>时才能被访问，其它的任何状态都会导致该服务不能被调用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    healthcheck:</span></div><div class="line"><span class="attr">      enabled:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><p>如果你想对健康检查有更细粒度的控制，你可以自己实现<code>com.netflix.appinfo.HealthCheckHandler</code>接口。</p><blockquote><p>以下内容翻译自Eureka官方手册：</p><p>Eureka客户端会每隔30s向服务端发送心跳包以告知服务端当前客户端没有挂掉。对于Client来说，服务Server超过90s没有收到该Client的心跳数据，Server就会把该Client移出服务列表。最好不要修改30s的默认心跳间隔，因为Server会使用这个时间数值来判断是否出现了大面积故障。(译者：意思是比如Eureka默认2分钟收不到心跳就认为网络出了故障，你如果把这个心跳间隔改成了3分钟，那就出问题了。)</p></blockquote><h2 id="Eureka元数据说明"><a href="#Eureka元数据说明" class="headerlink" title="Eureka元数据说明"></a>Eureka元数据说明</h2><p>我们有必要花一些时间来了解一下Eureka的元数据，这样就可以添加一些自定义的数据以适应特定的业务场景。像主机名、IP地址、端口号、状态页url和健康检查url都是Eureka定义的标准元数据。这些元数据会被保存在Eureka Server的注册信息中，客户端会读取这些数据来向需要调用的服务直接发起连接。你可以使用以<code>eureka.instance.metadataMap</code>开头的参数来添加你自定义的元数据，所有客户端都会读取到该信息。通过这种方式你能给客户端自定义一些行为。</p><h2 id="使用EurekaClient对象"><a href="#使用EurekaClient对象" class="headerlink" title="使用EurekaClient对象"></a>使用EurekaClient对象</h2><p>当添加了<code>@EnableDiscoveryClient</code>或<code>@EnableEurekaClient</code>注解后，你就可以在应用中使用<code>EurekaClient</code>对象来获取服务列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> EurekaClient discoveryClient;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serviceUrl</span><span class="params">()</span> </span>&#123;</div><div class="line">    InstanceInfo instance = discoveryClient.getNextServerFromEureka(<span class="string">"STORES"</span>, <span class="keyword">false</span>);</div><div class="line">    <span class="keyword">return</span> instance.getHomePageUrl();</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>不要在<code>@PostConstruct</code>或<code>@Scheduled</code>方法中使用<code>EurekaClient</code>。在<code>ApplicationContext</code>还没有完全启动时使用该对象会发生错误。</p></blockquote><h2 id="使用Spring的DiscoveryClient对象"><a href="#使用Spring的DiscoveryClient对象" class="headerlink" title="使用Spring的DiscoveryClient对象"></a>使用Spring的DiscoveryClient对象</h2><p>你没有必要直接使用Netflix原生的<code>EurekaClient</code>对象，在此基础上做一些封装使用起来会更方便。Spring Cloud支持<code>Feign</code>和<code>Spring RestTmpelate</code>，它们都可以使用服务的逻辑名而不是URL地址来查询服务。如果想给<code>Ribbon</code>手工指定服务列表，你可以将<code>&lt;client&gt;.ribbon.listOfServers</code>属性设为逗号分隔的物理地址或主机名, 参数中的<code>client</code>是服务id，即服务名。</p><p>你可以使用Spring提供的<code>DiscoveryClient</code>对象从而代码不会与Eureka紧耦合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> DiscoveryClient discoveryClient;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serviceUrl</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;ServiceInstance&gt; list = discoveryClient.getInstances(<span class="string">"STORES"</span>);</div><div class="line">    <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.size() &gt; <span class="number">0</span> ) &#123;</div><div class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>).getUri();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="为什么注册一个服务这么慢"><a href="#为什么注册一个服务这么慢" class="headerlink" title="为什么注册一个服务这么慢?"></a>为什么注册一个服务这么慢?</h2><p>服务的注册涉及到心跳连接，默认为每30秒一次。只有当Eureka服务端和客户端本地缓存中的服务元数据相同时这个服务才能被其它客户端发现，这需要3个心跳周期。你可以通过参数<code>eureka.instance.leaseRenewalIntervalInSeconds</code>调整这个时间间隔来加快这个过程。在生产环境中你最好使用默认值，因为Eureka内部的某些计算依赖于该时间间隔。</p><h1 id="服务发现：Eureka服务端"><a href="#服务发现：Eureka服务端" class="headerlink" title="服务发现：Eureka服务端"></a>服务发现：Eureka服务端</h1><p>添加<code>spring-cloud-starter-eureka-server</code>，主类代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SpringBootApplication</span></div><div class="line"><span class="meta">@EnableEurekaServer</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>服务启动后，Eureka有一个带UI的主页，注册信息可以通过<code>/eureka/*</code>下的URL获取到。</p><h2 id="高可用-Zone-和-Region"><a href="#高可用-Zone-和-Region" class="headerlink" title="高可用, Zone 和 Region"></a>高可用, Zone 和 Region</h2><p>Eureka把所有注册信息都放在内存中，所有注册过的客户端都会向Eureka发送心跳包来保持连接。客户端会有一份本地注册信息的缓存，这样就不需要每次远程调用时都向Eureka查询注册信息。</p><p>默认情况下，Eureka服务端自身也是个客户端，所以需要指定一个Eureka Server的URL作为”伙伴”(peer)。如果你没有提供这个地址，Eureka Server也能正常启动工作，但是在日志中会有大量关于找不到peer的错误信息。</p><h2 id="Standalone模式"><a href="#Standalone模式" class="headerlink" title="Standalone模式"></a>Standalone模式</h2><p>只要Eureka Server进程不会挂掉，这种集Server和Client于一身和心跳包的模式能让Standalone(单台)部署的Eureka Server非常容易进行灾难恢复。在 Standalone 模式中，可以通过下面的配置来关闭查找“伙伴”的行为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">server:</span></div><div class="line"><span class="attr">  port:</span> <span class="number">8761</span></div><div class="line"></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    hostname:</span> <span class="string">localhost</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    registerWithEureka:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    fetchRegistry:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></div></pre></td></tr></table></figure><p>注意，<code>serviceUrl</code>中的地址的主机名要与本地主机名相同。</p><h2 id="“伙伴”感知"><a href="#“伙伴”感知" class="headerlink" title="“伙伴”感知"></a>“伙伴”感知</h2><p>Eureka Server可以通过运行多个实例并相互指定为“伙伴”的方式来达到更高的高可用性。实际上这就是默认设置，你只需要指定“伙伴”的地址就可以了:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  client:</span></div><div class="line"><span class="attr">    serviceUrl:</span></div><div class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://peer1/eureka/,http://peer2/eureka/,http://peer3/eureka/</span></div><div class="line"></div><div class="line"><span class="meta">---</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  profiles:</span> <span class="string">peer1</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    hostname:</span> <span class="string">peer1</span></div><div class="line"></div><div class="line"><span class="meta">---</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  profiles:</span> <span class="string">peer2</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    hostname:</span> <span class="string">peer2</span></div><div class="line"></div><div class="line"><span class="meta">---</span></div><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  profiles:</span> <span class="string">peer3</span></div><div class="line"><span class="attr">eureka:</span></div><div class="line"><span class="attr">  instance:</span></div><div class="line"><span class="attr">    hostname:</span> <span class="string">peer3</span></div></pre></td></tr></table></figure><p>在上面这个例子中，我们通过使用不同<code>profile</code>配置的方式可以在本地运行两个Eureka Server。你可以通过修改<code>/etc/host</code>文件，使用上述配置在本地测试伙伴感特性。</p><p>你可以同时启动多个Eureka Server, 并通过伙伴配置使之围成一圈(相邻两个Server互为伙伴)，这些Server中的注册信息都是同步的。If the peers are physically separated (inside a data centre or between multiple data centres) then the system can in principle survive split-brain type failures.</p><h2 id="使用IP地址"><a href="#使用IP地址" class="headerlink" title="使用IP地址"></a>使用IP地址</h2><p>有些时候你可能更倾向于直接使用IP地址定义服务而不是使用主机名。把<code>eureka.instance.preferIpAddress</code>参数设为<code>true</code>时，客户端在注册时就会使用自己的ip地址而不是主机名。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Eureka学习文档资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Netflix/eureka/wiki&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Netflix Eureka详细文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_netflix&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud中对Eureka的介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-netflix/blob/master/docs/src/main/asciidoc/spring-cloud-netflix.adoc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud Eureka工程中的文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：本文主要是对&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_netflix&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_spring_cloud_netflix&lt;/a&gt; ,Eureka相关的内容进行翻译更新，由于工作原因可能存在时效性敬请谅解。&lt;/p&gt;
&lt;p&gt;Spring Cloud Netflix提供了对Netflix开源项目的集成，使得我们可以以Spring Boot编程风格使用Netflix旗下相关框架。你只需要在程序中添加注解，就能使用成熟的Netflix组件来快速实现分布式系统的常见架构模式。这些模式包括服务发现(Eureka), 断路器(Hystrix), 智能路由(Zuul)和客户端负载均衡(Ribbon)。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring Cloud翻译" scheme="http://lvqingyan.com/categories/Spring-Cloud%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Spring Cloud Eureka" scheme="http://lvqingyan.com/tags/Spring-Cloud-Eureka/"/>
    
  </entry>
  
  <entry>
    <title>爱油科技基于SpringCloud的微服务实践</title>
    <link href="http://lvqingyan.com/sc-fx1/"/>
    <id>http://lvqingyan.com/sc-fx1/</id>
    <published>2016-11-22T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="爱油科技基于SpringCloud的微服务实践"><a href="#爱油科技基于SpringCloud的微服务实践" class="headerlink" title="爱油科技基于SpringCloud的微服务实践"></a>爱油科技基于SpringCloud的微服务实践</h1><h2 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h2><p>刘思贤（微博<a href="http://weibo.com/starlight36" target="_blank" rel="external">@starlight36</a>），爱油科技架构师、PMP。主要负责业务平台架构设计，DevOps实施和研发过程持续改进等，关注领域驱动设计与微服务、建设高效团队和工程师文化培养。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本次分享主要介绍了爱油科技基于Docker和Spring Cloud将整体业务微服务化的一些实践经验，主要包括：</p><ul><li>微服务架构的分层和框架选型</li><li>服务发现和配置管理</li><li>服务集成和服务质量保证</li><li>基于领域驱动设计</li><li>实施DevOps<a id="more"></a><h2 id="从单体应用到微服务"><a href="#从单体应用到微服务" class="headerlink" title="从单体应用到微服务"></a>从单体应用到微服务</h2></li></ul><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><p>优点</p><ul><li>小而美，结构简单易于开发实现</li><li>部署门槛低，单个Jar包或者网站打包即可部署</li><li>可快速实现多实例部署</li></ul><p>缺点</p><ul><li>随着业务发展更多的需求被塞进系统，体系结构逐渐被侵蚀反应堆林立</li><li>被技术绑架，难以为特定业务选择平台或框架，尽管可能有更适宜的技术做这件事</li><li>协作困难，不同业务的团队在一个系统上进行开发相互冲突</li><li>难以扩展，为了热点业务而不得不同时扩容全部业务，或者难以继续扩容</li></ul><h3 id="架构拆分"><a href="#架构拆分" class="headerlink" title="架构拆分"></a>架构拆分</h3><p>拆分：按行分层，按列分业务</p><p>在我们的微服务体系中，所有的服务被划分为了三个层次：</p><ol><li>基础设施层：为所有业务提供基础设施，包括服务注册、数据库和NoSQL、对象存储、消息队列等基础设施服务，这一层通常是由成熟组件、第三方服务组成。</li><li>业务服务层：业务微服务，根据业务领域每个子域单独一个微服务，分而治之。</li><li>接入层：直接对外提供服务，例如网站、API接口等。接入层不包含复杂的业务逻辑，只做呈现和转换。</li></ol><p>项目中我们主要关注业务服务层和接入层，对于没有足够运维力量的我们，基础设施使用云服务是省事省力的选择。</p><p>业务服务层我们给他起名叫作Epic，接入层我们起名Rune，建立之初便订立了如下原则：</p><ol><li>业务逻辑层内所有服务完全对等，可相互调用</li><li>业务逻辑层所有服务必须是无状态的</li><li>接入层所有服务可调用业务逻辑层所有服务，但接入层内部同层服务之间<strong>不可</strong>调用</li><li>接入层不能包含业务逻辑代码</li><li>所有微服务必须运行在Docker容器里</li></ol><p>业务逻辑层我们主要使用使用Java，接入层我们主要使用PHP或Node。后来随着团队的成长，逐步将接入层全部迁移至Node。</p><h3 id="框架选型"><a href="#框架选型" class="headerlink" title="框架选型"></a>框架选型</h3><p>爱油科技作为一家成品油行业的初创型公司，需要面对非常复杂的业务场景，而且随着业务的发展，变化的可能性非常高。所以在微服务架构设计之初，我们就期望我们的微服务体系能：</p><ul><li>不绑定到特定的框架、语言</li><li>服务最好是Restful风格</li><li>足够简单，容易落地，将来能扩展</li><li>和Docker相容性好</li></ul><p>目前常见的微服务相关框架：</p><ul><li>Dubbo、DubboX</li><li>Spring Cloud</li><li>Motan</li><li>Thrift、gRPC</li></ul><p>这些常见的框架中，Dubbo几乎是唯一能被称作全栈微服务框架的“框架”，它包含了微服务所需的几乎所有内容，而DubboX作为它的增强，增加了REST支持。</p><p>它优点很多，例如：</p><ul><li>全栈，服务治理的所有问题几乎都有现成答案</li><li>可靠，经过阿里实践检验的产品</li><li>实践多，社区有许多成功应用Dubbo的经验</li></ul><p>不过遗憾的是：</p><ul><li>已经停止维护</li><li>不利于裁剪使用</li><li>“过于Java”，与其他语言相容性一般</li></ul><p>Motan是微博平台微服务框架，承载了微博平台千亿次调用业务。</p><p>优点是：</p><ul><li>性能好，源自于微博对高并发和实时性的要求</li><li>模块化，结构简单，易于使用</li><li>与其他语言相容性好</li></ul><p>不过：</p><ul><li>为“短平快”业务而生，即业务简单，追求高性能高并发。</li></ul><p>Apache Thrift、gRPC等虽然优秀，并不能算作微服务框架，自身并不包括服务发现等必要特性。</p><p>如果说微服务少不了Java，那么一定少不了Spring，如果说少不了Spring，那么微服务“官配”Spring Cloud当然是值得斟酌的选择。</p><p>优点：</p><ul><li>“不做生产者，只做搬运工”</li><li>简单方便，几乎零配置</li><li>模块化，松散耦合，按需取用</li><li>社区背靠Spring大树</li></ul><p>不足：</p><ul><li>轻量并非全栈</li><li>没解决RPC的问题</li><li>实践案例少</li></ul><p>根据我们的目标，我们最终选择了Spring Cloud作为我们的微服务框架，原因有4点：</p><ol><li>虽然Dubbo基础设施更加完善，但结构复杂，我们很难吃得下，容易出坑</li><li>基于<code>Apache Thrift</code>和<code>gRPC</code>自研，投入产出比很差</li><li>不想过早引入RPC以防滥用，Restful风格本身就是一种约束。</li><li>做选择时，<code>Motan</code>还没有发布</li></ol><h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><p>Spring Cloud是一个集成框架，将开源社区中的框架集成到Spring体系下，几个重要的家族项目：</p><ul><li><code>spring-boot</code>，一改Java应用程序运行难、部署难，甚至无需Web容器，只依赖JRE即可</li><li><code>spring-cloud-netflix</code>，集成Netflix优秀的组件Eureka、Hystrix、Ribbon、Zuul，提供服务发现、限流、客户端负载均衡和API网关等特性支持</li><li><code>spring-cloud-config</code>，微服务配置管理</li><li><code>spring-cloud-consul</code>，集成Consul支持</li></ul><h2 id="服务发现和配置管理"><a href="#服务发现和配置管理" class="headerlink" title="服务发现和配置管理"></a>服务发现和配置管理</h2><p>Spring Cloud Netflix提供了Eureka服务注册的集成支持，不过没选它是因为：</p><ul><li>更适合纯Java平台的服务注册和发现</li><li>仍然需要其他分布式KV服务做后端，没解决我们的核心问题</li></ul><p>Docker作为支撑平台的重要技术之一，Consul几乎也是我们的必选服务。因此我们觉得一事不烦二主，理所应当的Consul成为我们的服务注册中心。</p><p>Consul的优势：</p><ul><li>使用Raft一致性算法，能保证分布式集群内各节点状态一致</li><li>提供服务注册、服务发现、服务状态检查</li><li>支持HTTP、DNS等协议</li><li>提供分布式一致性KV存储</li></ul><p>也就是说，Consul可以一次性解决我们对服务注册发现、配置管理的需求，而且长期来看也更适合跟不同平台的系统，包括和Docker调度系统进行整合。</p><p>最初打算自己开发一个Consul和Spring Cloud整合的组件，不过幸运的是，我们做出这个决定的时候，<code>spring-cloud-consul</code>刚刚发布了，我们可以拿来即用，这节约了很多的工作量。</p><p>因此借助Consul和<code>spring-cloud-consul</code>，我们实现了</p><ul><li>服务注册，引用了<code>srping-cloud-consul</code>的项目可以自动注册服务，也可以通过HTTP接口手动注册，Docker容器也可以自动注册</li><li>服务健康状态检查，Consul可以自动维护健康的服务列表</li><li>异构系统可以直接通过Consul的HTTP接口拉取并监视服务列表，或者直接使用DNS解析服务</li><li>通过分布式一致性KV存储进行微服务的配置下发</li><li>为一些业务提供选主和分布式锁服务</li></ul><p>当然也踩到了一些坑：</p><p><code>spring-cloud-consul</code>服务注册时不能正确选判本地ip地址。对于我们的环境来说，无论是在服务器上，还是Docker容器里，都有多个网络接口同时存在，而<code>spring-cloud-consul</code>在注册服务时，需要先选判本地服务的IP地址，判断逻辑是以第一个非本地地址为准，常常错判。因此在容器中我们利用entrypoint脚本获取再通过环境变量强制指定。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env bash</span></div><div class="line"><span class="built_in">set</span> -e</div><div class="line"></div><div class="line"><span class="comment"># If service runs as Rancher service, auto set advertise ip address</span></div><div class="line"><span class="comment"># from Rancher metadata service.</span></div><div class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$RUN_IN_RANCHER</span>"</span> ]; <span class="keyword">then</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"Waiting for ip address..."</span></div><div class="line">    <span class="comment"># Waiting for ip address</span></div><div class="line">    sleep 5</div><div class="line"></div><div class="line">    RANCHER_MS_BASE=http://rancher-metadata/2015-12-19</div><div class="line">    PRIMARY_IP=`curl -sSL <span class="variable">$RANCHER_MS_BASE</span>/self/container/primary_ip`</div><div class="line">    SERVICE_INDEX=`curl -sSL <span class="variable">$RANCHER_MS_BASE</span>/self/container/service_index`</div><div class="line"></div><div class="line">    <span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$PRIMARY_IP</span>"</span> ]; <span class="keyword">then</span></div><div class="line">        <span class="built_in">export</span> SPRING_CLOUD_CONSUL_DISCOVERY_HOSTNAME=<span class="variable">$PRIMARY_IP</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line"></div><div class="line">    <span class="built_in">echo</span> <span class="string">"Starting service #<span class="variable">$&#123;SERVICE_INDEX-1&#125;</span> at <span class="variable">$PRIMARY_IP</span>."</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></div></pre></td></tr></table></figure><p>我们的容器运行在Rancher中，所以可以利用Rancher的metadata服务来获取容器的IP地址，再通过<code>SPRING_CLOUD_CONSUL_DISCOVERY_HOSTNAME</code>环境变量来设置服务发现的注册地址。基于其他容器调度平台也会很相似。</p><p>另外一些服务中内置了定时调度任务等，多实例启动时需要单节点运行调度任务。通过Consul的分布式锁服务，我们可以让获取到锁的节点启用调度任务，没获取到的节点等待获取锁。</p><h2 id="服务集成"><a href="#服务集成" class="headerlink" title="服务集成"></a>服务集成</h2><p>为了方便开发人员使用，微服务框架应当简单容易使用。对于很多微服务框架和RPC框架来说，都提供了很好的机制。在Spring Cloud中通过<code>OpenFeign</code>实现微服务之间的快速集成：</p><p>服务方声明一个Restful的服务接口，和普通的Spring MVC控制器几乎别无二致：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserResource</span> </span>&#123;</div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"&#123;id&#125;"</span>, method = RequestMethod.GET, produces = <span class="string">"application/json"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> UserRepresentation <span class="title">findOne</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> String id) </span>&#123;</div><div class="line">        User user = <span class="keyword">this</span>.userRepository.findByUserId(<span class="keyword">new</span> UserId(id));</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span> || user.getDeleted()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="string">"指定ID的用户不存在或者已被删除。"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserRepresentation(user);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>客户方使用一个微服务接口，只需要定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FeignClient</span>(<span class="string">"epic-member-microservice"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/users/&#123;id&#125;"</span>, method = RequestMethod.GET, produces = <span class="string">"application/json"</span>)</div><div class="line">    <span class="function">User <span class="title">findOne</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> String id)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在需要使用<code>UserClient</code>的Bean中，直接注入<code>UserClient</code>类型即可。事实上，<code>UserClient</code>和相关VO类，可以直接作为公共接口封装在公共项目中，供任意需要使用的微服务引用，服务方Restful Controller直接实现这一接口即可。</p><p><code>OpenFeign</code>提供了这种简单的方式来使用Restful服务，这大大降低了进行接口调用的复杂程度。</p><p>对于错误的处理，我们使用HTTP状态码作为错误标识，并做了如下规定：</p><ul><li>4xx用来表示由于客户方参数错误、状态不正确、没有权限、操作冲突等种种原因导致的业务错误。</li><li>5xx用来表示由于服务方系统异常、无法服务等原因服务不可用的错误。</li></ul><p>对于服务器端，只需要在一个异常类上添加注解，即可指定该异常的HTTP响应状态码，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.NOT_FOUND)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFoundException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotFoundException</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"查找的资源不存在或者已被删除。"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotFoundException</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(message);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotFoundException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(message, cause);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于客户端我们实现了自己的<code>FeignClientExceptionErrorDecoder</code>来将请求异常转换为对于的异常类，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientExceptionErrorDecoder</span> <span class="keyword">implements</span> <span class="title">ErrorDecoder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ErrorDecoder delegate = <span class="keyword">new</span> ErrorDecoder.Default();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Exception <span class="title">decode</span><span class="params">(String methodKey, Response response)</span> </span>&#123;</div><div class="line">        <span class="comment">// Only decode 4xx errors.</span></div><div class="line">        <span class="keyword">if</span> (response.status() &gt;= <span class="number">500</span>) &#123;</div><div class="line">            <span class="keyword">return</span> delegate.decode(methodKey, response);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Response content type must be json</span></div><div class="line">        <span class="keyword">if</span> (response.headers().getOrDefault(<span class="string">"Content-Type"</span>, Lists.newArrayList()).stream()</div><div class="line">            .filter(s -&gt; s.toLowerCase().contains(<span class="string">"json"</span>)).count() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                String body = Util.toString(response.body().asReader());</div><div class="line">                <span class="comment">// 转换并返回异常对象</span></div><div class="line">                ...</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to process response body."</span>, ex);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> delegate.decode(methodKey, response);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>需要注意的是，<code>decode</code>方法返回的4xx状态码异常应当是<code>HystrixBadRequestException</code>的子类对象，原因在于，我们把4xx异常视作业务异常，而不是由于故障导致的异常，所以不应当被Hystrix计算为失败请求，并引发断路器动作，这一点<strong>非常重要</strong>。</p><p>在<code>UserClient.findOne</code>方法的调用代码中，即可直接捕获相应的异常了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    User user = <span class="keyword">this</span>.userClient.findOne(<span class="keyword">new</span> UserId(id));</div><div class="line">&#125; <span class="keyword">catch</span>(NotFoundException ex) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过<code>OpenFeign</code>，我们大大降低了Restful接口进行服务集成的难度，几乎做到了无额外工作量的服务集成。</p><h2 id="服务质量保证"><a href="#服务质量保证" class="headerlink" title="服务质量保证"></a>服务质量保证</h2><p>微服务架构下，由于调用需要跨系统进行远程操作，各微服务独立运维，所以在设计架构时还必须考虑伸缩性和容错性，具体地说主要包括以下几点要求：</p><ul><li>服务实例可以平滑地加入、移除</li><li>流量可以均匀地分布在不同的实例上</li><li>接口应当资源隔离，防止因为个别接口调用时间过长导致线程池被占满而导致整个服务不可用</li><li>能支持接口降级并隔离故障节点，防止集群雪崩</li><li>服务能进行平滑升级</li></ul><p>Spring Cloud中内置的<code>spring-cloud-netflix</code>的其他组件为我们提供了很好的解决方案：</p><ul><li>Hystrix - 实现了断路器模式，帮助控流和降级，防止集群雪崩，就像汽车的避震器</li><li>Ribbon - 提供了客户端负载均衡器</li><li>Zuul - API网关模式，帮助实现接口的路由、认证等</li></ul><p>下面主要介绍一下，各个组件在进行服务质量保证中是如何发挥作用的。</p><h3 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h3><p>Consul中注册了一致性的可用的服务列表，并通过健康检查保证这些实例都是存活的，服务注册和检查的过程如下：</p><ul><li>服务启动完成，服务端口开始监听时，<code>spring-cloud-consul</code>通过Consul接口发起服务注册，将服务的<code>/health</code>作为健康检查端点；</li><li>Consul每隔5秒访问<code>/health</code>，检查当前微服务是否为<code>UP</code>状态；</li><li><code>/health</code>将会收集微服务内各个仪表收集上来的状态数据，主要包括数据库、消息队列是否连通等；</li><li>如果为UP状态，则微服务实例被标记为健康可用，否则被标记成失败；</li><li>当服务关闭时，先从Consul中取消服务注册，再优雅停机。</li></ul><p>这样能够保证Consul中列出的所有微服务状态都是健康可用的，各个微服务会监视微服务实例列表，自动同步更新他们。</p><h3 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h3><p>Hystrix提供了断路器模式的实现，主要在三个方面可以说明：</p><p><img src="/images/fx/07-flow-hystrix.png" alt="hystrix-command-flow-chart"></p><p><em>图片来自Hystrix项目文档</em></p><p>首先Hystrix提供了降级方法，断路器开启时，操作请求会快速失败不再向后投递，直接调用fallback方法来返回操作；当操作失败、被拒或者超时后，也会直接调用fallback方法返回操作。这可以保证在系统过载时，能有后备方案来返回一个操作，或者优雅的提示错误信息。断路器的存在能让故障业务被隔离，防止过载的流量涌入打死后端数据库等。</p><p>然后是基于请求数据统计的断路开关，在Hystrix中维护一个请求统计了列表（默认最多10条），列表中的每一项是一个桶。每个桶记录了在这个桶的时间范围内（默认是1秒），请求的成功数、失败数、超时数、被拒数。其中当失败请求的比例高于某一值时，将会触发断路器工作。</p><p>最后是不同的请求命令（<code>HystrixCommand</code>）可以使用彼此隔离的资源池，不会发生相互的挤占。在Hystrix中提供了两种隔离机制，包括线程池和信号量。线程池模式下，通过线程池的大小来限制同时占用资源的请求命令数目；信号量模式下通过控制进入临界区的操作数目来达到限流的目的。</p><p>这里包括了Hystrix的一些重要参数的配置项：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>circuitBreaker.requestVolumeThreshold</td><td>至少在一个统计窗口内有多少个请求后，才执行断路器的开关，默认20</td></tr><tr><td>circuitBreaker.sleepWindowInMilliseconds</td><td>断路器触发后多久后才进行下一次判定，默认5000毫秒</td></tr><tr><td>circuitBreaker.errorThresholdPercentage</td><td>一个统计窗口内百分之多少的请求失败才触发熔断，默认是50%</td></tr><tr><td>execution.isolation.strategy</td><td>运行隔离策略，支持<code>Thread</code>，<code>Semaphore</code>，前者通过线程池来控制同时运行的命令，后者通过信号来控制，默认是<code>Thread</code></td></tr><tr><td>execution.isolation.thread.interruptOnTimeout</td><td>命令执行的超时时间，默认1000毫秒</td></tr><tr><td>coreSize</td><td>线程池大小，默认10</td></tr><tr><td>keepAliveTimeMinutes</td><td>线程存活时间，默认为1分钟</td></tr><tr><td>maxQueueSize</td><td>最大队列长度，-1使用SynchronousQueue，默认-1。</td></tr><tr><td>queueSizeRejectionThreshold</td><td>允许队列堆积的最大数量</td></tr></tbody></table><h3 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h3><p>Ribbon使用Consul提供的服务实例列表，可以通过服务名选取一个后端服务实例连接，并保证后端流量均匀分布。<code>spring-cloud-netflix</code>整合了OpenFeign、Hystrix和Ribbon的负载均衡器，整个调用过程如下（返回值路径已经省略）：</p><p><img src="/images/fx/09-flow-spring-ribbon.png" alt=""></p><p>在这个过程中，各个组件扮演的角色如下：</p><ul><li>Feign作为客户端工厂，负责生成客户端对象，请求和应答的编解码</li><li>Hystrix提供限流、断路器、降级、数据统计</li><li>Ribbon提供负载均衡器</li></ul><p>Feign负责提供客户端接口收调用，把发起请求操作（包括编码、解码和请求数据）封装成一个Hystrix命令，这个命令包裹的请求对象，会被Ribbon的负载均衡器处理，按照负载均衡策略选择一个主机，然后交给请求对象绑定的HTTP客户端对象发请求，响应成功或者不成功的结果，返回给Hystrix。</p><p><code>spring-cloud-netflix</code>中默认使用了Ribbon的<code>ZoneAwareLoadBalancer</code>负载均衡器，它的负载均衡策略的核心指标是平均活跃请求数（Average Active Requests）。<code>ZoneAwareLoadBalancer</code>会拉取所有当前可用的服务器列表，然后将目前由于种种原因（比如网络异常）响应过慢的实例暂时从可用服务实例列表中移除，这样的机制可以保证故障实例被隔离，以免继续向其发送流量导致集群状态进一步恶化。不过由于目前<code>spring-cloud-consul</code>还不支持通过consul来指定服务实例的所在区，我们正在努力将这一功能完善。除了选区策略外，Ribbon中还提供了其他的负载均衡器，也可以自定义合适的负载均衡器。</p><p>总的来看，<code>spring-cloud-netflix</code>和Ribbon中提供了基本的负载均衡策略，对于我们来说已经足够用了。但实践中，如果需要进行灰度发布或者需要进行流量压测，目前来看还很难直接实现。而这些特性在Dubbo则开箱即用。</p><h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><p>Zuul为使用Java语言的接入层服务提供API网关服务，既可以根据配置反向代理指定的接口，也可以根据服务发现自动配置。Zuul提供了类似于iptables的处理机制，来帮助我们实现验证权鉴、日志等，请求工作流如下所示：</p><p><img src="/images/fx/10-flow-zuul.png" alt="zuul-lifecycle"><br>图片来自Zuul官方文档。</p><p>使用Zuul进行反向代理时，同样会走与OpenFeign类似的请求过程，确保API的调用过程也能通过Hystrix、Ribbon提供的降级、控流机制。</p><h3 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix Dashboard"></a>Hystrix Dashboard</h3><p>Hystrix会统计每个请求操作的情况来帮助控制断路器，这些数据是可以暴露出来供监控系统热点。Hystrix Dashboard可以将当前接口调用的情况以图形形式展示出来：</p><p><img src="/images/fx/11-flow-hystrix-dashboard.png" alt="hystrix-dashboard-netflix-api-example"></p><p>图片来自Hystrix Dashboard官方示例</p><p>Hystrix Dashboard既可以集成在其他项目中，也可以独立运行。我们直接使用Docker启动一个Hystrix Dashboard服务即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --rm -ti -p 7979:7979 kennedyoliveira/hystrix-dashboard</div></pre></td></tr></table></figure><p>为了实现能对整个微服务集群的接口调用情况汇总，可以使用<code>spring-cloud-netflix-turbine</code>来将整个集群的调用情况汇集起来，供Hystrix Dashboard展示。</p><h3 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h3><p>微服务的日志直接输出到标准输出/标准错误中，再由Docker通过syslog日志驱动将日志写入至节点机器机的rsyslog中。rsyslog在本地暂存并转发至日志中心节点的Logstash中，既归档存储，又通过ElasticSearch进行索引，日志可以通过Kibana展示报表。</p><p><img src="/images/fx/12-flow-elk.png" alt="logs"></p><p>在rsyslog的日志收集时，需要将容器信息和镜像信息加入到tag中，通过Docker启动参数来进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--log-driver syslog --log-opt tag=&quot;&#123;&#123;.ImageName&#125;&#125;/&#123;&#123;.Name&#125;&#125;/&#123;&#123;.ID&#125;&#125;&quot;</div></pre></td></tr></table></figure><p>不过rsyslog默认只允许tag不超过32个字符，这显然是不够用的，所以我们自定义了日志模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">template (name=&quot;LongTagForwardFormat&quot; type=&quot;string&quot; string=&quot;&lt;%PRI%&gt;%TIMESTAMP:::date-rfc3339% %HOSTNAME% %syslogtag%%msg:::sp-if-no-1st-sp%%msg%&quot;)</div></pre></td></tr></table></figure><p>在实际的使用过程中发现，当主机内存负载比较高时，rsyslog会发生日志无法收集的情况，报日志数据文件损坏。后来在Redhat官方找到了相关的问题，确认是rsyslog中的一个Bug导致的，当开启日志压缩时会出现这个问题，我们选择暂时把它禁用掉。</p><h2 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h2><p>我们使用领域驱动设计（DDD）的方法来构建微服务，因为微服务架构和DDD有一种天然的契合。把所有业务划分成若干个子领域，有强内在关联关系的领域（界限上下文）应当被放在一起作为一个微服务。最后形成了界限上下文-工作团队-微服务一一对应的关系：</p><ul><li>身份与访问 - 团队A - 成员微服务</li><li>商品与促销 - 团队B - 商品微服务</li><li>订单交易 - 团队C - 交易微服务</li><li>…</li></ul><h3 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h3><p>在设计单个微服务（Epic层的微服务）时，我们这样做：</p><ul><li>使用OOD方法对业务进行领域建模，领域模型应当是充血模型</li><li>领域服务帮助完成多个领域对象协作</li><li>事件驱动，提供领域事件，供内部或者其他微服务使用</li><li>依赖倒置，在适配器接口中实现和框架、组件、SDK的整合</li></ul><p>这给我们带来了显著的好处：</p><ul><li>服务开发时关注于业务，边界合理清晰</li><li>容易直接对领域模型进行单元测试</li><li>不依赖特定组件或者平台</li></ul><h3 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h3><p>从单体应用迁移到微服务架构时，不得不面临的问题之一就是事务。在单体应用时代，所有业务共享同一个数据库，一次请求操作可放置在同一个数据库事务中；在微服务架构下，这件事变得非常困难。然而事务问题不可避免，非常关键。</p><p>解决事务问题时，最先想到的解决方法通常是分布式事务。分布式事务在传统系统中应用的比较广泛，主要基于两阶段提交的方式实现。然而分布式事务在微服务架构中可行性并不高，主要基于这些考虑：</p><ul><li>分布式事务需要事务管理器，对于不同语言平台来说，几乎没有有一致的实现来进行事务管理；</li><li>并非所有的持久化基施都提供完整ACID的事务，比如现在广泛使用的NoSQL；</li><li>分布式事务存在性能问题。</li></ul><p>根据CAP理论，分布式系统不可兼得一致性、可用性、分区容错性（可靠性）三者，对于微服务架构来讲，我们通常会保证可用性、容错性，牺牲一部分一致性，追求最终一致性。所以对于微服务架构来说，使用分布式事务来解决事务问题无论是从成本还是收益上来看，都不划算。</p><p>对微服务系统来说解决事务问题，CQRS+Event Sourcing是更好的选择。</p><p>CQRS是命令和查询职责分离的缩写。CQRS的核心观点是，把操作分为修改状态的命令（Command），和返回数据的查询（Query），前者对应于“写”的操作，不能返回数据，后者对应于“读”的操作，不造成任何影响，由此领域模型被一分为二，分而治之。</p><p>Event Sourcing通常被翻译成事件溯源，简单的来说就是某一对象的当前状态，是由一系列的事件叠加后产生的，存储这些事件即可通过重放获得对象在任一时间节点上的状态。</p><p>通过CQRS+Event Sourcing，我们很容易获得最终一致性，例如对于一个跨系统的交易过程而言：</p><ul><li>用户在交易微服务提交下单命令，产生领域事件<code>PlaceOrderEvent</code>，订单状态<code>PENDING</code>；</li><li>支付微服务收到领域事件进行扣款，扣款成功产生领域事件<code>PaidEvent</code>；</li><li>交易微服务收到领域事件<code>PaidEvent</code>，将订单标记为<code>CREATED</code>；</li><li>若支付微服务发现额度不足扣款失败，产生领域事件<code>InsufficientEvent</code>，交易微服务消费将订单标记为<code>CANCELED</code>。</li></ul><p>我们只要保证领域事件能被持久化，那么即使出现网络延迟或部分系统失效，我们也能保证最终一致性。</p><p>实践上，我们利用Spring从4.2版本开始支持的自定义应用事件机制将本地事务和事件投递结合起来进行：</p><ul><li>领域内业务过程会产生领域事件，通过Spring的应用事件机制进行应用内投递；</li><li>监听相应的领域事件，在事务提交前投递至消息队列；</li><li>以上全都没有异常发生，则本地事务提交，如果出现异常，本地事务回滚。</li></ul><h3 id="一些小经验"><a href="#一些小经验" class="headerlink" title="一些小经验"></a>一些小经验</h3><ul><li>使用Spring Configured实现非Spring Bean的依赖注入（自己new的对象也可以注入了，对充血模型非常有用）</li><li>使用Swagger UI实现自文档的微服务，写好接口即有文档，即可调试</li></ul><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><p>到目前为止我们已经有数十个微服务运行于线上了，微服务数目甚至多过了团队人数。如果没有DevOps支持，运维这些微服务将是一场灾难。<br>我们使用Docker镜像作为微服务交付的标准件：</p><ul><li>Gitlab管理团队项目代码</li><li>Gitlab-CI提供构建打包，大家提交的项目都要构建并跑通测试</li><li>使用Rancher作为Docker调度平台，Merge后RC分支自动部署</li><li>测试通过后统一上线发布</li></ul><p>由于时间所限，这里就不展开赘述了。</p><h2 id="永不完美"><a href="#永不完美" class="headerlink" title="永不完美"></a>永不完美</h2><p>基于<code>spring-cloud-consul</code>的配置管理仍然需要完善，对于大规模应用的环境中，配置的版本控制、灰度、回滚等非常重要。SpringCloud提供了一个核，但是具体的使用还要结合场景、需求和环境等，再做一些工作。</p><p>对于非JVM语言的微服务和基于SpringCloud的微服务如何协同治理，这一问题仍然值得探索。包括像与Docker编排平台，特别是与Mesos协同进行伸缩的服务治理，还需要更多的实践来支持。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>是否选用微服务架构，应当根据业务实际情况进行判断，切勿跟风为了微服务而微服务；</li><li>目前来看还没有微服务全栈框架，Spring Cloud也未必是最优方案，技术选型还是应当务实；</li><li>微服务架构下，对于业务的理解拆分、领域建模等提出了更高的要求，相比框架，它们才是微服务架构的基石；</li><li>DevOps是微服务实践中的重要一环，不容小视。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;爱油科技基于SpringCloud的微服务实践&quot;&gt;&lt;a href=&quot;#爱油科技基于SpringCloud的微服务实践&quot; class=&quot;headerlink&quot; title=&quot;爱油科技基于SpringCloud的微服务实践&quot;&gt;&lt;/a&gt;爱油科技基于SpringCloud的微服务实践&lt;/h1&gt;&lt;h2 id=&quot;个人简介&quot;&gt;&lt;a href=&quot;#个人简介&quot; class=&quot;headerlink&quot; title=&quot;个人简介&quot;&gt;&lt;/a&gt;个人简介&lt;/h2&gt;&lt;p&gt;刘思贤（微博&lt;a href=&quot;http://weibo.com/starlight36&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;@starlight36&lt;/a&gt;），爱油科技架构师、PMP。主要负责业务平台架构设计，DevOps实施和研发过程持续改进等，关注领域驱动设计与微服务、建设高效团队和工程师文化培养。&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本次分享主要介绍了爱油科技基于Docker和Spring Cloud将整体业务微服务化的一些实践经验，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务架构的分层和框架选型&lt;/li&gt;
&lt;li&gt;服务发现和配置管理&lt;/li&gt;
&lt;li&gt;服务集成和服务质量保证&lt;/li&gt;
&lt;li&gt;基于领域驱动设计&lt;/li&gt;
&lt;li&gt;实施DevOps
    
    </summary>
    
      <category term="社区" scheme="http://lvqingyan.com/categories/%E7%A4%BE%E5%8C%BA/"/>
    
    
      <category term="Spring Cloud Eureka" scheme="http://lvqingyan.com/tags/Spring-Cloud-Eureka/"/>
    
      <category term="实践分享" scheme="http://lvqingyan.com/tags/%E5%AE%9E%E8%B7%B5%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Eureka服务下线(Cancel)源码分析</title>
    <link href="http://lvqingyan.com/sc-eureka-cancle/"/>
    <id>http://lvqingyan.com/sc-eureka-cancle/</id>
    <published>2016-11-19T06:00:00.000Z</published>
    <updated>2018-04-23T14:59:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>:在本篇文章中主要对Eureka的Cancel(服务下线)进行源码分析，在Service Provider服务shut down的时候，需要及时通知Eureka Server把自己剔除，从而避免其它客户端调用已经下线的服务，导致服务不可用。</p><h2 id="Cancel-服务下线"><a href="#Cancel-服务下线" class="headerlink" title="Cancel(服务下线)"></a>Cancel(服务下线)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在Service Provider服务shut down的时候，需要及时通知Eureka Server把自己剔除，从而避免客户端调用已经下线的服务。</p><h2 id="服务提供者端源码分析"><a href="#服务提供者端源码分析" class="headerlink" title="服务提供者端源码分析"></a>服务提供者端源码分析</h2><ol><li>在eureka-client-1.4.1中的com.netflix.discovery.DiscoveryClient中shutdown()的<code>867</code>行。<a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Shuts down Eureka Client. Also sends a deregistration request to the</div><div class="line">    * eureka server.</div><div class="line">    */</div><div class="line">   <span class="meta">@PreDestroy</span></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (isShutdown.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">           logger.info(<span class="string">"Shutting down DiscoveryClient ..."</span>);</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (statusChangeListener != <span class="keyword">null</span> &amp;&amp; applicationInfoManager != <span class="keyword">null</span>) &#123;</div><div class="line">               applicationInfoManager.unregisterStatusChangeListener(statusChangeListener.getId());</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           cancelScheduledTasks();</div><div class="line"></div><div class="line">           <span class="comment">// If APPINFO was registered</span></div><div class="line">           <span class="keyword">if</span> (applicationInfoManager != <span class="keyword">null</span> &amp;&amp; clientConfig.shouldRegisterWithEureka()) &#123;</div><div class="line">               applicationInfoManager.setInstanceStatus(InstanceStatus.DOWN);</div><div class="line">               <span class="comment">//调用下线接口</span></div><div class="line">               unregister();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (eurekaTransport != <span class="keyword">null</span>) &#123;</div><div class="line">               eurekaTransport.shutdown();</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           heartbeatStalenessMonitor.shutdown();</div><div class="line">           registryStalenessMonitor.shutdown();</div><div class="line"></div><div class="line">           logger.info(<span class="string">"Completed shut down of DiscoveryClient"</span>);</div><div class="line">       &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></li></ol><blockquote><p><code>Tips</code> <code>@PreDestroy</code>注解或<code>shutdown()</code>的方法是服务下线的入口</p></blockquote><ol><li>在eureka-client-1.4.1中的<code>com.netflix.discovery.DiscoveryClient</code>中<code>unregister（）</code>的<code>897</code>行<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">  * unregister w/ the eureka service.</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// It can be null if shouldRegisterWithEureka == false</span></div><div class="line">  <span class="keyword">if</span>(eurekaTransport != <span class="keyword">null</span> &amp;&amp; eurekaTransport.registrationClient != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">         logger.info(<span class="string">"Unregistering ..."</span>);</div><div class="line">         <span class="comment">//发送服务下线请求</span></div><div class="line">         EurekaHttpResponse&lt;Void&gt; httpResponse = eurekaTransport.registrationClient.cancel(instanceInfo.getAppName(), instanceInfo.getId());</div><div class="line">         logger.info(PREFIX + appPathIdentifier + <span class="string">" - deregister  status: "</span> + httpResponse.getStatusCode());</div><div class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                logger.error(PREFIX + appPathIdentifier + <span class="string">" - de-registration failed"</span> + e.getMessage(), e);</div><div class="line">      &#125;</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h2 id="Eureka-Server服务下线实现细节"><a href="#Eureka-Server服务下线实现细节" class="headerlink" title="Eureka Server服务下线实现细节"></a>Eureka Server服务下线实现细节</h2><ol><li><p>在<code>com.netflix.eureka.resources.InstanceResource</code>中的<code>280</code>行中的<code>cancelLease()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@DELETE</span></div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">cancelLease</span><span class="params">(</span></span></div><div class="line"> @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) &#123;</div><div class="line">   <span class="comment">//调用cancel</span></div><div class="line">   <span class="keyword">boolean</span> isSuccess = registry.cancel(app.getName(), id,</div><div class="line">                <span class="string">"true"</span>.equals(isReplication));</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (isSuccess) &#123;</div><div class="line">     logger.debug(<span class="string">"Found (Cancel): "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">            <span class="keyword">return</span> Response.ok().build();</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     logger.info(<span class="string">"Not Found (Cancel): "</span> + app.getName() + <span class="string">" - "</span> + id);</div><div class="line">            <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>在<code>org.springframework.cloud.netflix.eureka.server.InstanceRegistry</code>中的<code>95</code>行的<code>cancel()</code>方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(String appName, String serverId, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">   handleCancelation(appName, serverId, isReplication);</div><div class="line">   <span class="comment">//调用父类中的cancel</span></div><div class="line">   <span class="keyword">return</span> <span class="keyword">super</span>.cancel(appName, serverId, isReplication);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>在<code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl</code>中的<code>376</code>行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id,</span></span></div><div class="line">                          <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication) &#123;</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">super</span>.cancel(appName, id, isReplication)) &#123;</div><div class="line">            <span class="comment">//服务下线成功后，同步更新信息到其它Eureka Server节点</span></div><div class="line">            replicateToPeers(Action.Cancel, appName, id, <span class="keyword">null</span>, <span class="keyword">null</span>, isReplication);</div><div class="line">            <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="comment">// Since the client wants to cancel it, reduce the threshold (1 for 30 seconds, 2 for a minute)</span></div><div class="line">                    <span class="keyword">this</span>.expectedNumberOfRenewsPerMin = <span class="keyword">this</span>.expectedNumberOfRenewsPerMin - <span class="number">2</span>;</div><div class="line">                    <span class="keyword">this</span>.numberOfRenewsPerMinThreshold =</div><div class="line">                            (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>4.在com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl中的<code>618</code>行，主要接口实现方式和register基本一致：首先更新自身Eureka Server中服务的状态，再同步到其它Eureka Server中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateToPeers</span><span class="params">(Action action, String appName, String id,</span></span></div><div class="line">                                  InstanceInfo info <span class="comment">/* optional */</span>,</div><div class="line">                                  InstanceStatus newStatus <span class="comment">/* optional */</span>, <span class="keyword">boolean</span> isReplication) &#123;</div><div class="line">        Stopwatch tracer = action.getTimer().start();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (isReplication) &#123;</div><div class="line">                numberOfReplicationsLastMin.increment();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// If it is a replication already, do not replicate again as this will create a poison replication</span></div><div class="line">            <span class="keyword">if</span> (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 同步把服务信息同步到其它的Eureka Server中</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;</div><div class="line">                <span class="comment">// If the url represents this host, do not replicate to yourself.</span></div><div class="line">                <span class="keyword">if</span> (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//根据action做相应操作的同步</span></div><div class="line">                replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            tracer.stop();</div><div class="line">        &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>至此，Eureka服务续约源码分析结束，大家有兴趣可自行阅读。</p><h3 id="源码分析链接"><a href="#源码分析链接" class="headerlink" title="源码分析链接"></a>源码分析链接</h3><p> 其它源码分析链接:<br> Spring Cloud中@EnableEurekaClient源码分析:<br> <a href="http://xujin.org/sc/sc-enableEurekaClient-annonation/" target="_blank" rel="external">http://xujin.org/sc/sc-enableEurekaClient-annonation/</a><br> Spring Cloud Eureka服务注册源码分析：<br> <a href="http://xujin.org/sc/sc-eureka-register/" target="_blank" rel="external">http://xujin.org/sc/sc-eureka-register/</a><br> Spring Cloud Eureka服务续约(Renew)源码分析<br> <a href="http://xujin.org/sc/sc-eureka-renew/" target="_blank" rel="external">http://xujin.org/sc/sc-eureka-renew/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;:在本篇文章中主要对Eureka的Cancel(服务下线)进行源码分析，在Service Provider服务shut down的时候，需要及时通知Eureka Server把自己剔除，从而避免其它客户端调用已经下线的服务，导致服务不可用。&lt;/p&gt;
&lt;h2 id=&quot;Cancel-服务下线&quot;&gt;&lt;a href=&quot;#Cancel-服务下线&quot; class=&quot;headerlink&quot; title=&quot;Cancel(服务下线)&quot;&gt;&lt;/a&gt;Cancel(服务下线)&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;在Service Provider服务shut down的时候，需要及时通知Eureka Server把自己剔除，从而避免客户端调用已经下线的服务。&lt;/p&gt;
&lt;h2 id=&quot;服务提供者端源码分析&quot;&gt;&lt;a href=&quot;#服务提供者端源码分析&quot; class=&quot;headerlink&quot; title=&quot;服务提供者端源码分析&quot;&gt;&lt;/a&gt;服务提供者端源码分析&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在eureka-client-1.4.1中的com.netflix.discovery.DiscoveryClient中shutdown()的&lt;code&gt;867&lt;/code&gt;行。
    
    </summary>
    
      <category term="Spring Cloud Eureka" scheme="http://lvqingyan.com/categories/Spring-Cloud-Eureka/"/>
    
    
      <category term="Spring Cloud Eureka" scheme="http://lvqingyan.com/tags/Spring-Cloud-Eureka/"/>
    
      <category term="Spring Cloud 源码分析" scheme="http://lvqingyan.com/tags/Spring-Cloud-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud Eureka服务续约(Renew)源码分析</title>
    <link href="http://lvqingyan.com/sc-eureka-renew/"/>
    <id>http://lvqingyan.com/sc-eureka-renew/</id>
    <published>2016-11-13T06:00:00.000Z</published>
    <updated>2018-01-30T16:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong>:在本篇文章中主要对Eureka的Renew(服务续约)，从服务提供者发起续约请求开始分析，通过阅读源码和画时序图的方式，展示Eureka服务续约的整个生命周期。服务续约主要是把服务续约的信息更新到自身的Eureka Server中，然后再同步到其它Eureka Server中。</p><h2 id="Renew-服务续约"><a href="#Renew-服务续约" class="headerlink" title="Renew(服务续约)"></a>Renew(服务续约)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Renew（服务续约）操作由Service Provider定期调用，类似于heartbeat。目的是隔一段时间Service Provider调用接口，告诉Eureka Server它还活着没挂，不要把它T了。通俗的说就是它们两之间的心跳检测，避免服务提供者被剔除掉。<br>请参考:<a href="http://blog.xujin.org/sc/sc-eureka-mid/#名词解释" target="_blank" rel="external">Spring Cloud Eureka名词解释</a><br><a id="more"></a></p><h3 id="服务续约配置"><a href="#服务续约配置" class="headerlink" title="服务续约配置"></a>服务续约配置</h3><p>  Renew操作会在Service Provider定时发起，用来通知Eureka Server自己还活着。 这里有两个比较重要的配置需要如下，可以在Run之前配置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.instance.leaseRenewalIntervalInSeconds</div></pre></td></tr></table></figure></p><p>  Renew频率。默认是<code>30秒</code>，也就是每30秒会向Eureka Server发起Renew操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eureka.instance.leaseExpirationDurationInSeconds</div></pre></td></tr></table></figure></p><p> 服务失效时间。默认是<code>90秒</code>，也就是如果Eureka Server在90秒内没有接收到来自Service Provider的Renew操作，就会把<code>Service Provider剔除</code>。</p><h2 id="Renew源码分析"><a href="#Renew源码分析" class="headerlink" title="Renew源码分析"></a>Renew源码分析</h2><h3 id="服务提供者实现细节"><a href="#服务提供者实现细节" class="headerlink" title="服务提供者实现细节"></a>服务提供者实现细节</h3><p> 服务提供者发发起服务续约的时序图，如下图所示,大家先直观的看一下时序图，等阅读完源码再回顾一下。<br><img src="/images/spring-cloud-netflix/eureka/service-renew.png" alt="服务提供者发起续约时序图"></p><ol><li>在com.netflix.discovery.DiscoveryClient.initScheduledTasks()中的1272行，TimedSupervisorTask会定时发起服务续约，代码如下所示:<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Heartbeat timer</span></div><div class="line">  scheduler.schedule(</div><div class="line">     <span class="keyword">new</span> TimedSupervisorTask(</div><div class="line">            <span class="string">"heartbeat"</span>,</div><div class="line">             scheduler,</div><div class="line">             heartbeatExecutor,</div><div class="line">             renewalIntervalInSecs,</div><div class="line">             TimeUnit.SECONDS,</div><div class="line">             expBackOffBound,</div><div class="line">              <span class="keyword">new</span> HeartbeatThread()</div><div class="line">            ),</div><div class="line">  renewalIntervalInSecs, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></li></ol><p>2.在com.netflix.discovery.DiscoveryClient中的1393行，有一个<code>HeartbeatThread</code>线程发起续约操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="comment">//调用eureka-client中的renew</span></div><div class="line">            <span class="keyword">if</span> (renew()) &#123;</div><div class="line">                lastSuccessfulHeartbeatTimestamp = System.currentTimeMillis();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>renew()调用eureka-client-1.4.11.jarcom.netflix.discovery.DiscoveryClient中<code>829</code>行renew()发起<code>PUT Reset</code>请求，调用com.netflix.eureka.resources.InstanceResource中的renewLease()续约。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * Renew with the eureka service by making the appropriate REST call</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">       EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           httpResponse = eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, <span class="keyword">null</span>);</div><div class="line">           logger.debug(<span class="string">"&#123;&#125; - Heartbeat status: &#123;&#125;"</span>, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</div><div class="line">           <span class="keyword">if</span> (httpResponse.getStatusCode() == <span class="number">404</span>) &#123;</div><div class="line">               REREGISTER_COUNTER.increment();</div><div class="line">               logger.info(<span class="string">"&#123;&#125; - Re-registering apps/&#123;&#125;"</span>, PREFIX + appPathIdentifier, instanceInfo.getAppName());</div><div class="line">               <span class="keyword">return</span> register();</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> httpResponse.getStatusCode() == <span class="number">200</span>;</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">           logger.error(<span class="string">"&#123;&#125; - was unable to send heartbeat!"</span>, PREFIX + appPathIdentifier, e);</div><div class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">       &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><h3 id="Netflix中的Eureka-Core实现细节"><a href="#Netflix中的Eureka-Core实现细节" class="headerlink" title="Netflix中的Eureka Core实现细节"></a>Netflix中的Eureka Core实现细节</h3><p>   NetFlix中Eureka Core中的服务续约时序图，如下图所示。<br>  <img src="/images/spring-cloud-netflix/eureka/eureka-renew.png" alt="服务续约时序图"></p><ol><li><p>打开<code>com.netflix.eureka.resources.InstanceResource</code>中的<code>106</code>行的<code>renewLease()</code>方法，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry</div><div class="line"><span class="meta">@PUT</span></div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">renewLease</span><span class="params">(</span></span></div><div class="line">        @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication,</div><div class="line">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"overriddenstatus"</span>)</span> String overriddenStatus,</div><div class="line">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"status"</span>)</span> String status,</div><div class="line">        @<span class="title">QueryParam</span><span class="params">(<span class="string">"lastDirtyTimestamp"</span>)</span> String lastDirtyTimestamp) &#123;</div><div class="line">    <span class="keyword">boolean</span> isFromReplicaNode = <span class="string">"true"</span>.equals(isReplication);</div><div class="line">    <span class="comment">//调用</span></div><div class="line">    <span class="keyword">boolean</span> isSuccess = registry.renew(app.getName(), id, isFromReplicaNode);</div><div class="line">    <span class="comment">//其余省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>点开registry.renew(app.getName(), id, isFromReplicaNode);我们可以看到，调用了<code>org.springframework.cloud.netflix.eureka.server.InstanceRegistry</code>中的<code>renew（）</code>方法，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String serverId,</span></span></div><div class="line"><span class="keyword">boolean</span> isReplication) &#123;</div><div class="line">log(<span class="string">"renew "</span> + appName + <span class="string">" serverId "</span> + serverId + <span class="string">", isReplication &#123;&#125;"</span></div><div class="line">+ isReplication);</div><div class="line">List&lt;Application&gt; applications = getSortedApplications();</div><div class="line"><span class="keyword">for</span> (Application input : applications) &#123;</div><div class="line"><span class="keyword">if</span> (input.getName().equals(appName)) &#123;</div><div class="line">InstanceInfo instance = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">for</span> (InstanceInfo info : input.getInstances()) &#123;</div><div class="line"><span class="keyword">if</span> (info.getHostName().equals(serverId)) &#123;</div><div class="line">instance = info;</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">publishEvent(<span class="keyword">new</span> EurekaInstanceRenewedEvent(<span class="keyword">this</span>, appName, serverId,</div><div class="line">instance, isReplication));</div><div class="line"><span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">        <span class="comment">//调用com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl中的renew方法</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">super</span>.renew(appName, serverId, isReplication);</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>3.从<code>super.renew()</code>看到调用了父类中的<code>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl</code>中<code>420</code>行的<code>renew()</code>方法，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(<span class="keyword">final</span> String appName, <span class="keyword">final</span> String id, <span class="keyword">final</span> <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">        <span class="comment">//服务续约成功，</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.renew(appName, id, isReplication)) &#123;</div><div class="line">            <span class="comment">//然后replicateToPeers同步其它Eureka Server中的数据</span></div><div class="line">            replicateToPeers(Action.Heartbeat, appName, id, <span class="keyword">null</span>, <span class="keyword">null</span>, isReplication);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3.1 从上面代码中<code>super.renew(appName, id, isReplication)</code>可以看出调用的是com.netflix.eureka.registry.AbstractInstanceRegistry中<code>345</code>行的renew()方法，代码如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String appName, String id, <span class="keyword">boolean</span> isReplication)</span> </span>&#123;</div><div class="line">      RENEW.increment(isReplication);</div><div class="line">      Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(appName);</div><div class="line">      Lease&lt;InstanceInfo&gt; leaseToRenew = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">if</span> (gMap != <span class="keyword">null</span>) &#123;</div><div class="line">          leaseToRenew = gMap.get(id);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (leaseToRenew == <span class="keyword">null</span>) &#123;</div><div class="line">          RENEW_NOT_FOUND.increment(isReplication);</div><div class="line">          logger.warn(<span class="string">"DS: Registry: lease doesn't exist, registering resource: &#123;&#125; - &#123;&#125;"</span>, appName, id);</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          InstanceInfo instanceInfo = leaseToRenew.getHolder();</div><div class="line">          <span class="keyword">if</span> (instanceInfo != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">// touchASGCache(instanceInfo.getASGName());</span></div><div class="line">              InstanceStatus overriddenInstanceStatus = <span class="keyword">this</span>.getOverriddenInstanceStatus(</div><div class="line">                      instanceInfo, leaseToRenew, isReplication);</div><div class="line">              <span class="keyword">if</span> (overriddenInstanceStatus == InstanceStatus.UNKNOWN) &#123;</div><div class="line">                  logger.info(<span class="string">"Instance status UNKNOWN possibly due to deleted override for instance &#123;&#125;"</span></div><div class="line">                          + <span class="string">"; re-register required"</span>, instanceInfo.getId());</div><div class="line">                  RENEW_NOT_FOUND.increment(isReplication);</div><div class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">              &#125;</div><div class="line">              <span class="keyword">if</span> (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) &#123;</div><div class="line">                  Object[] args = &#123;</div><div class="line">                          instanceInfo.getStatus().name(),</div><div class="line">                          instanceInfo.getOverriddenStatus().name(),</div><div class="line">                          instanceInfo.getId()</div><div class="line">                  &#125;;</div><div class="line">                  logger.info(</div><div class="line">                          <span class="string">"The instance status &#123;&#125; is different from overridden instance status &#123;&#125; for instance &#123;&#125;. "</span></div><div class="line">                                  + <span class="string">"Hence setting the status to overridden status"</span>, args);</div><div class="line">                  instanceInfo.setStatus(overriddenInstanceStatus);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">          renewsLastMin.increment();</div><div class="line">          leaseToRenew.renew();</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>其中 <code>leaseToRenew.renew()</code>是调用com.netflix.eureka.lease.Lease<t>中的<code>62</code>行的renew()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Renew the lease, use renewal duration if it was specified by the</div><div class="line"> * associated &#123;<span class="doctag">@link</span> T&#125; during registration, otherwise default duration is</div><div class="line"> * &#123;<span class="doctag">@link</span> #DEFAULT_DURATION_IN_SECS&#125;.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renew</span><span class="params">()</span> </span>&#123;</div><div class="line">    lastUpdateTimestamp = System.currentTimeMillis() + duration;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p><p>3.2 replicateToPeers(Action.Heartbeat, appName, id, null, null, isReplication);调用自身的<code>replicateToPeers()</code>方法，在com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl中的<code>618</code>行，主要接口实现方式和register基本一致：首先更新自身Eureka Server中服务的状态，再同步到其它Eureka Server中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replicateToPeers</span><span class="params">(Action action, String appName, String id,</span></span></div><div class="line">                                  InstanceInfo info <span class="comment">/* optional */</span>,</div><div class="line">                                  InstanceStatus newStatus <span class="comment">/* optional */</span>, <span class="keyword">boolean</span> isReplication) &#123;</div><div class="line">        Stopwatch tracer = action.getTimer().start();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (isReplication) &#123;</div><div class="line">                numberOfReplicationsLastMin.increment();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// If it is a replication already, do not replicate again as this will create a poison replication</span></div><div class="line">            <span class="keyword">if</span> (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 同步把续约信息同步到其它的Eureka Server中</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) &#123;</div><div class="line">                <span class="comment">// If the url represents this host, do not replicate to yourself.</span></div><div class="line">                <span class="keyword">if</span> (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//根据action做相应操作的同步</span></div><div class="line">                replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            tracer.stop();</div><div class="line">        &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>至此，Eureka服务续约源码分析结束，大家有兴趣可自行阅读。</p><h3 id="源码分析链接"><a href="#源码分析链接" class="headerlink" title="源码分析链接"></a>源码分析链接</h3><p> 其它源码分析链接:<br> Spring Cloud中@EnableEurekaClient源码分析:<br> <a href="http://blog.xujin.org/sc/sc-enableEurekaClient-annonation/" target="_blank" rel="external">http://blog.xujin.org/sc/sc-enableEurekaClient-annonation/</a><br> Spring Cloud Eureka服务注册源码分析：<br> <a href="http://blog.xujin.org/sc/sc-eureka-register/" target="_blank" rel="external">http://blog.xujin.org/sc/sc-eureka-register/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;:在本篇文章中主要对Eureka的Renew(服务续约)，从服务提供者发起续约请求开始分析，通过阅读源码和画时序图的方式，展示Eureka服务续约的整个生命周期。服务续约主要是把服务续约的信息更新到自身的Eureka Server中，然后再同步到其它Eureka Server中。&lt;/p&gt;
&lt;h2 id=&quot;Renew-服务续约&quot;&gt;&lt;a href=&quot;#Renew-服务续约&quot; class=&quot;headerlink&quot; title=&quot;Renew(服务续约)&quot;&gt;&lt;/a&gt;Renew(服务续约)&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;Renew（服务续约）操作由Service Provider定期调用，类似于heartbeat。目的是隔一段时间Service Provider调用接口，告诉Eureka Server它还活着没挂，不要把它T了。通俗的说就是它们两之间的心跳检测，避免服务提供者被剔除掉。&lt;br&gt;请参考:&lt;a href=&quot;http://blog.xujin.org/sc/sc-eureka-mid/#名词解释&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Spring Cloud Eureka名词解释&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Spring Cloud Eureka" scheme="http://lvqingyan.com/categories/Spring-Cloud-Eureka/"/>
    
    
      <category term="Spring Cloud Eureka" scheme="http://lvqingyan.com/tags/Spring-Cloud-Eureka/"/>
    
      <category term="Spring Cloud 源码分析" scheme="http://lvqingyan.com/tags/Spring-Cloud-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
